
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>skimage.morphology &#8212; skimage 0.24.1rc0.dev0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=61a4c737" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=87e54e7c" />
    <link rel="stylesheet" type="text/css" href="../_static/theme_overrides.css?v=4340df76" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=a22486ce"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script data-domain="scikit-image.org" defer="defer" src="https://views.scientific-python.org/js/script.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'api/skimage.morphology';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.15.4';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://scikit-image.org/docs/dev/_static/version_switcher.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = 'dev';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = true;
        </script>
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="skimage.registration" href="skimage.registration.html" />
    <link rel="prev" title="skimage.metrics" href="skimage.metrics.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">

  
     
  

<a class="navbar-brand logo" href="https://scikit-image.org">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="scikit-image's logo, showing a snake's head overlayed with green and orange"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="scikit-image's logo, showing a snake's head overlayed with green and orange"/>`);</script>
  
  
    <p class="title logo__title">scikit-image</p>
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../user_guide/index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../auto_examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="api.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../release_notes/index.html">
    Release notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../development/index.html">
    Development
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../about/index.html">
    About
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-2"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-2"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-2"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-2">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/scikit-image/scikit-image" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/scikit-image/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-box fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../user_guide/index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../auto_examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="api.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../release_notes/index.html">
    Release notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../development/index.html">
    Development
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../about/index.html">
    About
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-3"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-3"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-3"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-3">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/scikit-image/scikit-image" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/scikit-image/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-box fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="skimage.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.color.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.color</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.data.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.data</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.draw.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.draw</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.exposure.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.exposure</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.feature.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.feature</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.filters.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.filters</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.filters.rank.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.filters.rank</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.future.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.future</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.graph.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.graph</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.io.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.io</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.measure.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.measure</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.metrics.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.metrics</span></code></a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.morphology</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.registration.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.registration</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.restoration.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.restoration</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.segmentation.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.segmentation</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.transform.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.transform</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.util.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.util</span></code></a></li>
</ul>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="api.html" class="nav-link">API reference</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><code...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="module-skimage.morphology">
<span id="skimage-morphology"></span><h1><a class="reference internal" href="#module-skimage.morphology" title="skimage.morphology"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.morphology</span></code></a><a class="headerlink" href="#module-skimage.morphology" title="Link to this heading">#</a></h1>
<p>Utilities that operate on shapes in images.</p>
<p>These operations are particularly suited for binary images,
although some may be useful for images of other types as well.</p>
<p>Basic morphological operations include dilation and erosion.</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.area_closing" title="skimage.morphology.area_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_closing</span></code></a></p></td>
<td><p>Perform an area closing of the image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.area_opening" title="skimage.morphology.area_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_opening</span></code></a></p></td>
<td><p>Perform an area opening of the image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.ball" title="skimage.morphology.ball"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.ball</span></code></a></p></td>
<td><p>Generates a ball-shaped footprint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.binary_closing" title="skimage.morphology.binary_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.binary_closing</span></code></a></p></td>
<td><p>Return fast binary morphological closing of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.binary_dilation" title="skimage.morphology.binary_dilation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.binary_dilation</span></code></a></p></td>
<td><p>Return fast binary morphological dilation of an image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.binary_erosion" title="skimage.morphology.binary_erosion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.binary_erosion</span></code></a></p></td>
<td><p>Return fast binary morphological erosion of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.binary_opening" title="skimage.morphology.binary_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.binary_opening</span></code></a></p></td>
<td><p>Return fast binary morphological opening of an image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.black_tophat" title="skimage.morphology.black_tophat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.black_tophat</span></code></a></p></td>
<td><p>Return black top hat of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.closing" title="skimage.morphology.closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.closing</span></code></a></p></td>
<td><p>Return grayscale morphological closing of an image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.convex_hull_image" title="skimage.morphology.convex_hull_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.convex_hull_image</span></code></a></p></td>
<td><p>Compute the convex hull image of a binary image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.convex_hull_object" title="skimage.morphology.convex_hull_object"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.convex_hull_object</span></code></a></p></td>
<td><p>Compute the convex hull image of individual objects in a binary image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.cube" title="skimage.morphology.cube"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.cube</span></code></a></p></td>
<td><p>Generates a cube-shaped footprint.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.diameter_closing" title="skimage.morphology.diameter_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_closing</span></code></a></p></td>
<td><p>Perform a diameter closing of the image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.diameter_opening" title="skimage.morphology.diameter_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_opening</span></code></a></p></td>
<td><p>Perform a diameter opening of the image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.diamond" title="skimage.morphology.diamond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diamond</span></code></a></p></td>
<td><p>Generates a flat, diamond-shaped footprint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.dilation" title="skimage.morphology.dilation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.dilation</span></code></a></p></td>
<td><p>Return grayscale morphological dilation of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.disk" title="skimage.morphology.disk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.disk</span></code></a></p></td>
<td><p>Generates a flat, disk-shaped footprint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.ellipse" title="skimage.morphology.ellipse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.ellipse</span></code></a></p></td>
<td><p>Generates a flat, ellipse-shaped footprint.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.erosion" title="skimage.morphology.erosion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.erosion</span></code></a></p></td>
<td><p>Return grayscale morphological erosion of an image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.flood" title="skimage.morphology.flood"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.flood</span></code></a></p></td>
<td><p>Mask corresponding to a flood fill.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.flood_fill" title="skimage.morphology.flood_fill"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.flood_fill</span></code></a></p></td>
<td><p>Perform flood filling on an image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.footprint_from_sequence" title="skimage.morphology.footprint_from_sequence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.footprint_from_sequence</span></code></a></p></td>
<td><p>Convert a footprint sequence into an equivalent ndarray.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.h_maxima" title="skimage.morphology.h_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.h_maxima</span></code></a></p></td>
<td><p>Determine all maxima of the image with height &gt;= h.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.h_minima" title="skimage.morphology.h_minima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.h_minima</span></code></a></p></td>
<td><p>Determine all minima of the image with depth &gt;= h.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.isotropic_closing" title="skimage.morphology.isotropic_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.isotropic_closing</span></code></a></p></td>
<td><p>Return binary morphological closing of an image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.isotropic_dilation" title="skimage.morphology.isotropic_dilation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.isotropic_dilation</span></code></a></p></td>
<td><p>Return binary morphological dilation of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.isotropic_erosion" title="skimage.morphology.isotropic_erosion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.isotropic_erosion</span></code></a></p></td>
<td><p>Return binary morphological erosion of an image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.isotropic_opening" title="skimage.morphology.isotropic_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.isotropic_opening</span></code></a></p></td>
<td><p>Return binary morphological opening of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.label" title="skimage.morphology.label"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.label</span></code></a></p></td>
<td><p>Label connected regions of an integer array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.local_maxima" title="skimage.morphology.local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.local_maxima</span></code></a></p></td>
<td><p>Find local maxima of n-dimensional array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.local_minima" title="skimage.morphology.local_minima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.local_minima</span></code></a></p></td>
<td><p>Find local minima of n-dimensional array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.max_tree</span></code></a></p></td>
<td><p>Build the max tree from an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.max_tree_local_maxima" title="skimage.morphology.max_tree_local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.max_tree_local_maxima</span></code></a></p></td>
<td><p>Determine all local maxima of the image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.medial_axis</span></code></a></p></td>
<td><p>Compute the medial axis transform of a binary image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.mirror_footprint" title="skimage.morphology.mirror_footprint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.mirror_footprint</span></code></a></p></td>
<td><p>Mirror each dimension in the footprint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.octagon" title="skimage.morphology.octagon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.octagon</span></code></a></p></td>
<td><p>Generates an octagon shaped footprint.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.octahedron" title="skimage.morphology.octahedron"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.octahedron</span></code></a></p></td>
<td><p>Generates a octahedron-shaped footprint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.opening" title="skimage.morphology.opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.opening</span></code></a></p></td>
<td><p>Return grayscale morphological opening of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.pad_footprint" title="skimage.morphology.pad_footprint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.pad_footprint</span></code></a></p></td>
<td><p>Pad the footprint to an odd size along each dimension.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.reconstruction" title="skimage.morphology.reconstruction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.reconstruction</span></code></a></p></td>
<td><p>Perform a morphological reconstruction of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.rectangle" title="skimage.morphology.rectangle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.rectangle</span></code></a></p></td>
<td><p>Generates a flat, rectangular-shaped footprint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.remove_objects_by_distance" title="skimage.morphology.remove_objects_by_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.remove_objects_by_distance</span></code></a></p></td>
<td><p>Remove objects, in specified order, until remaining are a minimum distance apart.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.remove_small_holes" title="skimage.morphology.remove_small_holes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_holes</span></code></a></p></td>
<td><p>Remove contiguous holes smaller than the specified size.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.remove_small_objects" title="skimage.morphology.remove_small_objects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_objects</span></code></a></p></td>
<td><p>Remove objects smaller than the specified size.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.skeletonize</span></code></a></p></td>
<td><p>Compute the skeleton of a binary image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.square" title="skimage.morphology.square"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.square</span></code></a></p></td>
<td><p>Generates a flat, square-shaped footprint.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.star" title="skimage.morphology.star"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.star</span></code></a></p></td>
<td><p>Generates a star shaped footprint.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.thin" title="skimage.morphology.thin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.thin</span></code></a></p></td>
<td><p>Perform morphological thinning of a binary image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.white_tophat" title="skimage.morphology.white_tophat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.white_tophat</span></code></a></p></td>
<td><p>Return white top hat of an image.</p></td>
</tr>
</tbody>
</table>
</div>
<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.area_closing">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">area_closing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">area_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_traverser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/max_tree.py#L367-L494"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.area_closing" title="Link to this definition">#</a></dt>
<dd><p>Perform an area closing of the image.</p>
<p>Area closing removes all dark structures of an image with
a surface smaller than area_threshold.
The output image is larger than or equal to the input image
for every pixel and all local minima have at least a surface of
area_threshold pixels.</p>
<p>Area closings are similar to morphological closings, but
they do not use a fixed footprint, but rather a deformable
one, with surface = area_threshold.</p>
<p>In the binary case, area closings are equivalent to
remove_small_holes; this operator is thus extended to gray-level images.</p>
<p>Technically, this operator is based on the max-tree representation of
the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the area_closing is to be calculated.
This image can be of any type.</p>
</dd>
<dt><strong>area_threshold</strong><span class="classifier">unsigned int</span></dt><dd><p>The size parameter (number of pixels). The default value is arbitrarily
chosen to be 64.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">unsigned int, optional</span></dt><dd><p>The neighborhood connectivity. The integer represents the maximum
number of orthogonal steps to reach a neighbor. In 2D, it is 1 for
a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p>
</dd>
<dt><strong>parent</strong><span class="classifier">ndarray, int64, optional</span></dt><dd><p>Parent image representing the max tree of the inverted image. The
value of each pixel is the index of its parent in the ravelled array.
See Note for further details.</p>
</dd>
<dt><strong>tree_traverser</strong><span class="classifier">1D array, int64, optional</span></dt><dd><p>The ordered pixel indices (referring to the ravelled array). The pixels
are ordered such that every pixel is preceded by its parent (except for
the root which has no parent).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>Output image of the same shape and type as input image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.area_opening" title="skimage.morphology.area_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_opening</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.diameter_opening" title="skimage.morphology.diameter_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_opening</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.diameter_closing" title="skimage.morphology.diameter_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_closing</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.max_tree</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.remove_small_objects" title="skimage.morphology.remove_small_objects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_objects</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.remove_small_holes" title="skimage.morphology.remove_small_holes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_holes</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If a max-tree representation (parent and tree_traverser) are given to the
function, they must be calculated from the inverted image for this
function, i.e.:
&gt;&gt;&gt; P, S = max_tree(invert(f))
&gt;&gt;&gt; closed = diameter_closing(f, 3, parent=P, tree_traverser=S)</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rce2615f30276-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Vincent L., Proc. “Grayscale area openings and closings,
their efficient implementation and applications”,
EURASIP Workshop on Mathematical Morphology and its
Applications to Signal Processing, Barcelona, Spain, pp.22-27,
May 1993.</p>
</div>
<div class="citation" id="rce2615f30276-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Soille, P., “Morphological Image Analysis: Principles and
Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.
<a class="reference external" href="https://doi.org/10.1007/978-3-662-05088-0">DOI:10.1007/978-3-662-05088-0</a></p>
</div>
<div class="citation" id="rce2615f30276-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Salembier, P., Oliveras, A., &amp; Garrido, L. (1998). Antiextensive
Connected Operators for Image and Sequence Processing.
IEEE Transactions on Image Processing, 7(4), 555-570.
<a class="reference external" href="https://doi.org/10.1109/83.663500">DOI:10.1109/83.663500</a></p>
</div>
<div class="citation" id="rce2615f30276-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p>Najman, L., &amp; Couprie, M. (2006). Building the component tree in
quasi-linear time. IEEE Transactions on Image Processing, 15(11),
3531-3539.
<a class="reference external" href="https://doi.org/10.1109/TIP.2006.877518">DOI:10.1109/TIP.2006.877518</a></p>
</div>
<div class="citation" id="rce2615f30276-5" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of
Component Tree Computation Algorithms. IEEE Transactions on Image
Processing, 23(9), 3885-3895.
<a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<p>We create an image (quadratic function with a minimum in the center and
4 additional local minima.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">+</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">160</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">140</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate the area closing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">closed</span> <span class="o">=</span> <span class="n">area_closing</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>All small minima are removed, and the remaining minima have at least
a size of 8.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.area_opening">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">area_opening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">area_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_traverser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/max_tree.py#L150-L262"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.area_opening" title="Link to this definition">#</a></dt>
<dd><p>Perform an area opening of the image.</p>
<p>Area opening removes all bright structures of an image with
a surface smaller than area_threshold.
The output image is thus the largest image smaller than the input
for which all local maxima have at least a surface of
area_threshold pixels.</p>
<p>Area openings are similar to morphological openings, but
they do not use a fixed footprint, but rather a deformable
one, with surface = area_threshold. Consequently, the area_opening
with area_threshold=1 is the identity.</p>
<p>In the binary case, area openings are equivalent to
remove_small_objects; this operator is thus extended to gray-level images.</p>
<p>Technically, this operator is based on the max-tree representation of
the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the area_opening is to be calculated.
This image can be of any type.</p>
</dd>
<dt><strong>area_threshold</strong><span class="classifier">unsigned int</span></dt><dd><p>The size parameter (number of pixels). The default value is arbitrarily
chosen to be 64.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">unsigned int, optional</span></dt><dd><p>The neighborhood connectivity. The integer represents the maximum
number of orthogonal steps to reach a neighbor. In 2D, it is 1 for
a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p>
</dd>
<dt><strong>parent</strong><span class="classifier">ndarray, int64, optional</span></dt><dd><p>Parent image representing the max tree of the image. The
value of each pixel is the index of its parent in the ravelled array.</p>
</dd>
<dt><strong>tree_traverser</strong><span class="classifier">1D array, int64, optional</span></dt><dd><p>The ordered pixel indices (referring to the ravelled array). The pixels
are ordered such that every pixel is preceded by its parent (except for
the root which has no parent).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>Output image of the same shape and type as the input image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.area_closing" title="skimage.morphology.area_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_closing</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.diameter_opening" title="skimage.morphology.diameter_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_opening</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.diameter_closing" title="skimage.morphology.diameter_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_closing</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.max_tree</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.remove_small_objects" title="skimage.morphology.remove_small_objects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_objects</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.remove_small_holes" title="skimage.morphology.remove_small_holes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_holes</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rab8157de4f2f-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Vincent L., Proc. “Grayscale area openings and closings,
their efficient implementation and applications”,
EURASIP Workshop on Mathematical Morphology and its
Applications to Signal Processing, Barcelona, Spain, pp.22-27,
May 1993.</p>
</div>
<div class="citation" id="rab8157de4f2f-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Soille, P., “Morphological Image Analysis: Principles and
Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.
<a class="reference external" href="https://doi.org/10.1007/978-3-662-05088-0">DOI:10.1007/978-3-662-05088-0</a></p>
</div>
<div class="citation" id="rab8157de4f2f-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Salembier, P., Oliveras, A., &amp; Garrido, L. (1998). Antiextensive
Connected Operators for Image and Sequence Processing.
IEEE Transactions on Image Processing, 7(4), 555-570.
<a class="reference external" href="https://doi.org/10.1109/83.663500">DOI:10.1109/83.663500</a></p>
</div>
<div class="citation" id="rab8157de4f2f-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p>Najman, L., &amp; Couprie, M. (2006). Building the component tree in
quasi-linear time. IEEE Transactions on Image Processing, 15(11),
3531-3539.
<a class="reference external" href="https://doi.org/10.1109/TIP.2006.877518">DOI:10.1109/TIP.2006.877518</a></p>
</div>
<div class="citation" id="rab8157de4f2f-5" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of
Component Tree Computation Algorithms. IEEE Transactions on Image
Processing, 23(9), 3885-3895.
<a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<p>We create an image (quadratic function with a maximum in the center and
4 additional local maxima.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate the area opening:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">open</span> <span class="o">=</span> <span class="n">area_opening</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The peaks with a surface smaller than 8 are removed.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.ball">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">ball</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict_radius=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/footprints.py#L763-L833"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.ball" title="Link to this definition">#</a></dt>
<dd><p>Generates a ball-shaped footprint.</p>
<p>This is the 3D equivalent of a disk.
A pixel is within the neighborhood if the Euclidean distance between
it and the origin is no greater than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the ball-shaped footprint.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>strict_radius</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, extend the radius by 0.5. This allows the circle to expand
further within a cube that remains of size <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">radius</span> <span class="pre">+</span> <span class="pre">1</span></code> along
each axis. This parameter is ignored if decomposition is not None.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, ‘sequence’}, optional</span></dt><dd><p>If None, a single array is returned. For ‘sequence’, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given a result equivalent to a single, larger footprint, but with
better computational performance. For ball footprints, the sequence
decomposition is not exactly equivalent to decomposition=None.
See Notes for more details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The disk produced by the decomposition=’sequence’ mode is not identical
to that with decomposition=None. Here we extend the approach taken in <a class="reference internal" href="#r18a203c75858-1" id="id11">[1]</a>
for disks to the 3D case, using 3-dimensional extensions of the “square”,
“diamond” and “t-shaped” elements from that publication. All of these
elementary elements have size <code class="docutils literal notranslate"><span class="pre">(3,)</span> <span class="pre">*</span> <span class="pre">ndim</span></code>. We numerically computed the
number of repetitions of each element that gives the closest match to the
ball computed with kwargs <code class="docutils literal notranslate"><span class="pre">strict_radius=False,</span> <span class="pre">decomposition=None</span></code>.</p>
<p>Empirically, the equivalent composite footprint to the sequence
decomposition approaches a rhombicuboctahedron (26-faces <a class="reference internal" href="#r18a203c75858-2" id="id12">[2]</a>).</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r18a203c75858-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">1</a><span class="fn-bracket">]</span></span>
<p>Park, H and Chin R.T. Decomposition of structuring elements for
optimal implementation of morphological operations. In Proceedings:
1997 IEEE Workshop on Nonlinear Signal and Image Processing, London,
UK.
<a class="reference external" href="https://www.iwaenc.org/proceedings/1997/nsip97/pdf/scan/ns970226.pdf">https://www.iwaenc.org/proceedings/1997/nsip97/pdf/scan/ns970226.pdf</a></p>
</div>
<div class="citation" id="r18a203c75858-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Rhombicuboctahedron">https://en.wikipedia.org/wiki/Rhombicuboctahedron</a></p>
</div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :pyskimage.morphology to generate footprints (struct..."><img alt="" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Generate footprints (structuring elements)</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Many footprints (structuring elements) can be decomposed into an equivalent series of smaller s..."><img alt="" src="../_images/sphx_glr_plot_footprint_decompositions_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_footprint_decompositions.html#sphx-glr-auto-examples-numpy-operations-plot-footprint-decompositions-py"><span class="std std-ref">Decompose flat footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Decompose flat footprints (structuring elements)</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example enhances an image with low contrast, using a method called local histogram equaliz..."><img alt="" src="../_images/sphx_glr_plot_local_equalize_thumb.png" />
<p><a class="reference internal" href="../auto_examples/color_exposure/plot_local_equalize.html#sphx-glr-auto-examples-color-exposure-plot-local-equalize-py"><span class="std std-ref">Local Histogram Equalization</span></a></p>
  <div class="sphx-glr-thumbnail-title">Local Histogram Equalization</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Rank filters are non-linear filters using local gray-level ordering to compute the filtered val..."><img alt="" src="../_images/sphx_glr_plot_rank_filters_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_rank_filters.html#sphx-glr-auto-examples-applications-plot-rank-filters-py"><span class="std std-ref">Rank filters</span></a></p>
  <div class="sphx-glr-thumbnail-title">Rank filters</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.binary_closing">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">binary_closing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ignore'</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/binary.py#L262-L320"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.binary_closing" title="Link to this definition">#</a></dt>
<dd><p>Return fast binary morphological closing of an image.</p>
<p>This function returns the same result as grayscale closing but performs
faster for binary images.</p>
<p>The morphological closing on an image is defined as a dilation followed by
an erosion. Closing can remove small dark spots (i.e. “pepper”) and connect
small bright cracks. This tends to “close” up (dark) gaps between (bright)
features.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None,
is passed, a new array will be allocated.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>The <em class="xref py py-obj">mode</em> parameter determines how the array borders are handled.
Valid modes are: ‘max’, ‘min’, ‘ignore’.
If ‘ignore’, pixels outside the image domain are assumed to be <em class="xref py py-obj">True</em>
for the erosion and <em class="xref py py-obj">False</em> for the dilation, which causes them to not
influence the result. Default is ‘ignore’.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.23: </span><em class="xref py py-obj">mode</em> was added in 0.23.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>closing</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological closing.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.isotropic_closing" title="skimage.morphology.isotropic_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.isotropic_closing</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(np.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(np.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=np.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<a class="reference internal" href="#skimage.morphology.disk" title="skimage.morphology.disk"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.disk()</span></code></a> provide an option to automatically generate a
footprint sequence of this type.</p>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Flood fill is an algorithm to identify and/or change adjacent values in an image based on their..."><img alt="" src="../_images/sphx_glr_plot_floodfill_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_floodfill.html#sphx-glr-auto-examples-segmentation-plot-floodfill-py"><span class="std std-ref">Flood Fill</span></a></p>
  <div class="sphx-glr-thumbnail-title">Flood Fill</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.binary_dilation">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">binary_dilation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ignore'</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/binary.py#L120-L198"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.binary_dilation" title="Link to this definition">#</a></dt>
<dd><p>Return fast binary morphological dilation of an image.</p>
<p>This function returns the same result as grayscale dilation but performs
faster for binary images.</p>
<p>Morphological dilation sets a pixel at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> to the maximum over all
pixels in the neighborhood centered at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code>. Dilation enlarges bright
regions and shrinks dark regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>The <em class="xref py py-obj">mode</em> parameter determines how the array borders are handled.
Valid modes are: ‘max’, ‘min’, ‘ignore’.
If ‘min’ or ‘ignore’, pixels outside the image domain are assumed
to be <em class="xref py py-obj">False</em>, which causes them to not influence the result.
Default is ‘ignore’.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.23: </span><em class="xref py py-obj">mode</em> was added in 0.23.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dilated</strong><span class="classifier">ndarray of bool or uint</span></dt><dd><p>The result of the morphological dilation with values in
<code class="docutils literal notranslate"><span class="pre">[False,</span> <span class="pre">True]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.isotropic_dilation" title="skimage.morphology.isotropic_dilation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.isotropic_dilation</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(np.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(np.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=np.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<a class="reference internal" href="#skimage.morphology.disk" title="skimage.morphology.disk"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.disk()</span></code></a> provide an option to automatically generate a
footprint sequence of this type.</p>
<p>For non-symmetric footprints, <a class="reference internal" href="#skimage.morphology.binary_dilation" title="skimage.morphology.binary_dilation"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.binary_dilation()</span></code></a>
and <a class="reference internal" href="#skimage.morphology.dilation" title="skimage.morphology.dilation"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.dilation()</span></code></a> produce an output that differs:
<a class="reference internal" href="#skimage.morphology.binary_dilation" title="skimage.morphology.binary_dilation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">binary_dilation</span></code></a> mirrors the footprint, whereas <a class="reference internal" href="#skimage.morphology.dilation" title="skimage.morphology.dilation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dilation</span></code></a> does not.</p>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Inpainting [1]_ is the process of reconstructing lost or deteriorated parts of images and video..."><img alt="" src="../_images/sphx_glr_plot_inpaint_thumb.png" />
<p><a class="reference internal" href="../auto_examples/filters/plot_inpaint.html#sphx-glr-auto-examples-filters-plot-inpaint-py"><span class="std std-ref">Fill in defects with inpainting</span></a></p>
  <div class="sphx-glr-thumbnail-title">Fill in defects with inpainting</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example reproduces a well-established workflow in bioimage data analysis for measuring the..."><img alt="" src="../_images/sphx_glr_plot_fluorescence_nuclear_envelope_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_fluorescence_nuclear_envelope.html#sphx-glr-auto-examples-applications-plot-fluorescence-nuclear-envelope-py"><span class="std std-ref">Measure fluorescence intensity at the nuclear envelope</span></a></p>
  <div class="sphx-glr-thumbnail-title">Measure fluorescence intensity at the nuclear envelope</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.binary_erosion">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">binary_erosion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ignore'</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/binary.py#L39-L117"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.binary_erosion" title="Link to this definition">#</a></dt>
<dd><p>Return fast binary morphological erosion of an image.</p>
<p>This function returns the same result as grayscale erosion but performs
faster for binary images.</p>
<p>Morphological erosion sets a pixel at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> to the minimum over all
pixels in the neighborhood centered at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code>. Erosion shrinks bright
regions and enlarges dark regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>The <em class="xref py py-obj">mode</em> parameter determines how the array borders are handled.
Valid modes are: ‘max’, ‘min’, ‘ignore’.
If ‘max’ or ‘ignore’, pixels outside the image domain are assumed
to be <em class="xref py py-obj">True</em>, which causes them to not influence the result.
Default is ‘ignore’.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.23: </span><em class="xref py py-obj">mode</em> was added in 0.23.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eroded</strong><span class="classifier">ndarray of bool or uint</span></dt><dd><p>The result of the morphological erosion taking values in
<code class="docutils literal notranslate"><span class="pre">[False,</span> <span class="pre">True]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.isotropic_erosion" title="skimage.morphology.isotropic_erosion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.isotropic_erosion</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(np.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(np.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=np.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<a class="reference internal" href="#skimage.morphology.disk" title="skimage.morphology.disk"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.disk()</span></code></a> provide an option to automatically generate a
footprint sequence of this type.</p>
<p>For even-sized footprints, <a class="reference internal" href="#skimage.morphology.erosion" title="skimage.morphology.erosion"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.erosion()</span></code></a> and
this function produce an output that differs: one is shifted by one pixel
compared to the other.</p>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example reproduces a well-established workflow in bioimage data analysis for measuring the..."><img alt="" src="../_images/sphx_glr_plot_fluorescence_nuclear_envelope_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_fluorescence_nuclear_envelope.html#sphx-glr-auto-examples-applications-plot-fluorescence-nuclear-envelope-py"><span class="std std-ref">Measure fluorescence intensity at the nuclear envelope</span></a></p>
  <div class="sphx-glr-thumbnail-title">Measure fluorescence intensity at the nuclear envelope</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.binary_opening">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">binary_opening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ignore'</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/binary.py#L201-L259"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.binary_opening" title="Link to this definition">#</a></dt>
<dd><p>Return fast binary morphological opening of an image.</p>
<p>This function returns the same result as grayscale opening but performs
faster for binary images.</p>
<p>The morphological opening on an image is defined as an erosion followed by
a dilation. Opening can remove small bright spots (i.e. “salt”) and connect
small dark cracks. This tends to “open” up (dark) gaps between (bright)
features.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>The <em class="xref py py-obj">mode</em> parameter determines how the array borders are handled.
Valid modes are: ‘max’, ‘min’, ‘ignore’.
If ‘ignore’, pixels outside the image domain are assumed to be <em class="xref py py-obj">True</em>
for the erosion and <em class="xref py py-obj">False</em> for the dilation, which causes them to not
influence the result. Default is ‘ignore’.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.23: </span><em class="xref py py-obj">mode</em> was added in 0.23.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opening</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological opening.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.isotropic_opening" title="skimage.morphology.isotropic_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.isotropic_opening</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(np.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(np.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=np.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<a class="reference internal" href="#skimage.morphology.disk" title="skimage.morphology.disk"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.disk()</span></code></a> provide an option to automatically generate a
footprint sequence of this type.</p>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Flood fill is an algorithm to identify and/or change adjacent values in an image based on their..."><img alt="" src="../_images/sphx_glr_plot_floodfill_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_floodfill.html#sphx-glr-auto-examples-segmentation-plot-floodfill-py"><span class="std std-ref">Flood Fill</span></a></p>
  <div class="sphx-glr-thumbnail-title">Flood Fill</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.black_tophat">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">black_tophat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/gray.py#L613-L703"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.black_tophat" title="Link to this definition">#</a></dt>
<dd><p>Return black top hat of an image.</p>
<p>The black top hat of an image is defined as its morphological closing minus
the original image. This operation returns the dark spots of the image that
are smaller than the footprint. Note that dark spots in the
original image are bright spots after the black top hat.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>The <em class="xref py py-obj">mode</em> parameter determines how the array borders are handled.
Valid modes are: ‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’,
‘max’, ‘min’, or ‘ignore’. See <a class="reference internal" href="#skimage.morphology.closing" title="skimage.morphology.closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.closing()</span></code></a>.
Default is ‘reflect’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <em class="xref py py-obj">mode</em> is ‘constant’. Default
is 0.0.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.23: </span><em class="xref py py-obj">mode</em> and <em class="xref py py-obj">cval</em> were added in 0.23.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">array, same shape and type as <em class="xref py py-obj">image</em></span></dt><dd><p>The result of the morphological black top hat.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.white_tophat" title="skimage.morphology.white_tophat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">white_tophat</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(np.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(np.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=np.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<a class="reference internal" href="#skimage.morphology.disk" title="skimage.morphology.disk"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.disk()</span></code></a> provide an option to automatically generate
a footprint sequence of this type.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rd2d72f1c8811-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Top-hat_transform">https://en.wikipedia.org/wiki/Top-hat_transform</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Change dark peak to bright peak and subtract background</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dark_on_gray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">black_tophat</span><span class="p">(</span><span class="n">dark_on_gray</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 1, 5, 1, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><img alt="" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></p>
  <div class="sphx-glr-thumbnail-title">Morphological Filtering</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.closing">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">closing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/gray.py#L443-L517"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.closing" title="Link to this definition">#</a></dt>
<dd><p>Return grayscale morphological closing of an image.</p>
<p>The morphological closing of an image is defined as a dilation followed by
an erosion. Closing can remove small dark spots (i.e. “pepper”) and connect
small bright cracks. This tends to “close” up (dark) gaps between (bright)
features.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None,
a new array will be allocated.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>The <em class="xref py py-obj">mode</em> parameter determines how the array borders are handled.
Valid modes are: ‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’,
‘max’, ‘min’, or ‘ignore’.
If ‘ignore’, pixels outside the image domain are assumed
to be the maximum for the image’s dtype in the erosion, and minimum
in the dilation, which causes them to not influence the result.
Default is ‘reflect’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <em class="xref py py-obj">mode</em> is ‘constant’. Default
is 0.0.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.23: </span><em class="xref py py-obj">mode</em> and <em class="xref py py-obj">cval</em> were added in 0.23.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>closing</strong><span class="classifier">array, same shape and type as <em class="xref py py-obj">image</em></span></dt><dd><p>The result of the morphological closing.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(np.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(np.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=np.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<a class="reference internal" href="#skimage.morphology.disk" title="skimage.morphology.disk"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.disk()</span></code></a> provide an option to automatically generate
a footprint sequence of this type.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Close a gap between two bright lines</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">broken_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">closing</span><span class="p">(</span><span class="n">broken_line</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Attribute operators (or connected operators) [1]_ is a family of contour preserving filtering o..."><img alt="" src="../_images/sphx_glr_plot_attribute_operators_thumb.png" />
<p><a class="reference internal" href="../auto_examples/filters/plot_attribute_operators.html#sphx-glr-auto-examples-filters-plot-attribute-operators-py"><span class="std std-ref">Attribute operators</span></a></p>
  <div class="sphx-glr-thumbnail-title">Attribute operators</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to segment an image with image labelling. The following steps are applie..."><img alt="" src="../_images/sphx_glr_plot_label_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_label.html#sphx-glr-auto-examples-segmentation-plot-label-py"><span class="std std-ref">Label image regions</span></a></p>
  <div class="sphx-glr-thumbnail-title">Label image regions</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><img alt="" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></p>
  <div class="sphx-glr-thumbnail-title">Morphological Filtering</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.convex_hull_image">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">convex_hull_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_coordinates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_borders</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/convex_hull.py#L74-L170"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.convex_hull_image" title="Link to this definition">#</a></dt>
<dd><p>Compute the convex hull image of a binary image.</p>
<p>The convex hull is the set of pixels included in the smallest convex
polygon that surround all white pixels in the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>Binary input image. This array is cast to bool before processing.</p>
</dd>
<dt><strong>offset_coordinates</strong><span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, a pixel at coordinate, e.g., (4, 7) will be represented
by coordinates (3.5, 7), (4.5, 7), (4, 6.5), and (4, 7.5). This adds
some “extent” to a pixel when computing the hull.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance when determining whether a point is inside the hull. Due
to numerical floating point errors, a tolerance of 0 can result in
some points erroneously being classified as being outside the hull.</p>
</dd>
<dt><strong>include_borders: bool, optional</strong></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">False</span></code>, vertices/edges are excluded from the final hull mask.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>hull</strong><span class="classifier">(M, N) array of bool</span></dt><dd><p>Binary image with pixels in convex hull set to True.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rf22b92a8225f-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://blogs.mathworks.com/steve/2011/10/04/binary-image-convex-hull-algorithm-notes/">https://blogs.mathworks.com/steve/2011/10/04/binary-image-convex-hull-algorithm-notes/</a></p>
</div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The convex hull of a binary image is the set of pixels included in the smallest convex polygon ..."><img alt="" src="../_images/sphx_glr_plot_convex_hull_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_convex_hull.html#sphx-glr-auto-examples-edges-plot-convex-hull-py"><span class="std std-ref">Convex Hull</span></a></p>
  <div class="sphx-glr-thumbnail-title">Convex Hull</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><img alt="" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></p>
  <div class="sphx-glr-thumbnail-title">Morphological Filtering</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.convex_hull_object">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">convex_hull_object</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/convex_hull.py#L173-L222"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.convex_hull_object" title="Link to this definition">#</a></dt>
<dd><p>Compute the convex hull image of individual objects in a binary image.</p>
<p>The convex hull is the set of pixels included in the smallest convex
polygon that surround all white pixels in the input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">{1, 2}, int, optional</span></dt><dd><p>Determines the neighbors of each pixel. Adjacent elements
within a squared distance of <code class="docutils literal notranslate"><span class="pre">connectivity</span></code> from pixel center
are considered neighbors.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">-</span><span class="n">connectivity</span>      <span class="mi">2</span><span class="o">-</span><span class="n">connectivity</span>
      <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>
       <span class="o">|</span>               \  <span class="o">|</span>  <span class="o">/</span>
 <span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>      <span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>
       <span class="o">|</span>               <span class="o">/</span>  <span class="o">|</span>  \
      <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>hull</strong><span class="classifier">ndarray of bool</span></dt><dd><p>Binary image with pixels inside convex hull set to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function uses <code class="docutils literal notranslate"><span class="pre">skimage.morphology.label</span></code> to define unique objects,
finds the convex hull of each using <code class="docutils literal notranslate"><span class="pre">convex_hull_image</span></code>, and combines
these regions with logical OR. Be aware the convex hulls of unconnected
objects may overlap in the result. If this is suspected, consider using
convex_hull_image separately on each object or adjust <code class="docutils literal notranslate"><span class="pre">connectivity</span></code>.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.cube">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">cube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/footprints.py#L638-L699"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.cube" title="Link to this definition">#</a></dt>
<dd><p>Generates a cube-shaped footprint.</p>
<p>This is the 3D equivalent of a square.
Every pixel along the perimeter has a chessboard distance
no greater than radius (radius=floor(width/2)) pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>The width, height and depth of the cube.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.
When <em class="xref py py-obj">decomposition</em> is None, this is just a numpy.ndarray. Otherwise,
this will be a tuple whose length is equal to the number of unique
structuring elements to apply (see Notes for more detail)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, ‘separable’, ‘sequence’}, optional</span></dt><dd><p>If None, a single array is returned. For ‘sequence’, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given an identical result to a single, larger footprint, but often with
better computational performance. See Notes for more details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When <em class="xref py py-obj">decomposition</em> is not None, each element of the <em class="xref py py-obj">footprint</em>
tuple is a 2-tuple of the form <code class="docutils literal notranslate"><span class="pre">(ndarray,</span> <span class="pre">num_iter)</span></code> that specifies a
footprint array and the number of iterations it is to be applied.</p>
<p>For binary morphology, using <code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code>
was observed to give better performance, with the magnitude of the
performance increase rapidly increasing with footprint size. For grayscale
morphology with square footprints, it is recommended to use
<code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code> since the internal SciPy functions that are called
already have a fast implementation based on separable 1D sliding windows.</p>
<p>The ‘sequence’ decomposition mode only supports odd valued <em class="xref py py-obj">width</em>. If
<em class="xref py py-obj">width</em> is even, the sequence used will be identical to the ‘separable’
mode.</p>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :pyskimage.morphology to generate footprints (struct..."><img alt="" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Generate footprints (structuring elements)</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Many footprints (structuring elements) can be decomposed into an equivalent series of smaller s..."><img alt="" src="../_images/sphx_glr_plot_footprint_decompositions_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_footprint_decompositions.html#sphx-glr-auto-examples-numpy-operations-plot-footprint-decompositions-py"><span class="std std-ref">Decompose flat footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Decompose flat footprints (structuring elements)</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.diameter_closing">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">diameter_closing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diameter_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_traverser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/max_tree.py#L497-L609"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.diameter_closing" title="Link to this definition">#</a></dt>
<dd><p>Perform a diameter closing of the image.</p>
<p>Diameter closing removes all dark structures of an image with
maximal extension smaller than diameter_threshold. The maximal
extension is defined as the maximal extension of the bounding box.
The operator is also called Bounding Box Closing. In practice,
the result is similar to a morphological closing, but long and thin
structures are not removed.</p>
<p>Technically, this operator is based on the max-tree representation of
the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the diameter_closing is to be calculated.
This image can be of any type.</p>
</dd>
<dt><strong>diameter_threshold</strong><span class="classifier">unsigned int</span></dt><dd><p>The maximal extension parameter (number of pixels). The default value
is 8.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">unsigned int, optional</span></dt><dd><p>The neighborhood connectivity. The integer represents the maximum
number of orthogonal steps to reach a neighbor. In 2D, it is 1 for
a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p>
</dd>
<dt><strong>parent</strong><span class="classifier">ndarray, int64, optional</span></dt><dd><p>Precomputed parent image representing the max tree of the inverted
image. This function is fast, if precomputed parent and tree_traverser
are provided. See Note for further details.</p>
</dd>
<dt><strong>tree_traverser</strong><span class="classifier">1D array, int64, optional</span></dt><dd><p>Precomputed traverser, where the pixels are ordered such that every
pixel is preceded by its parent (except for the root which has no
parent). This function is fast, if precomputed parent and
tree_traverser are provided. See Note for further details.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>Output image of the same shape and type as input image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.area_opening" title="skimage.morphology.area_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_opening</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.area_closing" title="skimage.morphology.area_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_closing</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.diameter_opening" title="skimage.morphology.diameter_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_opening</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.max_tree</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If a max-tree representation (parent and tree_traverser) are given to the
function, they must be calculated from the inverted image for this
function, i.e.:
&gt;&gt;&gt; P, S = max_tree(invert(f))
&gt;&gt;&gt; closed = diameter_closing(f, 3, parent=P, tree_traverser=S)</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r0f793839edcd-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Walter, T., &amp; Klein, J.-C. (2002). Automatic Detection of
Microaneurysms in Color Fundus Images of the Human Retina by Means
of the Bounding Box Closing. In A. Colosimo, P. Sirabella,
A. Giuliani (Eds.), Medical Data Analysis. Lecture Notes in Computer
Science, vol 2526, pp. 210-220. Springer Berlin Heidelberg.
<a class="reference external" href="https://doi.org/10.1007/3-540-36104-9_23">DOI:10.1007/3-540-36104-9_23</a></p>
</div>
<div class="citation" id="r0f793839edcd-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of
Component Tree Computation Algorithms. IEEE Transactions on Image
Processing, 23(9), 3885-3895.
<a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<p>We create an image (quadratic function with a minimum in the center and
4 additional local minima.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">+</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">160</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">140</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate the diameter closing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">closed</span> <span class="o">=</span> <span class="n">diameter_closing</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>All small minima with a maximal extension of 2 or less are removed.
The remaining minima have all a maximal extension of at least 3.</p>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Attribute operators (or connected operators) [1]_ is a family of contour preserving filtering o..."><img alt="" src="../_images/sphx_glr_plot_attribute_operators_thumb.png" />
<p><a class="reference internal" href="../auto_examples/filters/plot_attribute_operators.html#sphx-glr-auto-examples-filters-plot-attribute-operators-py"><span class="std std-ref">Attribute operators</span></a></p>
  <div class="sphx-glr-thumbnail-title">Attribute operators</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.diameter_opening">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">diameter_opening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diameter_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_traverser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/max_tree.py#L265-L364"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.diameter_opening" title="Link to this definition">#</a></dt>
<dd><p>Perform a diameter opening of the image.</p>
<p>Diameter opening removes all bright structures of an image with
maximal extension smaller than diameter_threshold. The maximal
extension is defined as the maximal extension of the bounding box.
The operator is also called Bounding Box Opening. In practice,
the result is similar to a morphological opening, but long and thin
structures are not removed.</p>
<p>Technically, this operator is based on the max-tree representation of
the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the area_opening is to be calculated.
This image can be of any type.</p>
</dd>
<dt><strong>diameter_threshold</strong><span class="classifier">unsigned int</span></dt><dd><p>The maximal extension parameter (number of pixels). The default value
is 8.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">unsigned int, optional</span></dt><dd><p>The neighborhood connectivity. The integer represents the maximum
number of orthogonal steps to reach a neighbor. In 2D, it is 1 for
a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p>
</dd>
<dt><strong>parent</strong><span class="classifier">ndarray, int64, optional</span></dt><dd><p>Parent image representing the max tree of the image. The
value of each pixel is the index of its parent in the ravelled array.</p>
</dd>
<dt><strong>tree_traverser</strong><span class="classifier">1D array, int64, optional</span></dt><dd><p>The ordered pixel indices (referring to the ravelled array). The pixels
are ordered such that every pixel is preceded by its parent (except for
the root which has no parent).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>Output image of the same shape and type as the input image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.area_opening" title="skimage.morphology.area_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_opening</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.area_closing" title="skimage.morphology.area_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_closing</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.diameter_closing" title="skimage.morphology.diameter_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_closing</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.max_tree</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rff2b90016d8e-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Walter, T., &amp; Klein, J.-C. (2002). Automatic Detection of
Microaneurysms in Color Fundus Images of the Human Retina by Means
of the Bounding Box Closing. In A. Colosimo, P. Sirabella,
A. Giuliani (Eds.), Medical Data Analysis. Lecture Notes in Computer
Science, vol 2526, pp. 210-220. Springer Berlin Heidelberg.
<a class="reference external" href="https://doi.org/10.1007/3-540-36104-9_23">DOI:10.1007/3-540-36104-9_23</a></p>
</div>
<div class="citation" id="rff2b90016d8e-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of
Component Tree Computation Algorithms. IEEE Transactions on Image
Processing, 23(9), 3885-3895.
<a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<p>We create an image (quadratic function with a maximum in the center and
4 additional local maxima.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate the diameter opening:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">open</span> <span class="o">=</span> <span class="n">diameter_opening</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The peaks with a maximal extension of 2 or less are removed.
The remaining peaks have all a maximal extension of at least 3.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.diamond">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">diamond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/footprints.py#L258-L312"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.diamond" title="Link to this definition">#</a></dt>
<dd><p>Generates a flat, diamond-shaped footprint.</p>
<p>A pixel is part of the neighborhood (i.e. labeled 1) if
the city block/Manhattan distance between it and the center of
the neighborhood is no greater than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the diamond-shaped footprint.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.
When <em class="xref py py-obj">decomposition</em> is None, this is just a numpy.ndarray. Otherwise,
this will be a tuple whose length is equal to the number of unique
structuring elements to apply (see Notes for more detail)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, ‘sequence’}, optional</span></dt><dd><p>If None, a single array is returned. For ‘sequence’, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given an identical result to a single, larger footprint, but with
better computational performance. See Notes for more details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When <em class="xref py py-obj">decomposition</em> is not None, each element of the <em class="xref py py-obj">footprint</em>
tuple is a 2-tuple of the form <code class="docutils literal notranslate"><span class="pre">(ndarray,</span> <span class="pre">num_iter)</span></code> that specifies a
footprint array and the number of iterations it is to be applied.</p>
<p>For either binary or grayscale morphology, using
<code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code> was observed to have a performance benefit,
with the magnitude of the benefit increasing with increasing footprint
size.</p>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :pyskimage.morphology to generate footprints (struct..."><img alt="" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Generate footprints (structuring elements)</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Many footprints (structuring elements) can be decomposed into an equivalent series of smaller s..."><img alt="" src="../_images/sphx_glr_plot_footprint_decompositions_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_footprint_decompositions.html#sphx-glr-auto-examples-numpy-operations-plot-footprint-decompositions-py"><span class="std std-ref">Decompose flat footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Decompose flat footprints (structuring elements)</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Optical coherence tomography (OCT) is a non-invasive imaging technique used by ophthalmologists..."><img alt="" src="../_images/sphx_glr_plot_cornea_spot_inpainting_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_cornea_spot_inpainting.html#sphx-glr-auto-examples-applications-plot-cornea-spot-inpainting-py"><span class="std std-ref">Restore spotted cornea image with inpainting</span></a></p>
  <div class="sphx-glr-thumbnail-title">Restore spotted cornea image with inpainting</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.dilation">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">dilation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_x=&lt;DEPRECATED&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_y=&lt;DEPRECATED&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode='reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval=0.0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/gray.py#L245-L363"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.dilation" title="Link to this definition">#</a></dt>
<dd><p>Return grayscale morphological dilation of an image.</p>
<p>Morphological dilation sets the value of a pixel to the maximum over all
pixel values within a local neighborhood centered about it. The values
where the footprint is 1 define this neighborhood.
Dilation enlarges bright regions and shrinks dark regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>The <em class="xref py py-obj">mode</em> parameter determines how the array borders are handled.
Valid modes are: ‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’,
‘max’, ‘min’, or ‘ignore’.
If ‘min’ or ‘ignore’, pixels outside the image domain are assumed
to be the maximum for the image’s dtype, which causes them to not
influence the result. Default is ‘reflect’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <em class="xref py py-obj">mode</em> is ‘constant’. Default
is 0.0.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.23: </span><em class="xref py py-obj">mode</em> and <em class="xref py py-obj">cval</em> were added in 0.23.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>dilated</strong><span class="classifier">uint8 array, same shape and type as <em class="xref py py-obj">image</em></span></dt><dd><p>The result of the morphological dilation.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>shift_x, shift_y</strong><span class="classifier">DEPRECATED</span></dt><dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 0.23.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For <code class="docutils literal notranslate"><span class="pre">uint8</span></code> (and <code class="docutils literal notranslate"><span class="pre">uint16</span></code> up to a certain bit-depth) data, the lower
algorithm complexity makes the <a class="reference internal" href="skimage.filters.rank.html#skimage.filters.rank.maximum" title="skimage.filters.rank.maximum"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.filters.rank.maximum()</span></code></a>
function more efficient for larger images and footprints.</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(np.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(np.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=np.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<a class="reference internal" href="#skimage.morphology.disk" title="skimage.morphology.disk"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.disk()</span></code></a> provide an option to automatically generate
a footprint sequence of this type.</p>
<p>For non-symmetric footprints, <a class="reference internal" href="#skimage.morphology.binary_dilation" title="skimage.morphology.binary_dilation"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.binary_dilation()</span></code></a>
and <a class="reference internal" href="#skimage.morphology.dilation" title="skimage.morphology.dilation"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.dilation()</span></code></a> produce an output that differs:
<a class="reference internal" href="#skimage.morphology.binary_dilation" title="skimage.morphology.binary_dilation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">binary_dilation</span></code></a> mirrors the footprint, whereas <a class="reference internal" href="#skimage.morphology.dilation" title="skimage.morphology.dilation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dilation</span></code></a> does not.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Dilation enlarges bright regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bright_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dilation</span><span class="p">(</span><span class="n">bright_pixel</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 1, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Given several connected components represented by a label image, these connected components can..."><img alt="" src="../_images/sphx_glr_plot_expand_labels_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_expand_labels.html#sphx-glr-auto-examples-segmentation-plot-expand-labels-py"><span class="std std-ref">Expand segmentation labels without overlap</span></a></p>
  <div class="sphx-glr-thumbnail-title">Expand segmentation labels without overlap</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><img alt="" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></p>
  <div class="sphx-glr-thumbnail-title">Morphological Filtering</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Optical coherence tomography (OCT) is a non-invasive imaging technique used by ophthalmologists..."><img alt="" src="../_images/sphx_glr_plot_cornea_spot_inpainting_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_cornea_spot_inpainting.html#sphx-glr-auto-examples-applications-plot-cornea-spot-inpainting-py"><span class="std std-ref">Restore spotted cornea image with inpainting</span></a></p>
  <div class="sphx-glr-thumbnail-title">Restore spotted cornea image with inpainting</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Rank filters are non-linear filters using local gray-level ordering to compute the filtered val..."><img alt="" src="../_images/sphx_glr_plot_rank_filters_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_rank_filters.html#sphx-glr-auto-examples-applications-plot-rank-filters-py"><span class="std std-ref">Rank filters</span></a></p>
  <div class="sphx-glr-thumbnail-title">Rank filters</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.disk">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">disk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict_radius=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/footprints.py#L424-L513"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.disk" title="Link to this definition">#</a></dt>
<dd><p>Generates a flat, disk-shaped footprint.</p>
<p>A pixel is within the neighborhood if the Euclidean distance between
it and the origin is no greater than radius (This is only approximately
True, when <em class="xref py py-obj">decomposition == ‘sequence’</em>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the disk-shaped footprint.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">ndarray</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>strict_radius</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, extend the radius by 0.5. This allows the circle to expand
further within a cube that remains of size <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">radius</span> <span class="pre">+</span> <span class="pre">1</span></code> along
each axis. This parameter is ignored if decomposition is not None.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, ‘sequence’, ‘crosses’}, optional</span></dt><dd><p>If None, a single array is returned. For ‘sequence’, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given a result equivalent to a single, larger footprint, but with
better computational performance. For disk footprints, the ‘sequence’
or ‘crosses’ decompositions are not always exactly equivalent to
<code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code>. See Notes for more details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When <em class="xref py py-obj">decomposition</em> is not None, each element of the <em class="xref py py-obj">footprint</em>
tuple is a 2-tuple of the form <code class="docutils literal notranslate"><span class="pre">(ndarray,</span> <span class="pre">num_iter)</span></code> that specifies a
footprint array and the number of iterations it is to be applied.</p>
<p>The disk produced by the <code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code> mode may not be
identical to that with <code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code>. A disk footprint can be
approximated by applying a series of smaller footprints of extent 3 along
each axis. Specific solutions for this are given in <a class="reference internal" href="#r536854016e8e-1" id="id21">[1]</a> for the case of
2D disks with radius 2 through 10. Here, we numerically computed the number
of repetitions of each element that gives the closest match to the disk
computed with kwargs <code class="docutils literal notranslate"><span class="pre">strict_radius=False,</span> <span class="pre">decomposition=None</span></code>.</p>
<p>Empirically, the series decomposition at large radius approaches a
hexadecagon (a 16-sided polygon <a class="reference internal" href="#r536854016e8e-2" id="id22">[2]</a>). In <a class="reference internal" href="#r536854016e8e-3" id="id23">[3]</a>, the authors demonstrate
that a hexadecagon is the closest approximation to a disk that can be
achieved for decomposition with footprints of shape (3, 3).</p>
<p>The disk produced by the <code class="docutils literal notranslate"><span class="pre">decomposition='crosses'</span></code> is often but not
always  identical to that with <code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code>. It tends to give a
closer approximation than <code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code>, at a performance
that is fairly comparable. The individual cross-shaped elements are not
limited to extent (3, 3) in size. Unlike the ‘seqeuence’ decomposition, the
‘crosses’ decomposition can also accurately approximate the shape of disks
with <code class="docutils literal notranslate"><span class="pre">strict_radius=True</span></code>. The method is based on an adaption of
algorithm 1 given in <a class="reference internal" href="#r536854016e8e-4" id="id24">[4]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r536854016e8e-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id21">1</a><span class="fn-bracket">]</span></span>
<p>Park, H and Chin R.T. Decomposition of structuring elements for
optimal implementation of morphological operations. In Proceedings:
1997 IEEE Workshop on Nonlinear Signal and Image Processing, London,
UK.
<a class="reference external" href="https://www.iwaenc.org/proceedings/1997/nsip97/pdf/scan/ns970226.pdf">https://www.iwaenc.org/proceedings/1997/nsip97/pdf/scan/ns970226.pdf</a></p>
</div>
<div class="citation" id="r536854016e8e-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id22">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Hexadecagon">https://en.wikipedia.org/wiki/Hexadecagon</a></p>
</div>
<div class="citation" id="r536854016e8e-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id23">3</a><span class="fn-bracket">]</span></span>
<p>Vanrell, M and Vitrià, J. Optimal 3 × 3 decomposable disks for
morphological transformations. Image and Vision Computing, Vol. 15,
Issue 11, 1997.
<a class="reference external" href="https://doi.org/10.1016/S0262-8856(97)00026-7">DOI:10.1016/S0262-8856(97)00026-7</a></p>
</div>
<div class="citation" id="r536854016e8e-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id24">4</a><span class="fn-bracket">]</span></span>
<p>Li, D. and Ritter, G.X. Decomposition of Separable and Symmetric
Convex Templates. Proc. SPIE 1350, Image Algebra and Morphological
Image Processing, (1 November 1990).
<a class="reference external" href="https://doi.org/10.1117/12.23608">DOI:10.1117/12.23608</a></p>
</div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :pyskimage.morphology to generate footprints (struct..."><img alt="" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Generate footprints (structuring elements)</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Many footprints (structuring elements) can be decomposed into an equivalent series of smaller s..."><img alt="" src="../_images/sphx_glr_plot_footprint_decompositions_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_footprint_decompositions.html#sphx-glr-auto-examples-numpy-operations-plot-footprint-decompositions-py"><span class="std std-ref">Decompose flat footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Decompose flat footprints (structuring elements)</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example enhances an image with low contrast, using a method called local histogram equaliz..."><img alt="" src="../_images/sphx_glr_plot_local_equalize_thumb.png" />
<p><a class="reference internal" href="../auto_examples/color_exposure/plot_local_equalize.html#sphx-glr-auto-examples-color-exposure-plot-local-equalize-py"><span class="std std-ref">Local Histogram Equalization</span></a></p>
  <div class="sphx-glr-thumbnail-title">Local Histogram Equalization</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to remove small objects from grayscale images. The top-hat transform [1]..."><img alt="" src="../_images/sphx_glr_plot_tophat_thumb.png" />
<p><a class="reference internal" href="../auto_examples/filters/plot_tophat.html#sphx-glr-auto-examples-filters-plot-tophat-py"><span class="std std-ref">Removing small objects in grayscale images with a top hat filter</span></a></p>
  <div class="sphx-glr-thumbnail-title">Removing small objects in grayscale images with a top hat filter</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example compares the following mean filters of the rank filter package:"><img alt="" src="../_images/sphx_glr_plot_rank_mean_thumb.png" />
<p><a class="reference internal" href="../auto_examples/filters/plot_rank_mean.html#sphx-glr-auto-examples-filters-plot-rank-mean-py"><span class="std std-ref">Mean filters</span></a></p>
  <div class="sphx-glr-thumbnail-title">Mean filters</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In information theory, information entropy is the log-base-2 of the number of possible outcomes..."><img alt="" src="../_images/sphx_glr_plot_entropy_thumb.png" />
<p><a class="reference internal" href="../auto_examples/filters/plot_entropy.html#sphx-glr-auto-examples-filters-plot-entropy-py"><span class="std std-ref">Entropy</span></a></p>
  <div class="sphx-glr-thumbnail-title">Entropy</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Inpainting [1]_ is the process of reconstructing lost or deteriorated parts of images and video..."><img alt="" src="../_images/sphx_glr_plot_inpaint_thumb.png" />
<p><a class="reference internal" href="../auto_examples/filters/plot_inpaint.html#sphx-glr-auto-examples-filters-plot-inpaint-py"><span class="std std-ref">Fill in defects with inpainting</span></a></p>
  <div class="sphx-glr-thumbnail-title">Fill in defects with inpainting</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Histogram matching can be used for object detection in images [1]_. This example extracts a sin..."><img alt="" src="../_images/sphx_glr_plot_windowed_histogram_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_windowed_histogram.html#sphx-glr-auto-examples-features-detection-plot-windowed-histogram-py"><span class="std std-ref">Sliding window histogram</span></a></p>
  <div class="sphx-glr-thumbnail-title">Sliding window histogram</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example is about comparing the segmentations obtained using the plain SLIC method [1]_ and..."><img alt="" src="../_images/sphx_glr_plot_mask_slic_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_mask_slic.html#sphx-glr-auto-examples-segmentation-plot-mask-slic-py"><span class="std std-ref">Apply maskSLIC vs SLIC</span></a></p>
  <div class="sphx-glr-thumbnail-title">Apply maskSLIC vs SLIC</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="The watershed is a classical algorithm used for segmentation, that is, for separating different..."><img alt="" src="../_images/sphx_glr_plot_marked_watershed_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_marked_watershed.html#sphx-glr-auto-examples-segmentation-plot-marked-watershed-py"><span class="std std-ref">Markers for watershed transform</span></a></p>
  <div class="sphx-glr-thumbnail-title">Markers for watershed transform</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Flood fill is an algorithm to identify and/or change adjacent values in an image based on their..."><img alt="" src="../_images/sphx_glr_plot_floodfill_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_floodfill.html#sphx-glr-auto-examples-segmentation-plot-floodfill-py"><span class="std std-ref">Flood Fill</span></a></p>
  <div class="sphx-glr-thumbnail-title">Flood Fill</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><img alt="" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></p>
  <div class="sphx-glr-thumbnail-title">Morphological Filtering</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example, we analyze a microscopy image of human cells. We use data provided by Jason Mo..."><img alt="" src="../_images/sphx_glr_plot_human_mitosis_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_human_mitosis.html#sphx-glr-auto-examples-applications-plot-human-mitosis-py"><span class="std std-ref">Segment human cells (in mitosis)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Segment human cells (in mitosis)</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Thresholding is used to create a binary image from a grayscale image [1]_. It is the simplest w..."><img alt="" src="../_images/sphx_glr_plot_thresholding_guide_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_thresholding_guide.html#sphx-glr-auto-examples-applications-plot-thresholding-guide-py"><span class="std std-ref">Thresholding</span></a></p>
  <div class="sphx-glr-thumbnail-title">Thresholding</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Rank filters are non-linear filters using local gray-level ordering to compute the filtered val..."><img alt="" src="../_images/sphx_glr_plot_rank_filters_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_rank_filters.html#sphx-glr-auto-examples-applications-plot-rank-filters-py"><span class="std std-ref">Rank filters</span></a></p>
  <div class="sphx-glr-thumbnail-title">Rank filters</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.ellipse">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">ellipse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/footprints.py#L568-L635"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.ellipse" title="Link to this definition">#</a></dt>
<dd><p>Generates a flat, ellipse-shaped footprint.</p>
<p>Every pixel along the perimeter of ellipse satisfies
the equation <code class="docutils literal notranslate"><span class="pre">(x/width+1)**2</span> <span class="pre">+</span> <span class="pre">(y/height+1)**2</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>The width of the ellipse-shaped footprint.</p>
</dd>
<dt><strong>height</strong><span class="classifier">int</span></dt><dd><p>The height of the ellipse-shaped footprint.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">ndarray</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.
The footprint will have shape <code class="docutils literal notranslate"><span class="pre">(2</span> <span class="pre">*</span> <span class="pre">height</span> <span class="pre">+</span> <span class="pre">1,</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">width</span> <span class="pre">+</span> <span class="pre">1)</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, ‘crosses’}, optional</span></dt><dd><p>If None, a single array is returned. For ‘sequence’, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given an identical result to a single, larger footprint, but with
better computational performance. See Notes for more details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When <em class="xref py py-obj">decomposition</em> is not None, each element of the <em class="xref py py-obj">footprint</em>
tuple is a 2-tuple of the form <code class="docutils literal notranslate"><span class="pre">(ndarray,</span> <span class="pre">num_iter)</span></code> that specifies a
footprint array and the number of iterations it is to be applied.</p>
<p>The ellipse produced by the <code class="docutils literal notranslate"><span class="pre">decomposition='crosses'</span></code> is often but not
always  identical to that with <code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code>. The method is based
on an adaption of algorithm 1 given in <a class="reference internal" href="#r6ebea2ee0b65-1" id="id29">[1]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r6ebea2ee0b65-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id29">1</a><span class="fn-bracket">]</span></span>
<p>Li, D. and Ritter, G.X. Decomposition of Separable and Symmetric
Convex Templates. Proc. SPIE 1350, Image Algebra and Morphological
Image Processing, (1 November 1990).
<a class="reference external" href="https://doi.org/10.1117/12.23608">DOI:10.1117/12.23608</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">footprints</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">footprints</span><span class="o">.</span><span class="n">ellipse</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([[0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Many footprints (structuring elements) can be decomposed into an equivalent series of smaller s..."><img alt="" src="../_images/sphx_glr_plot_footprint_decompositions_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_footprint_decompositions.html#sphx-glr-auto-examples-numpy-operations-plot-footprint-decompositions-py"><span class="std std-ref">Decompose flat footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Decompose flat footprints (structuring elements)</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.erosion">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">erosion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_x=&lt;DEPRECATED&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_y=&lt;DEPRECATED&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode='reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval=0.0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/gray.py#L128-L242"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.erosion" title="Link to this definition">#</a></dt>
<dd><p>Return grayscale morphological erosion of an image.</p>
<p>Morphological erosion sets a pixel at (i,j) to the minimum over all pixels
in the neighborhood centered at (i,j). Erosion shrinks bright regions and
enlarges dark regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarrays, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>The <em class="xref py py-obj">mode</em> parameter determines how the array borders are handled.
Valid modes are: ‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’,
‘max’, ‘min’, or ‘ignore’.
If ‘max’ or ‘ignore’, pixels outside the image domain are assumed
to be the maximum for the image’s dtype, which causes them to not
influence the result. Default is ‘reflect’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <em class="xref py py-obj">mode</em> is ‘constant’. Default
is 0.0.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.23: </span><em class="xref py py-obj">mode</em> and <em class="xref py py-obj">cval</em> were added in 0.23.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>eroded</strong><span class="classifier">array, same shape as <em class="xref py py-obj">image</em></span></dt><dd><p>The result of the morphological erosion.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>shift_x, shift_y</strong><span class="classifier">DEPRECATED</span></dt><dd><div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 0.23.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For <code class="docutils literal notranslate"><span class="pre">uint8</span></code> (and <code class="docutils literal notranslate"><span class="pre">uint16</span></code> up to a certain bit-depth) data, the
lower algorithm complexity makes the <a class="reference internal" href="skimage.filters.rank.html#skimage.filters.rank.minimum" title="skimage.filters.rank.minimum"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.filters.rank.minimum()</span></code></a>
function more efficient for larger images and footprints.</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(np.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(np.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=np.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<a class="reference internal" href="#skimage.morphology.disk" title="skimage.morphology.disk"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.disk()</span></code></a> provide an option to automatically generate
a footprint sequence of this type.</p>
<p>For even-sized footprints, <a class="reference internal" href="#skimage.morphology.binary_erosion" title="skimage.morphology.binary_erosion"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.binary_erosion()</span></code></a> and
this function produce an output that differs: one is shifted by one pixel
compared to the other.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Erosion shrinks bright regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bright_square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">erosion</span><span class="p">(</span><span class="n">bright_square</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><img alt="" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></p>
  <div class="sphx-glr-thumbnail-title">Morphological Filtering</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.flood">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">flood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed_point</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/_flood_fill.py#L129-L310"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.flood" title="Link to this definition">#</a></dt>
<dd><p>Mask corresponding to a flood fill.</p>
<p>Starting at a specific <em class="xref py py-obj">seed_point</em>, connected points equal or within
<em class="xref py py-obj">tolerance</em> of the seed value are found.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>An n-dimensional array.</p>
</dd>
<dt><strong>seed_point</strong><span class="classifier">tuple or int</span></dt><dd><p>The point in <em class="xref py py-obj">image</em> used as the starting point for the flood fill.  If
the image is 1D, this point may be given as an integer.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The footprint (structuring element) used to determine the neighborhood
of each evaluated pixel. It must contain only 1’s and 0’s, have the
same number of dimensions as <em class="xref py py-obj">image</em>. If not given, all adjacent pixels
are considered as part of the neighborhood (fully connected).</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>A number used to determine the neighborhood of each evaluated pixel.
Adjacent pixels whose squared distance from the center is less than or
equal to <em class="xref py py-obj">connectivity</em> are considered neighbors. Ignored if
<em class="xref py py-obj">footprint</em> is not None.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float or int, optional</span></dt><dd><p>If None (default), adjacent values must be strictly equal to the
initial value of <em class="xref py py-obj">image</em> at <em class="xref py py-obj">seed_point</em>.  This is fastest.  If a value
is given, a comparison will be done at every point and if within
tolerance of the initial value will also be filled (inclusive).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mask</strong><span class="classifier">ndarray</span></dt><dd><p>A Boolean array with the same shape as <em class="xref py py-obj">image</em> is returned, with True
values for areas connected to and equal (or within tolerance of) the
seed point.  All other values are False.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The conceptual analogy of this operation is the ‘paint bucket’ tool in many
raster graphics programs.  This function returns just the mask
representing the fill.</p>
<p>If indices are desired rather than masks for memory reasons, the user can
simply run <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.nonzero.html#numpy.nonzero" title="(in NumPy v2.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.nonzero</span></code></a> on the result, save the indices, and discard
this mask.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">flood</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 1, 1, 0, 2, 2, 0],</span>
<span class="go">       [0, 1, 1, 0, 2, 2, 0],</span>
<span class="go">       [1, 0, 0, 0, 0, 0, 3]])</span>
</pre></div>
</div>
<p>Fill connected ones with 5, with full connectivity (diagonals included):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">flood</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [5, 0, 0, 0, 0, 0, 3]])</span>
</pre></div>
</div>
<p>Fill connected ones with 5, excluding diagonal points (connectivity 1):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">flood</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [1, 0, 0, 0, 0, 0, 3]])</span>
</pre></div>
</div>
<p>Fill with a tolerance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">flood</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span>
<span class="go">array([[5, 5, 5, 5, 5, 5, 5],</span>
<span class="go">       [5, 5, 5, 5, 2, 2, 5],</span>
<span class="go">       [5, 5, 5, 5, 2, 2, 5],</span>
<span class="go">       [5, 5, 5, 5, 5, 5, 3]])</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.flood_fill">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">flood_fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_place</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/_flood_fill.py#L19-L126"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.flood_fill" title="Link to this definition">#</a></dt>
<dd><p>Perform flood filling on an image.</p>
<p>Starting at a specific <em class="xref py py-obj">seed_point</em>, connected points equal or within
<em class="xref py py-obj">tolerance</em> of the seed value are found, then set to <em class="xref py py-obj">new_value</em>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>An n-dimensional array.</p>
</dd>
<dt><strong>seed_point</strong><span class="classifier">tuple or int</span></dt><dd><p>The point in <em class="xref py py-obj">image</em> used as the starting point for the flood fill.  If
the image is 1D, this point may be given as an integer.</p>
</dd>
<dt><strong>new_value</strong><span class="classifier"><em class="xref py py-obj">image</em> type</span></dt><dd><p>New value to set the entire fill.  This must be chosen in agreement
with the dtype of <em class="xref py py-obj">image</em>.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The footprint (structuring element) used to determine the neighborhood
of each evaluated pixel. It must contain only 1’s and 0’s, have the
same number of dimensions as <em class="xref py py-obj">image</em>. If not given, all adjacent pixels
are considered as part of the neighborhood (fully connected).</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>A number used to determine the neighborhood of each evaluated pixel.
Adjacent pixels whose squared distance from the center is less than or
equal to <em class="xref py py-obj">connectivity</em> are considered neighbors. Ignored if
<em class="xref py py-obj">footprint</em> is not None.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float or int, optional</span></dt><dd><p>If None (default), adjacent values must be strictly equal to the
value of <em class="xref py py-obj">image</em> at <em class="xref py py-obj">seed_point</em> to be filled.  This is fastest.
If a tolerance is provided, adjacent points with values within plus or
minus tolerance from the seed point are filled (inclusive).</p>
</dd>
<dt><strong>in_place</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, flood filling is applied to <em class="xref py py-obj">image</em> in place.  If False, the
flood filled result is returned without modifying the input <em class="xref py py-obj">image</em>
(default).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filled</strong><span class="classifier">ndarray</span></dt><dd><p>An array with the same shape as <em class="xref py py-obj">image</em> is returned, with values in
areas connected to and equal (or within tolerance of) the seed point
replaced with <em class="xref py py-obj">new_value</em>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The conceptual analogy of this operation is the ‘paint bucket’ tool in many
raster graphics programs.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">flood_fill</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 1, 1, 0, 2, 2, 0],</span>
<span class="go">       [0, 1, 1, 0, 2, 2, 0],</span>
<span class="go">       [1, 0, 0, 0, 0, 0, 3]])</span>
</pre></div>
</div>
<p>Fill connected ones with 5, with full connectivity (diagonals included):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flood_fill</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [5, 0, 0, 0, 0, 0, 3]])</span>
</pre></div>
</div>
<p>Fill connected ones with 5, excluding diagonal points (connectivity 1):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flood_fill</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">5</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [1, 0, 0, 0, 0, 0, 3]])</span>
</pre></div>
</div>
<p>Fill with a tolerance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flood_fill</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">5</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[5, 5, 5, 5, 5, 5, 5],</span>
<span class="go">       [5, 5, 5, 5, 2, 2, 5],</span>
<span class="go">       [5, 5, 5, 5, 2, 2, 5],</span>
<span class="go">       [5, 5, 5, 5, 5, 5, 3]])</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.footprint_from_sequence">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">footprint_from_sequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">footprints</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/footprints.py#L74-L95"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.footprint_from_sequence" title="Link to this definition">#</a></dt>
<dd><p>Convert a footprint sequence into an equivalent ndarray.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>footprints</strong><span class="classifier">tuple of 2-tuples</span></dt><dd><p>A sequence of footprint tuples where the first element of each tuple
is an array corresponding to a footprint and the second element is the
number of times it is to be applied. Currently, all footprints should
have odd size.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">ndarray</span></dt><dd><p>An single array equivalent to applying the sequence of <code class="docutils literal notranslate"><span class="pre">footprints</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Many footprints (structuring elements) can be decomposed into an equivalent series of smaller s..."><img alt="" src="../_images/sphx_glr_plot_footprint_decompositions_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_footprint_decompositions.html#sphx-glr-auto-examples-numpy-operations-plot-footprint-decompositions-py"><span class="std std-ref">Decompose flat footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Decompose flat footprints (structuring elements)</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.h_maxima">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">h_maxima</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/extrema.py#L49-L175"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.h_maxima" title="Link to this definition">#</a></dt>
<dd><p>Determine all maxima of the image with height &gt;= h.</p>
<p>The local maxima are defined as connected sets of pixels with equal
gray level strictly greater than the gray level of all pixels in direct
neighborhood of the set.</p>
<p>A local maximum M of height h is a local maximum for which
there is at least one path joining M with an equal or higher local maximum
on which the minimal value is f(M) - h (i.e. the values along the path
are not decreasing by more than h with respect to the maximum’s value)
and no path to an equal or higher local maximum for which the minimal
value is greater.</p>
<p>The global maxima of the image are also found by this function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the maxima are to be calculated.</p>
</dd>
<dt><strong>h</strong><span class="classifier">unsigned integer</span></dt><dd><p>The minimal height of all extracted maxima.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an n-D array of 1’s and 0’s.
Default is the ball of radius 1 according to the maximum norm
(i.e. a 3x3 square for 2D images, a 3x3x3 cube for 3D images, etc.)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>h_max</strong><span class="classifier">ndarray</span></dt><dd><p>The local maxima of height &gt;= h and the global maxima.
The resulting image is a binary image, where pixels belonging to
the determined maxima take value 1, the others take value 0.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.h_minima" title="skimage.morphology.h_minima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.h_minima</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.local_maxima" title="skimage.morphology.local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.local_maxima</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.local_minima" title="skimage.morphology.local_minima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.local_minima</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="reab74d5f60e7-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Soille, P., “Morphological Image Analysis: Principles and
Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">extrema</span>
</pre></div>
</div>
<p>We create an image (quadratic function with a maximum in the center and
4 additional constant maxima.
The heights of the maxima are: 1, 21, 41, 61, 81</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate all maxima with a height of at least 40:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">maxima</span> <span class="o">=</span> <span class="n">extrema</span><span class="o">.</span><span class="n">h_maxima</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting image will contain 3 local maxima.</p>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="We detect local maxima in a galaxy image. The image is corrupted by noise, generating many loca..."><img alt="" src="../_images/sphx_glr_plot_extrema_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_extrema.html#sphx-glr-auto-examples-segmentation-plot-extrema-py"><span class="std std-ref">Extrema</span></a></p>
  <div class="sphx-glr-thumbnail-title">Extrema</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.h_minima">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">h_minima</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/extrema.py#L178-L272"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.h_minima" title="Link to this definition">#</a></dt>
<dd><p>Determine all minima of the image with depth &gt;= h.</p>
<p>The local minima are defined as connected sets of pixels with equal
gray level strictly smaller than the gray levels of all pixels in direct
neighborhood of the set.</p>
<p>A local minimum M of depth h is a local minimum for which
there is at least one path joining M with an equal or lower local minimum
on which the maximal value is f(M) + h (i.e. the values along the path
are not increasing by more than h with respect to the minimum’s value)
and no path to an equal or lower local minimum for which the maximal
value is smaller.</p>
<p>The global minima of the image are also found by this function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the minima are to be calculated.</p>
</dd>
<dt><strong>h</strong><span class="classifier">unsigned integer</span></dt><dd><p>The minimal depth of all extracted minima.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an n-D array of 1’s and 0’s.
Default is the ball of radius 1 according to the maximum norm
(i.e. a 3x3 square for 2D images, a 3x3x3 cube for 3D images, etc.)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>h_min</strong><span class="classifier">ndarray</span></dt><dd><p>The local minima of depth &gt;= h and the global minima.
The resulting image is a binary image, where pixels belonging to
the determined minima take value 1, the others take value 0.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.h_maxima" title="skimage.morphology.h_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.h_maxima</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.local_maxima" title="skimage.morphology.local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.local_maxima</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.local_minima" title="skimage.morphology.local_minima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.local_minima</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rb2b2b247b9a8-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Soille, P., “Morphological Image Analysis: Principles and
Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">extrema</span>
</pre></div>
</div>
<p>We create an image (quadratic function with a minimum in the center and
4 additional constant maxima.
The depth of the minima are: 1, 21, 41, 61, 81</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">+</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">160</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">140</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate all minima with a depth of at least 40:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minima</span> <span class="o">=</span> <span class="n">extrema</span><span class="o">.</span><span class="n">h_minima</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting image will contain 3 local minima.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.isotropic_closing">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">isotropic_closing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/isotropic.py#L151-L194"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.isotropic_closing" title="Link to this definition">#</a></dt>
<dd><p>Return binary morphological closing of an image.</p>
<p>This function returns the same result as binary <a class="reference internal" href="#skimage.morphology.binary_closing" title="skimage.morphology.binary_closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.binary_closing()</span></code></a>
but performs faster for large circular structuring elements.
This works by thresholding the exact Euclidean distance map <a class="reference internal" href="#ra67d62e44e71-1" id="id33">[1]</a>, <a class="reference internal" href="#ra67d62e44e71-2" id="id34">[2]</a>.
The implementation is based on: func:<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.distance_transform_edt.html#scipy.ndimage.distance_transform_edt" title="(in SciPy v1.14.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.ndimage.distance_transform_edt</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>The radius with which the regions should be closed.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None,
is passed, a new array will be allocated.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">float, or sequence of float, optional</span></dt><dd><p>Spacing of elements along each dimension.
If a sequence, must be of length equal to the input’s dimension (number of axes).
If a single number, this value is used for all axes.
If not specified, a grid spacing of unity is implied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>closed</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological closing.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="ra67d62e44e71-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id33">1</a><span class="fn-bracket">]</span></span>
<p>Cuisenaire, O. and Macq, B., “Fast Euclidean morphological operators
using local distance transformation by propagation, and applications,”
Image Processing And Its Applications, 1999. Seventh International
Conference on (Conf. Publ. No. 465), 1999, pp. 856-860 vol.2.
<a class="reference external" href="https://doi.org/10.1049/cp:19990446">DOI:10.1049/cp:19990446</a></p>
</div>
<div class="citation" id="ra67d62e44e71-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id34">2</a><span class="fn-bracket">]</span></span>
<p>Ingemar Ragnemalm, Fast erosion and dilation by contour processing
and thresholding of distance maps, Pattern Recognition Letters,
Volume 13, Issue 3, 1992, Pages 161-166.
<a class="reference external" href="https://doi.org/10.1016/0167-8655(92)90055-5">DOI:10.1016/0167-8655(92)90055-5</a></p>
</div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.isotropic_dilation">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">isotropic_dilation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/isotropic.py#L57-L102"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.isotropic_dilation" title="Link to this definition">#</a></dt>
<dd><p>Return binary morphological dilation of an image.</p>
<p>This function returns the same result as <a class="reference internal" href="#skimage.morphology.binary_dilation" title="skimage.morphology.binary_dilation"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.binary_dilation()</span></code></a>
but performs faster for large circular structuring elements.
This works by applying a threshold to the exact Euclidean distance map
of the inverted image <a class="reference internal" href="#r0a6e410d5981-1" id="id37">[1]</a>, <a class="reference internal" href="#r0a6e410d5981-2" id="id38">[2]</a>.
The implementation is based on: func:<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.distance_transform_edt.html#scipy.ndimage.distance_transform_edt" title="(in SciPy v1.14.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.ndimage.distance_transform_edt</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>The radius by which regions should be dilated.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">float, or sequence of float, optional</span></dt><dd><p>Spacing of elements along each dimension.
If a sequence, must be of length equal to the input’s dimension (number of axes).
If a single number, this value is used for all axes.
If not specified, a grid spacing of unity is implied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dilated</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological dilation with values in
<code class="docutils literal notranslate"><span class="pre">[False,</span> <span class="pre">True]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r0a6e410d5981-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id37">1</a><span class="fn-bracket">]</span></span>
<p>Cuisenaire, O. and Macq, B., “Fast Euclidean morphological operators
using local distance transformation by propagation, and applications,”
Image Processing And Its Applications, 1999. Seventh International
Conference on (Conf. Publ. No. 465), 1999, pp. 856-860 vol.2.
<a class="reference external" href="https://doi.org/10.1049/cp:19990446">DOI:10.1049/cp:19990446</a></p>
</div>
<div class="citation" id="r0a6e410d5981-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id38">2</a><span class="fn-bracket">]</span></span>
<p>Ingemar Ragnemalm, Fast erosion and dilation by contour processing
and thresholding of distance maps, Pattern Recognition Letters,
Volume 13, Issue 3, 1992, Pages 161-166.
<a class="reference external" href="https://doi.org/10.1016/0167-8655(92)90055-5">DOI:10.1016/0167-8655(92)90055-5</a></p>
</div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.isotropic_erosion">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">isotropic_erosion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/isotropic.py#L9-L54"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.isotropic_erosion" title="Link to this definition">#</a></dt>
<dd><p>Return binary morphological erosion of an image.</p>
<p>This function returns the same result as <a class="reference internal" href="#skimage.morphology.binary_erosion" title="skimage.morphology.binary_erosion"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.binary_erosion()</span></code></a>
but performs faster for large circular structuring elements.
This works by applying a threshold to the exact Euclidean distance map
of the image <a class="reference internal" href="#rc28c9b885fab-1" id="id41">[1]</a>, <a class="reference internal" href="#rc28c9b885fab-2" id="id42">[2]</a>.
The implementation is based on: func:<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.distance_transform_edt.html#scipy.ndimage.distance_transform_edt" title="(in SciPy v1.14.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.ndimage.distance_transform_edt</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>The radius by which regions should be eroded.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None,
a new array will be allocated.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">float, or sequence of float, optional</span></dt><dd><p>Spacing of elements along each dimension.
If a sequence, must be of length equal to the input’s dimension (number of axes).
If a single number, this value is used for all axes.
If not specified, a grid spacing of unity is implied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eroded</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological erosion taking values in
<code class="docutils literal notranslate"><span class="pre">[False,</span> <span class="pre">True]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rc28c9b885fab-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id41">1</a><span class="fn-bracket">]</span></span>
<p>Cuisenaire, O. and Macq, B., “Fast Euclidean morphological operators
using local distance transformation by propagation, and applications,”
Image Processing And Its Applications, 1999. Seventh International
Conference on (Conf. Publ. No. 465), 1999, pp. 856-860 vol.2.
<a class="reference external" href="https://doi.org/10.1049/cp:19990446">DOI:10.1049/cp:19990446</a></p>
</div>
<div class="citation" id="rc28c9b885fab-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id42">2</a><span class="fn-bracket">]</span></span>
<p>Ingemar Ragnemalm, Fast erosion and dilation by contour processing
and thresholding of distance maps, Pattern Recognition Letters,
Volume 13, Issue 3, 1992, Pages 161-166.
<a class="reference external" href="https://doi.org/10.1016/0167-8655(92)90055-5">DOI:10.1016/0167-8655(92)90055-5</a></p>
</div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.isotropic_opening">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">isotropic_opening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/isotropic.py#L105-L148"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.isotropic_opening" title="Link to this definition">#</a></dt>
<dd><p>Return binary morphological opening of an image.</p>
<p>This function returns the same result as <a class="reference internal" href="#skimage.morphology.binary_opening" title="skimage.morphology.binary_opening"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.binary_opening()</span></code></a>
but performs faster for large circular structuring elements.
This works by thresholding the exact Euclidean distance map <a class="reference internal" href="#r64be59d1154e-1" id="id45">[1]</a>, <a class="reference internal" href="#r64be59d1154e-2" id="id46">[2]</a>.
The implementation is based on: func:<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.distance_transform_edt.html#scipy.ndimage.distance_transform_edt" title="(in SciPy v1.14.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.ndimage.distance_transform_edt</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float</span></dt><dd><p>The radius with which the regions should be opened.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">float, or sequence of float, optional</span></dt><dd><p>Spacing of elements along each dimension.
If a sequence, must be of length equal to the input’s dimension (number of axes).
If a single number, this value is used for all axes.
If not specified, a grid spacing of unity is implied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opened</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological opening.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r64be59d1154e-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id45">1</a><span class="fn-bracket">]</span></span>
<p>Cuisenaire, O. and Macq, B., “Fast Euclidean morphological operators
using local distance transformation by propagation, and applications,”
Image Processing And Its Applications, 1999. Seventh International
Conference on (Conf. Publ. No. 465), 1999, pp. 856-860 vol.2.
<a class="reference external" href="https://doi.org/10.1049/cp:19990446">DOI:10.1049/cp:19990446</a></p>
</div>
<div class="citation" id="r64be59d1154e-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id46">2</a><span class="fn-bracket">]</span></span>
<p>Ingemar Ragnemalm, Fast erosion and dilation by contour processing
and thresholding of distance maps, Pattern Recognition Letters,
Volume 13, Issue 3, 1992, Pages 161-166.
<a class="reference external" href="https://doi.org/10.1016/0167-8655(92)90055-5">DOI:10.1016/0167-8655(92)90055-5</a></p>
</div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.label">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">label</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/measure/_label.py#L33-L125"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.label" title="Link to this definition">#</a></dt>
<dd><p>Label connected regions of an integer array.</p>
<p>Two pixels are connected when they are neighbors and have the same value.
In 2D, they can be neighbors either in a 1- or 2-connected sense.
The value refers to the maximum number of orthogonal hops to consider a
pixel/voxel a neighbor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">-</span><span class="n">connectivity</span>     <span class="mi">2</span><span class="o">-</span><span class="n">connectivity</span>     <span class="n">diagonal</span> <span class="n">connection</span> <span class="n">close</span><span class="o">-</span><span class="n">up</span>

     <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>             <span class="p">[</span> <span class="p">]</span>
      <span class="o">|</span>               \  <span class="o">|</span>  <span class="o">/</span>                 <span class="o">|</span>  <span class="o">&lt;-</span> <span class="n">hop</span> <span class="mi">2</span>
<span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>      <span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>        <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>
      <span class="o">|</span>               <span class="o">/</span>  <span class="o">|</span>  \             <span class="n">hop</span> <span class="mi">1</span>
     <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label_image</strong><span class="classifier">ndarray of dtype int</span></dt><dd><p>Image to label.</p>
</dd>
<dt><strong>background</strong><span class="classifier">int, optional</span></dt><dd><p>Consider all pixels with this value as background pixels, and label
them as 0. By default, 0-valued pixels are considered as background
pixels.</p>
</dd>
<dt><strong>return_num</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to return the number of assigned labels.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of orthogonal hops to consider a pixel/voxel
as a neighbor.
Accepted values are ranging from  1 to input.ndim. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a full
connectivity of <code class="docutils literal notranslate"><span class="pre">input.ndim</span></code> is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">ndarray of dtype int</span></dt><dd><p>Labeled array, where all connected regions are assigned the
same integer value.</p>
</dd>
<dt><strong>num</strong><span class="classifier">int, optional</span></dt><dd><p>Number of labels, which equals the maximum label index and is only
returned if return_num is <em class="xref py py-obj">True</em>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="skimage.measure.html#skimage.measure.regionprops" title="skimage.measure.regionprops"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.regionprops</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="skimage.measure.html#skimage.measure.regionprops_table" title="skimage.measure.regionprops_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.regionprops_table</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rfdcb8fe18c0f-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Christophe Fiorio and Jens Gustedt, “Two linear time Union-Find
strategies for image processing”, Theoretical Computer Science
154 (1996), pp. 165-181.</p>
</div>
<div class="citation" id="rfdcb8fe18c0f-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Kensheng Wu, Ekow Otoo and Arie Shoshani, “Optimizing connected
component labeling algorithms”, Paper LBNL-56864, 2005,
Lawrence Berkeley National Laboratory (University of California),
<a class="reference external" href="http://repositories.cdlib.org/lbnl/LBNL-56864">http://repositories.cdlib.org/lbnl/LBNL-56864</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 1 0]</span>
<span class="go"> [0 0 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 2 0]</span>
<span class="go"> [0 0 3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 1 0]</span>
<span class="go"> [0 0 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">background</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1 2 2]</span>
<span class="go"> [2 1 2]</span>
<span class="go"> [2 2 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [1 1 2]</span>
<span class="go"> [0 0 0]]</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.local_maxima">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">local_maxima</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_borders</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/extrema.py#L275-L438"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.local_maxima" title="Link to this definition">#</a></dt>
<dd><p>Find local maxima of n-dimensional array.</p>
<p>The local maxima are defined as connected sets of pixels with equal gray
level (plateaus) strictly greater than the gray levels of all pixels in the
neighborhood.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>An n-dimensional array.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The footprint (structuring element) used to determine the neighborhood
of each evaluated pixel (<code class="docutils literal notranslate"><span class="pre">True</span></code> denotes a connected pixel). It must
be a boolean array and have the same number of dimensions as <em class="xref py py-obj">image</em>.
If neither <em class="xref py py-obj">footprint</em> nor <em class="xref py py-obj">connectivity</em> are given, all adjacent
pixels are considered as part of the neighborhood.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>A number used to determine the neighborhood of each evaluated pixel.
Adjacent pixels whose squared distance from the center is less than or
equal to <em class="xref py py-obj">connectivity</em> are considered neighbors. Ignored if
<em class="xref py py-obj">footprint</em> is not None.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the output will be a tuple of one-dimensional arrays
representing the indices of local maxima in each dimension. If False,
the output will be a boolean array with the same shape as <em class="xref py py-obj">image</em>.</p>
</dd>
<dt><strong>allow_borders</strong><span class="classifier">bool, optional</span></dt><dd><p>If true, plateaus that touch the image border are valid maxima.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>maxima</strong><span class="classifier">ndarray or tuple[ndarray]</span></dt><dd><p>If <em class="xref py py-obj">indices</em> is false, a boolean array with the same shape as <em class="xref py py-obj">image</em>
is returned with <code class="docutils literal notranslate"><span class="pre">True</span></code> indicating the position of local maxima
(<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise). If <em class="xref py py-obj">indices</em> is true, a tuple of one-dimensional
arrays containing the coordinates (indices) of all found maxima.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Warns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>UserWarning</dt><dd><p>If <em class="xref py py-obj">allow_borders</em> is false and any dimension of the given <em class="xref py py-obj">image</em> is
shorter than 3 samples, maxima can’t exist and a warning is shown.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.local_minima" title="skimage.morphology.local_minima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.local_minima</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.h_maxima" title="skimage.morphology.h_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.h_maxima</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.h_minima" title="skimage.morphology.h_minima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.h_minima</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function operates on the following ideas:</p>
<ol class="arabic simple">
<li><p>Make a first pass over the image’s last dimension and flag candidates
for local maxima by comparing pixels in only one direction.
If the pixels aren’t connected in the last dimension all pixels are
flagged as candidates instead.</p></li>
</ol>
<p>For each candidate:</p>
<ol class="arabic simple" start="2">
<li><p>Perform a flood-fill to find all connected pixels that have the same
gray value and are part of the plateau.</p></li>
<li><p>Consider the connected neighborhood of a plateau: if no bordering sample
has a higher gray level, mark the plateau as a definite local maximum.</p></li>
</ol>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">local_maxima</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 1, 1, 0, 2, 2, 0],</span>
<span class="go">       [0, 1, 1, 0, 2, 2, 0],</span>
<span class="go">       [1, 0, 0, 0, 0, 0, 3]])</span>
</pre></div>
</div>
<p>Find local maxima by comparing to all neighboring pixels (maximal
connectivity):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">local_maxima</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">array([[False, False, False, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False, False, False, False],</span>
<span class="go">       [ True, False, False, False, False, False,  True]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_maxima</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(array([1, 1, 2, 2, 3, 3]), array([1, 2, 1, 2, 0, 6]))</span>
</pre></div>
</div>
<p>Find local maxima without comparing to diagonal pixels (connectivity 1):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">local_maxima</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[False, False, False, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [ True, False, False, False, False, False,  True]])</span>
</pre></div>
</div>
<p>and exclude maxima that border the image edge:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">local_maxima</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_borders</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([[False, False, False, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [False, False, False, False, False, False, False]])</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="We detect local maxima in a galaxy image. The image is corrupted by noise, generating many loca..."><img alt="" src="../_images/sphx_glr_plot_extrema_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_extrema.html#sphx-glr-auto-examples-segmentation-plot-extrema-py"><span class="std std-ref">Extrema</span></a></p>
  <div class="sphx-glr-thumbnail-title">Extrema</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.local_minima">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">local_minima</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_borders</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/extrema.py#L441-L549"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.local_minima" title="Link to this definition">#</a></dt>
<dd><p>Find local minima of n-dimensional array.</p>
<p>The local minima are defined as connected sets of pixels with equal gray
level (plateaus) strictly smaller than the gray levels of all pixels in the
neighborhood.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>An n-dimensional array.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The footprint (structuring element) used to determine the neighborhood
of each evaluated pixel (<code class="docutils literal notranslate"><span class="pre">True</span></code> denotes a connected pixel). It must
be a boolean array and have the same number of dimensions as <em class="xref py py-obj">image</em>.
If neither <em class="xref py py-obj">footprint</em> nor <em class="xref py py-obj">connectivity</em> are given, all adjacent
pixels are considered as part of the neighborhood.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>A number used to determine the neighborhood of each evaluated pixel.
Adjacent pixels whose squared distance from the center is less than or
equal to <em class="xref py py-obj">connectivity</em> are considered neighbors. Ignored if
<em class="xref py py-obj">footprint</em> is not None.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the output will be a tuple of one-dimensional arrays
representing the indices of local minima in each dimension. If False,
the output will be a boolean array with the same shape as <em class="xref py py-obj">image</em>.</p>
</dd>
<dt><strong>allow_borders</strong><span class="classifier">bool, optional</span></dt><dd><p>If true, plateaus that touch the image border are valid minima.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>minima</strong><span class="classifier">ndarray or tuple[ndarray]</span></dt><dd><p>If <em class="xref py py-obj">indices</em> is false, a boolean array with the same shape as <em class="xref py py-obj">image</em>
is returned with <code class="docutils literal notranslate"><span class="pre">True</span></code> indicating the position of local minima
(<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise). If <em class="xref py py-obj">indices</em> is true, a tuple of one-dimensional
arrays containing the coordinates (indices) of all found minima.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.local_maxima" title="skimage.morphology.local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.local_maxima</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.h_maxima" title="skimage.morphology.h_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.h_maxima</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.h_minima" title="skimage.morphology.h_minima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.h_minima</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function operates on the following ideas:</p>
<ol class="arabic simple">
<li><p>Make a first pass over the image’s last dimension and flag candidates
for local minima by comparing pixels in only one direction.
If the pixels aren’t connected in the last dimension all pixels are
flagged as candidates instead.</p></li>
</ol>
<p>For each candidate:</p>
<ol class="arabic simple" start="2">
<li><p>Perform a flood-fill to find all connected pixels that have the same
gray value and are part of the plateau.</p></li>
<li><p>Consider the connected neighborhood of a plateau: if no bordering sample
has a smaller gray level, mark the plateau as a definite local minimum.</p></li>
</ol>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">local_minima</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span>
<span class="go">array([[ 0,  0,  0,  0,  0,  0,  0],</span>
<span class="go">       [ 0, -1, -1,  0, -2, -2,  0],</span>
<span class="go">       [ 0, -1, -1,  0, -2, -2,  0],</span>
<span class="go">       [-1,  0,  0,  0,  0,  0, -3]])</span>
</pre></div>
</div>
<p>Find local minima by comparing to all neighboring pixels (maximal
connectivity):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">local_minima</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">array([[False, False, False, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False, False, False, False],</span>
<span class="go">       [ True, False, False, False, False, False,  True]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_minima</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(array([1, 1, 2, 2, 3, 3]), array([1, 2, 1, 2, 0, 6]))</span>
</pre></div>
</div>
<p>Find local minima without comparing to diagonal pixels (connectivity 1):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">local_minima</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[False, False, False, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [ True, False, False, False, False, False,  True]])</span>
</pre></div>
</div>
<p>and exclude minima that border the image edge:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">local_minima</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_borders</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([[False, False, False, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [False, False, False, False, False, False, False]])</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.max_tree">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">max_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/max_tree.py#L53-L147"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.max_tree" title="Link to this definition">#</a></dt>
<dd><p>Build the max tree from an image.</p>
<p>Component trees represent the hierarchical structure of the connected
components resulting from sequential thresholding operations applied to an
image. A connected component at one level is parent of a component at a
higher level if the latter is included in the first. A max-tree is an
efficient representation of a component tree. A connected component at
one level is represented by one reference pixel at this level, which is
parent to all other pixels at that level and to the reference pixel at the
level above. The max-tree is the basis for many morphological operators,
namely connected operators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the max-tree is to be calculated.
This image can be of any type.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">unsigned int, optional</span></dt><dd><p>The neighborhood connectivity. The integer represents the maximum
number of orthogonal steps to reach a neighbor. In 2D, it is 1 for
a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>parent</strong><span class="classifier">ndarray, int64</span></dt><dd><p>Array of same shape as image. The value of each pixel is the index of
its parent in the ravelled array.</p>
</dd>
<dt><strong>tree_traverser</strong><span class="classifier">1D array, int64</span></dt><dd><p>The ordered pixel indices (referring to the ravelled array). The pixels
are ordered such that every pixel is preceded by its parent (except for
the root which has no parent).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rd26fa56f6eaa-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Salembier, P., Oliveras, A., &amp; Garrido, L. (1998). Antiextensive
Connected Operators for Image and Sequence Processing.
IEEE Transactions on Image Processing, 7(4), 555-570.
<a class="reference external" href="https://doi.org/10.1109/83.663500">DOI:10.1109/83.663500</a></p>
</div>
<div class="citation" id="rd26fa56f6eaa-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Berger, C., Geraud, T., Levillain, R., Widynski, N., Baillard, A.,
Bertin, E. (2007). Effective Component Tree Computation with
Application to Pattern Recognition in Astronomical Imaging.
In International Conference on Image Processing (ICIP) (pp. 41-44).
<a class="reference external" href="https://doi.org/10.1109/ICIP.2007.4379949">DOI:10.1109/ICIP.2007.4379949</a></p>
</div>
<div class="citation" id="rd26fa56f6eaa-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Najman, L., &amp; Couprie, M. (2006). Building the component tree in
quasi-linear time. IEEE Transactions on Image Processing, 15(11),
3531-3539.
<a class="reference external" href="https://doi.org/10.1109/TIP.2006.877518">DOI:10.1109/TIP.2006.877518</a></p>
</div>
<div class="citation" id="rd26fa56f6eaa-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of
Component Tree Computation Algorithms. IEEE Transactions on Image
Processing, 23(9), 3885-3895.
<a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<p>We create a small sample image (Figure 1 from [4]) and build the max-tree.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">max_tree</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The max-tree is a hierarchical representation of an image that is the basis for a large family ..."><img alt="" src="../_images/sphx_glr_plot_max_tree_thumb.png" />
<p><a class="reference internal" href="../auto_examples/developers/plot_max_tree.html#sphx-glr-auto-examples-developers-plot-max-tree-py"><span class="std std-ref">Max-tree</span></a></p>
  <div class="sphx-glr-thumbnail-title">Max-tree</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.max_tree_local_maxima">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">max_tree_local_maxima</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_traverser</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/max_tree.py#L612-L700"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.max_tree_local_maxima" title="Link to this definition">#</a></dt>
<dd><p>Determine all local maxima of the image.</p>
<p>The local maxima are defined as connected sets of pixels with equal
gray level strictly greater than the gray levels of all pixels in direct
neighborhood of the set. The function labels the local maxima.</p>
<p>Technically, the implementation is based on the max-tree representation
of an image. The function is very efficient if the max-tree representation
has already been computed. Otherwise, it is preferable to use
the function local_maxima.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the maxima are to be calculated.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">unsigned int, optional</span></dt><dd><p>The neighborhood connectivity. The integer represents the maximum
number of orthogonal steps to reach a neighbor. In 2D, it is 1 for
a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p>
</dd>
<dt><strong>parent</strong><span class="classifier">ndarray, int64, optional</span></dt><dd><p>The value of each pixel is the index of its parent in the ravelled
array.</p>
</dd>
<dt><strong>tree_traverser</strong><span class="classifier">1D array, int64, optional</span></dt><dd><p>The ordered pixel indices (referring to the ravelled array). The pixels
are ordered such that every pixel is preceded by its parent (except for
the root which has no parent).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>local_max</strong><span class="classifier">ndarray, uint64</span></dt><dd><p>Labeled local maxima of the image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.local_maxima" title="skimage.morphology.local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.local_maxima</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.max_tree</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r3593ae75839c-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Vincent L., Proc. “Grayscale area openings and closings,
their efficient implementation and applications”,
EURASIP Workshop on Mathematical Morphology and its
Applications to Signal Processing, Barcelona, Spain, pp.22-27,
May 1993.</p>
</div>
<div class="citation" id="r3593ae75839c-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Soille, P., “Morphological Image Analysis: Principles and
Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.
<a class="reference external" href="https://doi.org/10.1007/978-3-662-05088-0">DOI:10.1007/978-3-662-05088-0</a></p>
</div>
<div class="citation" id="r3593ae75839c-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>Salembier, P., Oliveras, A., &amp; Garrido, L. (1998). Antiextensive
Connected Operators for Image and Sequence Processing.
IEEE Transactions on Image Processing, 7(4), 555-570.
<a class="reference external" href="https://doi.org/10.1109/83.663500">DOI:10.1109/83.663500</a></p>
</div>
<div class="citation" id="r3593ae75839c-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p>Najman, L., &amp; Couprie, M. (2006). Building the component tree in
quasi-linear time. IEEE Transactions on Image Processing, 15(11),
3531-3539.
<a class="reference external" href="https://doi.org/10.1109/TIP.2006.877518">DOI:10.1109/TIP.2006.877518</a></p>
</div>
<div class="citation" id="r3593ae75839c-5" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of
Component Tree Computation Algorithms. IEEE Transactions on Image
Processing, 23(9), 3885-3895.
<a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<p>We create an image (quadratic function with a maximum in the center and
4 additional constant maxima.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate all local maxima:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">maxima</span> <span class="o">=</span> <span class="n">max_tree_local_maxima</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting image contains the labeled local maxima.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.medial_axis">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">medial_axis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/_skeletonize.py#L356-L516"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.medial_axis" title="Link to this definition">#</a></dt>
<dd><p>Compute the medial axis transform of a binary image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">binary ndarray, shape (M, N)</span></dt><dd><p>The image of the shape to skeletonize. If this input isn’t already a
binary image, it gets converted into one: In this case, zero values are
considered background (False), nonzero values are considered
foreground (True).</p>
</dd>
<dt><strong>mask</strong><span class="classifier">binary ndarray, shape (M, N), optional</span></dt><dd><p>If a mask is given, only those elements in <em class="xref py py-obj">image</em> with a true
value in <em class="xref py py-obj">mask</em> are used for computing the medial axis.</p>
</dd>
<dt><strong>return_distance</strong><span class="classifier">bool, optional</span></dt><dd><p>If true, the distance transform is returned as well as the skeleton.</p>
</dd>
<dt><strong>rng</strong><span class="classifier">{<a class="reference external" href="https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.Generator" title="(in NumPy v2.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.Generator</span></code></a>, int}, optional</span></dt><dd><p>Pseudo-random number generator.
By default, a PCG64 generator is used (see <a class="reference external" href="https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.default_rng" title="(in NumPy v2.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.random.default_rng()</span></code></a>).
If <em class="xref py py-obj">rng</em> is an int, it is used to seed the generator.</p>
<p>The PRNG determines the order in which pixels are processed for
tiebreaking.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of bools</span></dt><dd><p>Medial axis transform of the image</p>
</dd>
<dt><strong>dist</strong><span class="classifier">ndarray of ints, optional</span></dt><dd><p>Distance transform of the image (only returned if <em class="xref py py-obj">return_distance</em>
is True)</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skeletonize</span></code></a>, <a class="reference internal" href="#skimage.morphology.thin" title="skimage.morphology.thin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">thin</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This algorithm computes the medial axis transform of an image
as the ridges of its distance transform.</p>
<dl class="simple">
<dt>The different steps of the algorithm are as follows</dt><dd><ul class="simple">
<li><p>A lookup table is used, that assigns 0 or 1 to each configuration of
the 3x3 binary square, whether the central pixel should be removed
or kept. We want a point to be removed if it has more than one neighbor
and if removing it does not change the number of connected components.</p></li>
<li><p>The distance transform to the background is computed, as well as
the cornerness of the pixel.</p></li>
<li><p>The foreground (value of 1) points are ordered by
the distance transform, then the cornerness.</p></li>
<li><p>A cython function is called to reduce the image to its skeleton. It
processes pixels in the order determined at the previous step, and
removes or maintains a pixel according to the lookup table. Because
of the ordering, it is possible to process all pixels in only one
pass.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">medial_axis</span><span class="p">(</span><span class="n">square</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Skeletonization reduces binary objects to 1 pixel wide representations. This can be useful for ..."><img alt="" src="../_images/sphx_glr_plot_skeleton_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_skeleton.html#sphx-glr-auto-examples-edges-plot-skeleton-py"><span class="std std-ref">Skeletonize</span></a></p>
  <div class="sphx-glr-thumbnail-title">Skeletonize</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.mirror_footprint">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">mirror_footprint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">footprint</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/footprints.py#L967-L994"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.mirror_footprint" title="Link to this definition">#</a></dt>
<dd><p>Mirror each dimension in the footprint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple</span></dt><dd><p>The input footprint or sequence of footprints</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inverted</strong><span class="classifier">ndarray or tuple</span></dt><dd><p>The footprint, mirrored along each dimension.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">footprint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mirror_footprint</span><span class="p">(</span><span class="n">footprint</span><span class="p">)</span>
<span class="go">array([[1, 1, 0],</span>
<span class="go">       [1, 1, 0],</span>
<span class="go">       [0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.octagon">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">octagon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/footprints.py#L836-L916"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.octagon" title="Link to this definition">#</a></dt>
<dd><p>Generates an octagon shaped footprint.</p>
<p>For a given size of (m) horizontal and vertical sides
and a given (n) height or width of slanted sides octagon is generated.
The slanted sides are 45 or 135 degrees to the horizontal axis
and hence the widths and heights are equal. The overall size of the
footprint along a single axis will be <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">n</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>m</strong><span class="classifier">int</span></dt><dd><p>The size of the horizontal and vertical sides.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The height or width of the slanted sides.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.
When <em class="xref py py-obj">decomposition</em> is None, this is just a numpy.ndarray. Otherwise,
this will be a tuple whose length is equal to the number of unique
structuring elements to apply (see Notes for more detail)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, ‘sequence’}, optional</span></dt><dd><p>If None, a single array is returned. For ‘sequence’, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given an identical result to a single, larger footprint, but with
better computational performance. See Notes for more details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When <em class="xref py py-obj">decomposition</em> is not None, each element of the <em class="xref py py-obj">footprint</em>
tuple is a 2-tuple of the form <code class="docutils literal notranslate"><span class="pre">(ndarray,</span> <span class="pre">num_iter)</span></code> that specifies a
footprint array and the number of iterations it is to be applied.</p>
<p>For either binary or grayscale morphology, using
<code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code> was observed to have a performance benefit,
with the magnitude of the benefit increasing with increasing footprint
size.</p>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :pyskimage.morphology to generate footprints (struct..."><img alt="" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Generate footprints (structuring elements)</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Many footprints (structuring elements) can be decomposed into an equivalent series of smaller s..."><img alt="" src="../_images/sphx_glr_plot_footprint_decompositions_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_footprint_decompositions.html#sphx-glr-auto-examples-numpy-operations-plot-footprint-decompositions-py"><span class="std std-ref">Decompose flat footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Decompose flat footprints (structuring elements)</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.octahedron">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">octahedron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/footprints.py#L702-L760"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.octahedron" title="Link to this definition">#</a></dt>
<dd><p>Generates a octahedron-shaped footprint.</p>
<p>This is the 3D equivalent of a diamond.
A pixel is part of the neighborhood (i.e. labeled 1) if
the city block/Manhattan distance between it and the center of
the neighborhood is no greater than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the octahedron-shaped footprint.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.
When <em class="xref py py-obj">decomposition</em> is None, this is just a numpy.ndarray. Otherwise,
this will be a tuple whose length is equal to the number of unique
structuring elements to apply (see Notes for more detail)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, ‘sequence’}, optional</span></dt><dd><p>If None, a single array is returned. For ‘sequence’, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given an identical result to a single, larger footprint, but with
better computational performance. See Notes for more details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When <em class="xref py py-obj">decomposition</em> is not None, each element of the <em class="xref py py-obj">footprint</em>
tuple is a 2-tuple of the form <code class="docutils literal notranslate"><span class="pre">(ndarray,</span> <span class="pre">num_iter)</span></code> that specifies a
footprint array and the number of iterations it is to be applied.</p>
<p>For either binary or grayscale morphology, using
<code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code> was observed to have a performance benefit,
with the magnitude of the benefit increasing with increasing footprint
size.</p>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :pyskimage.morphology to generate footprints (struct..."><img alt="" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Generate footprints (structuring elements)</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Many footprints (structuring elements) can be decomposed into an equivalent series of smaller s..."><img alt="" src="../_images/sphx_glr_plot_footprint_decompositions_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_footprint_decompositions.html#sphx-glr-auto-examples-numpy-operations-plot-footprint-decompositions-py"><span class="std std-ref">Decompose flat footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Decompose flat footprints (structuring elements)</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.opening">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">opening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/gray.py#L366-L440"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.opening" title="Link to this definition">#</a></dt>
<dd><p>Return grayscale morphological opening of an image.</p>
<p>The morphological opening of an image is defined as an erosion followed by
a dilation. Opening can remove small bright spots (i.e. “salt”) and connect
small dark cracks. This tends to “open” up (dark) gaps between (bright)
features.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>The <em class="xref py py-obj">mode</em> parameter determines how the array borders are handled.
Valid modes are: ‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’,
‘max’, ‘min’, or ‘ignore’.
If ‘ignore’, pixels outside the image domain are assumed
to be the maximum for the image’s dtype in the erosion, and minimum
in the dilation, which causes them to not influence the result.
Default is ‘reflect’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <em class="xref py py-obj">mode</em> is ‘constant’. Default
is 0.0.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.23: </span><em class="xref py py-obj">mode</em> and <em class="xref py py-obj">cval</em> were added in 0.23.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>opening</strong><span class="classifier">array, same shape and type as <em class="xref py py-obj">image</em></span></dt><dd><p>The result of the morphological opening.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(np.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(np.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=np.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<a class="reference internal" href="#skimage.morphology.disk" title="skimage.morphology.disk"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.disk()</span></code></a> provide an option to automatically generate
a footprint sequence of this type.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Open up gap between two bright regions (but also shrink regions)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bad_connection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opening</span><span class="p">(</span><span class="n">bad_connection</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 0, 1, 1],</span>
<span class="go">       [1, 1, 0, 1, 1],</span>
<span class="go">       [1, 1, 0, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example is about comparing the segmentations obtained using the plain SLIC method [1]_ and..."><img alt="" src="../_images/sphx_glr_plot_mask_slic_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_mask_slic.html#sphx-glr-auto-examples-segmentation-plot-mask-slic-py"><span class="std std-ref">Apply maskSLIC vs SLIC</span></a></p>
  <div class="sphx-glr-thumbnail-title">Apply maskSLIC vs SLIC</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><img alt="" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></p>
  <div class="sphx-glr-thumbnail-title">Morphological Filtering</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Optical coherence tomography (OCT) is a non-invasive imaging technique used by ophthalmologists..."><img alt="" src="../_images/sphx_glr_plot_cornea_spot_inpainting_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_cornea_spot_inpainting.html#sphx-glr-auto-examples-applications-plot-cornea-spot-inpainting-py"><span class="std std-ref">Restore spotted cornea image with inpainting</span></a></p>
  <div class="sphx-glr-thumbnail-title">Restore spotted cornea image with inpainting</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.pad_footprint">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">pad_footprint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">footprint</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/footprints.py#L997-L1030"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.pad_footprint" title="Link to this definition">#</a></dt>
<dd><p>Pad the footprint to an odd size along each dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple</span></dt><dd><p>The input footprint or sequence of footprints</p>
</dd>
<dt><strong>pad_end</strong><span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, pads at the end of each dimension (right side), otherwise
pads on the front (left side).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>padded</strong><span class="classifier">ndarray or tuple</span></dt><dd><p>The footprint, padded to an odd size along each dimension.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">footprint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                      <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pad_footprint</span><span class="p">(</span><span class="n">footprint</span><span class="p">)</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [1, 1, 0],</span>
<span class="go">       [1, 1, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.reconstruction">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">reconstruction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dilation'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/grayreconstruct.py#L8-L217"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.reconstruction" title="Link to this definition">#</a></dt>
<dd><p>Perform a morphological reconstruction of an image.</p>
<p>Morphological reconstruction by dilation is similar to basic morphological
dilation: high-intensity values will replace nearby low-intensity values.
The basic dilation operator, however, uses a footprint to
determine how far a value in the input image can spread. In contrast,
reconstruction uses two images: a “seed” image, which specifies the values
that spread, and a “mask” image, which gives the maximum allowed value at
each pixel. The mask image, like the footprint, limits the spread
of high-intensity values. Reconstruction by erosion is simply the inverse:
low-intensity values spread from the seed image and are limited by the mask
image, which represents the minimum allowed value.</p>
<p>Alternatively, you can think of reconstruction as a way to isolate the
connected regions of an image. For dilation, reconstruction connects
regions marked by local maxima in the seed image: neighboring pixels
less-than-or-equal-to those seeds are connected to the seeded region.
Local maxima with values larger than the seed image will get truncated to
the seed value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seed</strong><span class="classifier">ndarray</span></dt><dd><p>The seed image (a.k.a. marker image), which specifies the values that
are dilated or eroded.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">ndarray</span></dt><dd><p>The maximum (dilation) / minimum (erosion) allowed value at each pixel.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘dilation’|’erosion’}, optional</span></dt><dd><p>Perform reconstruction by dilation or erosion. In dilation (or
erosion), the seed image is dilated (or eroded) until limited by the
mask image. For dilation, each seed value must be less than or equal
to the corresponding mask value; for erosion, the reverse is true.
Default is ‘dilation’.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an n-D array of 1’s and 0’s.
Default is the n-D square of radius equal to 1 (i.e. a 3x3 square
for 2D images, a 3x3x3 cube for 3D images, etc.)</p>
</dd>
<dt><strong>offset</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The coordinates of the center of the footprint.
Default is located on the geometrical center of the footprint, in that
case footprint dimensions must be odd.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reconstructed</strong><span class="classifier">ndarray</span></dt><dd><p>The result of morphological reconstruction.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The algorithm is taken from <a class="reference internal" href="#r4e1a5d6f491d-1" id="id60">[1]</a>. Applications for grayscale reconstruction
are discussed in <a class="reference internal" href="#r4e1a5d6f491d-2" id="id61">[2]</a> and <a class="reference internal" href="#r4e1a5d6f491d-3" id="id62">[3]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r4e1a5d6f491d-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id60">1</a><span class="fn-bracket">]</span></span>
<p>Robinson, “Efficient morphological reconstruction: a downhill
filter”, Pattern Recognition Letters 25 (2004) 1759-1767.</p>
</div>
<div class="citation" id="r4e1a5d6f491d-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id61">2</a><span class="fn-bracket">]</span></span>
<p>Vincent, L., “Morphological Grayscale Reconstruction in Image
Analysis: Applications and Efficient Algorithms”, IEEE Transactions
on Image Processing (1993)</p>
</div>
<div class="citation" id="r4e1a5d6f491d-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id62">3</a><span class="fn-bracket">]</span></span>
<p>Soille, P., “Morphological Image Analysis: Principles and
Applications”, Chapter 6, 2nd edition (2003), ISBN 3540429883.</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">reconstruction</span>
</pre></div>
</div>
<p>First, we create a sinusoidal mask image with peaks at middle and ends.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, we create a seed image initialized to the minimum mask value (for
reconstruction by dilation, min-intensity values don’t spread) and add
“seeds” to the left and right peak, but at a fraction of peak value (1).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_seed</span> <span class="o">=</span> <span class="n">y_mask</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_seed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_seed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_rec</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">y_seed</span><span class="p">,</span> <span class="n">y_mask</span><span class="p">)</span>
</pre></div>
</div>
<p>The reconstructed image (or curve, in this case) is exactly the same as the
mask image, except that the peaks are truncated to 0.5 and 0. The middle
peak disappears completely: Since there were no seed values in this peak
region, its reconstructed value is truncated to the surrounding value (-1).</p>
<p>As a more practical example, we try to extract the bright features of an
image by subtracting a background image created by reconstruction.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="mi">20</span><span class="p">:</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mf">0.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bumps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>To create the background image, set the mask image to the original image,
and the seed image to the original image with an intensity offset, <em class="xref py py-obj">h</em>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seed</span> <span class="o">=</span> <span class="n">bumps</span> <span class="o">-</span> <span class="n">h</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">bumps</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting reconstructed image looks exactly like the original image,
but with the peaks of the bumps cut off. Subtracting this reconstructed
image from the original image leaves just the peaks of the bumps</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdome</span> <span class="o">=</span> <span class="n">bumps</span> <span class="o">-</span> <span class="n">background</span>
</pre></div>
</div>
<p>This operation is known as the h-dome of the image and leaves features
of height <em class="xref py py-obj">h</em> in the subtracted image.</p>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Here, we use morphological reconstruction to create a background image, which we can subtract f..."><img alt="" src="../_images/sphx_glr_plot_regional_maxima_thumb.png" />
<p><a class="reference internal" href="../auto_examples/color_exposure/plot_regional_maxima.html#sphx-glr-auto-examples-color-exposure-plot-regional-maxima-py"><span class="std std-ref">Filtering regional maxima</span></a></p>
  <div class="sphx-glr-thumbnail-title">Filtering regional maxima</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="We fill holes (i.e. isolated, dark spots) in an image using morphological reconstruction by ero..."><img alt="" src="../_images/sphx_glr_plot_holes_and_peaks_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_holes_and_peaks.html#sphx-glr-auto-examples-features-detection-plot-holes-and-peaks-py"><span class="std std-ref">Filling holes and finding peaks</span></a></p>
  <div class="sphx-glr-thumbnail-title">Filling holes and finding peaks</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.rectangle">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">rectangle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nrows</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/footprints.py#L177-L255"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.rectangle" title="Link to this definition">#</a></dt>
<dd><p>Generates a flat, rectangular-shaped footprint.</p>
<p>Every pixel in the rectangle generated for a given width and given height
belongs to the neighborhood.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nrows</strong><span class="classifier">int</span></dt><dd><p>The number of rows of the rectangle.</p>
</dd>
<dt><strong>ncols</strong><span class="classifier">int</span></dt><dd><p>The number of columns of the rectangle.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple</span></dt><dd><p>A footprint consisting only of ones, i.e. every pixel belongs to the
neighborhood. When <em class="xref py py-obj">decomposition</em> is None, this is just a
numpy.ndarray. Otherwise, this will be a tuple whose length is equal to
the number of unique structuring elements to apply (see Notes for more
detail)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, ‘separable’, ‘sequence’}, optional</span></dt><dd><p>If None, a single array is returned. For ‘sequence’, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
given an identical result to a single, larger footprint, but often with
better computational performance. See Notes for more details.
With ‘separable’, this function uses separable 1D footprints for each
axis. Whether ‘sequence’ or ‘separable’ is computationally faster may
be architecture-dependent.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When <em class="xref py py-obj">decomposition</em> is not None, each element of the <em class="xref py py-obj">footprint</em>
tuple is a 2-tuple of the form <code class="docutils literal notranslate"><span class="pre">(ndarray,</span> <span class="pre">num_iter)</span></code> that specifies a
footprint array and the number of iterations it is to be applied.</p>
<p>For binary morphology, using <code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code>
was observed to give better performance, with the magnitude of the
performance increase rapidly increasing with footprint size. For grayscale
morphology with rectangular footprints, it is recommended to use
<code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code> since the internal SciPy functions that are called
already have a fast implementation based on separable 1D sliding windows.</p>
<p>The <em class="xref py py-obj">sequence</em> decomposition mode only supports odd valued <em class="xref py py-obj">nrows</em> and
<em class="xref py py-obj">ncols</em>. If either <em class="xref py py-obj">nrows</em> or <em class="xref py py-obj">ncols</em> is even, the sequence used will be
identical to <code class="docutils literal notranslate"><span class="pre">decomposition='separable'</span></code>.</p>
<ul class="simple">
<li><p>The use of <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code> has been deprecated in
version 0.18.0. Use <code class="docutils literal notranslate"><span class="pre">nrows</span></code> and <code class="docutils literal notranslate"><span class="pre">ncols</span></code> instead.</p></li>
</ul>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :pyskimage.morphology to generate footprints (struct..."><img alt="" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Generate footprints (structuring elements)</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Many footprints (structuring elements) can be decomposed into an equivalent series of smaller s..."><img alt="" src="../_images/sphx_glr_plot_footprint_decompositions_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_footprint_decompositions.html#sphx-glr-auto-examples-numpy-operations-plot-footprint-decompositions-py"><span class="std std-ref">Decompose flat footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Decompose flat footprints (structuring elements)</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.remove_objects_by_distance">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">remove_objects_by_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_distance</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priority</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/misc.py#L248-L454"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.remove_objects_by_distance" title="Link to this definition">#</a></dt>
<dd><p>Remove objects, in specified order, until remaining are a minimum distance apart.</p>
<p>Remove labeled objects from an image until the remaining ones are spaced
more than a given distance from one another. By default, smaller objects
are removed first.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label_image</strong><span class="classifier">ndarray of integers</span></dt><dd><p>An n-dimensional array containing object labels, e.g. as returned by
<a class="reference internal" href="#skimage.morphology.label" title="skimage.morphology.label"><code class="xref py py-func docutils literal notranslate"><span class="pre">label()</span></code></a>. A value of zero is considered background, all other
object IDs must be positive integers.</p>
</dd>
<dt><strong>min_distance</strong><span class="classifier">int or float</span></dt><dd><p>Remove objects whose distance to other objects is not greater than this
positive value. Objects with a lower <em class="xref py py-obj">priority</em> are removed first.</p>
</dd>
<dt><strong>priority</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Defines the priority with which objects are removed. Expects a
1-dimensional array of length
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.amax.html#numpy.amax" title="(in NumPy v2.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">np.amax(label_image)</span> <span class="pre">+</span> <span class="pre">1</span></code></a> that contains the priority
for each object’s label at the respective index. Objects with a lower value
are removed first until all remaining objects fulfill the distance
requirement. If not given, priority is given to objects with a higher
number of samples and their label value second.</p>
</dd>
<dt><strong>p_norm</strong><span class="classifier">int or float, optional</span></dt><dd><p>The Minkowski distance of order p, used to calculate the distance
between objects. The default <code class="docutils literal notranslate"><span class="pre">2</span></code> corresponds to the Euclidean
distance, <code class="docutils literal notranslate"><span class="pre">1</span></code> to the “Manhattan” distance, and <code class="docutils literal notranslate"><span class="pre">np.inf</span></code> to the
Chebyshev distance.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">sequence of float, optional</span></dt><dd><p>The pixel spacing along each axis of <em class="xref py py-obj">label_image</em>. If not specified,
a grid spacing of unity (1) is implied.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Array of the same shape and dtype as <em class="xref py py-obj">image</em>, into which the output is
placed. By default, a new array is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Array of the same shape as <em class="xref py py-obj">label_image</em>, for which objects that violate
the <em class="xref py py-obj">min_distance</em> condition were removed.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.remove_small_objects" title="skimage.morphology.remove_small_objects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_objects</span></code></a></dt><dd><p>Remove objects smaller than the specified size.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The basic steps of this algorithm work as follows:</p>
<ol class="arabic simple">
<li><p>Find the indices for of all given objects and separate them depending on
if they point to an object’s border or not.</p></li>
<li><p>Sort indices by their label value, ensuring that indices which point to
the same object are next to each other. This optimization allows finding
all parts of an object, simply by stepping to the neighboring indices.</p></li>
<li><p>Sort boundary indices by <em class="xref py py-obj">priority</em>. Use a stable-sort to preserve the
ordering from the previous sorting step. If <em class="xref py py-obj">priority</em> is not given,
use <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.bincount.html#numpy.bincount" title="(in NumPy v2.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.bincount()</span></code></a> as a fallback.</p></li>
<li><p>Construct a <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.cKDTree.html#scipy.spatial.cKDTree" title="(in SciPy v1.14.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.spatial.cKDTree</span></code></a> from the boundary indices.</p></li>
<li><p>Iterate across boundary indices in priority-sorted order, and query the
kd-tree for objects that are too close. Remove ones that are and don’t
take them into account when evaluating other objects later on.</p></li>
</ol>
<p>The performance of this algorithm depends on the number of samples in
<em class="xref py py-obj">label_image</em> that belong to an object’s border.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">skimage</span> <span class="k">as</span> <span class="nn">ski</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ski</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">remove_objects_by_distance</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([0, 0, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ski</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">remove_objects_by_distance</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">array([2, 0, 0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ski</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">remove_objects_by_distance</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">label_image</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">3</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">array([[8, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9],</span>
<span class="go">       [8, 8, 8, 0, 0, 0, 0, 0, 0, 9, 9],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7]])</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="scikit-image has several ways of removing objects from N-dimensional images. Here, &quot;objects&quot; (a..."><img alt="" src="../_images/sphx_glr_plot_remove_objects_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_remove_objects.html#sphx-glr-auto-examples-features-detection-plot-remove-objects-py"><span class="std std-ref">Removing objects</span></a></p>
  <div class="sphx-glr-thumbnail-title">Removing objects</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.remove_small_holes">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">remove_small_holes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">area_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/misc.py#L162-L245"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.remove_small_holes" title="Link to this definition">#</a></dt>
<dd><p>Remove contiguous holes smaller than the specified size.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ar</strong><span class="classifier">ndarray (arbitrary shape, int or bool type)</span></dt><dd><p>The array containing the connected components of interest.</p>
</dd>
<dt><strong>area_threshold</strong><span class="classifier">int, optional (default: 64)</span></dt><dd><p>The maximum area, in pixels, of a contiguous hole that will be filled.
Replaces <em class="xref py py-obj">min_size</em>.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, {1, 2, …, ar.ndim}, optional (default: 1)</span></dt><dd><p>The connectivity defining the neighborhood of a pixel.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Array of the same shape as <em class="xref py py-obj">ar</em> and bool dtype, into which the
output is placed. By default, a new array is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">ndarray, same shape and type as input <em class="xref py py-obj">ar</em></span></dt><dd><p>The input array with small holes within connected components removed.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If the input array is of an invalid type, such as float or string.</p>
</dd>
<dt>ValueError</dt><dd><p>If the input array contains negative values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If the array type is int, it is assumed that it contains already-labeled
objects. The labels are not kept in the output image (this function always
outputs a bool image). It is suggested that labeling is completed after
using this function.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">morphology</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_holes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[ True,  True,  True,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True, False],</span>
<span class="go">       [ True, False, False,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_holes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[ True,  True,  True,  True,  True, False],</span>
<span class="go">       [ True,  True,  True, False,  True, False],</span>
<span class="go">       [ True, False, False,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_holes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example is about comparing the segmentations obtained using the plain SLIC method [1]_ and..."><img alt="" src="../_images/sphx_glr_plot_mask_slic_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_mask_slic.html#sphx-glr-auto-examples-segmentation-plot-mask-slic-py"><span class="std std-ref">Apply maskSLIC vs SLIC</span></a></p>
  <div class="sphx-glr-thumbnail-title">Apply maskSLIC vs SLIC</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima..."><img alt="" src="../_images/sphx_glr_plot_regionprops_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></p>
  <div class="sphx-glr-thumbnail-title">Measure region properties</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.remove_small_objects">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">remove_small_objects</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/misc.py#L63-L159"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.remove_small_objects" title="Link to this definition">#</a></dt>
<dd><p>Remove objects smaller than the specified size.</p>
<p>Expects ar to be an array with labeled objects, and removes objects
smaller than min_size. If <em class="xref py py-obj">ar</em> is bool, the image is first labeled.
This leads to potentially different behavior for bool and 0-and-1
arrays.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ar</strong><span class="classifier">ndarray (arbitrary shape, int or bool type)</span></dt><dd><p>The array containing the objects of interest. If the array type is
int, the ints must be non-negative.</p>
</dd>
<dt><strong>min_size</strong><span class="classifier">int, optional (default: 64)</span></dt><dd><p>The smallest allowable object size.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, {1, 2, …, ar.ndim}, optional (default: 1)</span></dt><dd><p>The connectivity defining the neighborhood of a pixel. Used during
labelling if <em class="xref py py-obj">ar</em> is bool.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Array of the same shape as <em class="xref py py-obj">ar</em>, into which the output is
placed. By default, a new array is created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">ndarray, same shape and type as input <em class="xref py py-obj">ar</em></span></dt><dd><p>The input array with small connected components removed.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If the input array is of an invalid type, such as float or string.</p>
</dd>
<dt>ValueError</dt><dd><p>If the input array contains negative values.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.remove_objects_by_distance" title="skimage.morphology.remove_objects_by_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.remove_objects_by_distance</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">morphology</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[False, False, False, False, False],</span>
<span class="go">       [ True,  True,  True, False, False],</span>
<span class="go">       [ True,  True,  True, False, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[False, False, False,  True, False],</span>
<span class="go">       [ True,  True,  True, False, False],</span>
<span class="go">       [ True,  True,  True, False, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="scikit-image has several ways of removing objects from N-dimensional images. Here, &quot;objects&quot; (a..."><img alt="" src="../_images/sphx_glr_plot_remove_objects_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_remove_objects.html#sphx-glr-auto-examples-features-detection-plot-remove-objects-py"><span class="std std-ref">Removing objects</span></a></p>
  <div class="sphx-glr-thumbnail-title">Removing objects</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example is about comparing the segmentations obtained using the plain SLIC method [1]_ and..."><img alt="" src="../_images/sphx_glr_plot_mask_slic_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_mask_slic.html#sphx-glr-auto-examples-segmentation-plot-mask-slic-py"><span class="std std-ref">Apply maskSLIC vs SLIC</span></a></p>
  <div class="sphx-glr-thumbnail-title">Apply maskSLIC vs SLIC</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima..."><img alt="" src="../_images/sphx_glr_plot_regionprops_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></p>
  <div class="sphx-glr-thumbnail-title">Measure region properties</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="When trying out different segmentation methods, how do you know which one is best? If you have ..."><img alt="" src="../_images/sphx_glr_plot_metrics_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_metrics.html#sphx-glr-auto-examples-segmentation-plot-metrics-py"><span class="std std-ref">Evaluating segmentation metrics</span></a></p>
  <div class="sphx-glr-thumbnail-title">Evaluating segmentation metrics</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example, we will see how to segment objects from a background. We use the coins image f..."><img alt="" src="../_images/sphx_glr_plot_coins_segmentation_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_coins_segmentation.html#sphx-glr-auto-examples-applications-plot-coins-segmentation-py"><span class="std std-ref">Comparing edge-based and region-based segmentation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Comparing edge-based and region-based segmentation</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.skeletonize">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">skeletonize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/_skeletonize.py#L14-L92"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.skeletonize" title="Link to this definition">#</a></dt>
<dd><p>Compute the skeleton of a binary image.</p>
<p>Thinning is used to reduce each connected component in a binary image
to a single-pixel wide skeleton.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray, 2D or 3D</span></dt><dd><p>An image containing the objects to be skeletonized. Zeros or <code class="docutils literal notranslate"><span class="pre">False</span></code>
represent background, nonzero values or <code class="docutils literal notranslate"><span class="pre">True</span></code> are foreground.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘zhang’, ‘lee’}, optional</span></dt><dd><p>Which algorithm to use. Zhang’s algorithm <a class="reference internal" href="#rc75910d539e3-zha84" id="id66">[Zha84]</a> only works for
2D images, and is the default for 2D. Lee’s algorithm <a class="reference internal" href="#rc75910d539e3-lee94" id="id67">[Lee94]</a>
works for 2D or 3D images and is the default for 3D.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>skeleton</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The thinned image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">medial_axis</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rc75910d539e3-lee94" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id67">Lee94</a><span class="fn-bracket">]</span></span>
<p>T.-C. Lee, R.L. Kashyap and C.-N. Chu, Building skeleton models
via 3-D medial surface/axis thinning algorithms.
Computer Vision, Graphics, and Image Processing, 56(6):462-478, 1994.</p>
</div>
<div class="citation" id="rc75910d539e3-zha84" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id66">Zha84</a><span class="fn-bracket">]</span></span>
<p>A fast parallel algorithm for thinning digital patterns,
T. Y. Zhang and C. Y. Suen, Communications of the ACM,
March 1984, Volume 27, Number 3.</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ellipse</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ellipse</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span> <span class="o">=</span> <span class="n">skeletonize</span><span class="p">(</span><span class="n">ellipse</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Skeletonization reduces binary objects to 1 pixel wide representations. This can be useful for ..."><img alt="" src="../_images/sphx_glr_plot_skeleton_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_skeleton.html#sphx-glr-auto-examples-edges-plot-skeleton-py"><span class="std std-ref">Skeletonize</span></a></p>
  <div class="sphx-glr-thumbnail-title">Skeletonize</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In various image analysis situations, it is useful to think of the pixels of an image, or of a ..."><img alt="" src="../_images/sphx_glr_plot_pixel_graphs_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_pixel_graphs.html#sphx-glr-auto-examples-applications-plot-pixel-graphs-py"><span class="std std-ref">Use pixel graphs to find an object’s geodesic center</span></a></p>
  <div class="sphx-glr-thumbnail-title">Use pixel graphs to find an object's geodesic center</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><img alt="" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></p>
  <div class="sphx-glr-thumbnail-title">Morphological Filtering</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.square">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decomposition=None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/footprints.py#L98-L161"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.square" title="Link to this definition">#</a></dt>
<dd><p>Generates a flat, square-shaped footprint.</p>
<p>Every pixel along the perimeter has a chessboard distance
no greater than radius (radius=floor(width/2)) pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>The width and height of the square.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.
When <em class="xref py py-obj">decomposition</em> is None, this is just a numpy.ndarray. Otherwise,
this will be a tuple whose length is equal to the number of unique
structuring elements to apply (see Notes for more detail)</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
<dt><strong>decomposition</strong><span class="classifier">{None, ‘separable’, ‘sequence’}, optional</span></dt><dd><p>If None, a single array is returned. For ‘sequence’, a tuple of smaller
footprints is returned. Applying this series of smaller footprints will
give an identical result to a single, larger footprint, but often with
better computational performance. See Notes for more details.
With ‘separable’, this function uses separable 1D footprints for each
axis. Whether ‘sequence’ or ‘separable’ is computationally faster may
be architecture-dependent.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When <em class="xref py py-obj">decomposition</em> is not None, each element of the <em class="xref py py-obj">footprint</em>
tuple is a 2-tuple of the form <code class="docutils literal notranslate"><span class="pre">(ndarray,</span> <span class="pre">num_iter)</span></code> that specifies a
footprint array and the number of iterations it is to be applied.</p>
<p>For binary morphology, using <code class="docutils literal notranslate"><span class="pre">decomposition='sequence'</span></code> or
<code class="docutils literal notranslate"><span class="pre">decomposition='separable'</span></code> were observed to give better performance than
<code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code>, with the magnitude of the performance increase
rapidly increasing with footprint size. For grayscale morphology with
square footprints, it is recommended to use <code class="docutils literal notranslate"><span class="pre">decomposition=None</span></code> since
the internal SciPy functions that are called already have a fast
implementation based on separable 1D sliding windows.</p>
<p>The ‘sequence’ decomposition mode only supports odd valued <em class="xref py py-obj">width</em>. If
<em class="xref py py-obj">width</em> is even, the sequence used will be identical to the ‘separable’
mode.</p>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :pyskimage.morphology to generate footprints (struct..."><img alt="" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Generate footprints (structuring elements)</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Many footprints (structuring elements) can be decomposed into an equivalent series of smaller s..."><img alt="" src="../_images/sphx_glr_plot_footprint_decompositions_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_footprint_decompositions.html#sphx-glr-auto-examples-numpy-operations-plot-footprint-decompositions-py"><span class="std std-ref">Decompose flat footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Decompose flat footprints (structuring elements)</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Attribute operators (or connected operators) [1]_ is a family of contour preserving filtering o..."><img alt="" src="../_images/sphx_glr_plot_attribute_operators_thumb.png" />
<p><a class="reference internal" href="../auto_examples/filters/plot_attribute_operators.html#sphx-glr-auto-examples-filters-plot-attribute-operators-py"><span class="std std-ref">Attribute operators</span></a></p>
  <div class="sphx-glr-thumbnail-title">Attribute operators</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to segment an image with image labelling. The following steps are applie..."><img alt="" src="../_images/sphx_glr_plot_label_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_label.html#sphx-glr-auto-examples-segmentation-plot-label-py"><span class="std std-ref">Label image regions</span></a></p>
  <div class="sphx-glr-thumbnail-title">Label image regions</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.star">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">star</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/footprints.py#L919-L964"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.star" title="Link to this definition">#</a></dt>
<dd><p>Generates a star shaped footprint.</p>
<p>Start has 8 vertices and is an overlap of square of size <em class="xref py py-obj">2*a + 1</em>
with its 45 degree rotated version.
The slanted sides are 45 or 135 degrees to the horizontal axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">int</span></dt><dd><p>Parameter deciding the size of the star structural element. The side
of the square array returned is <em class="xref py py-obj">2*a + 1 + 2*floor(a / 2)</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>footprint</strong><span class="classifier">ndarray</span></dt><dd><p>The footprint where elements of the neighborhood are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type, optional</span></dt><dd><p>The data type of the footprint.</p>
</dd>
</dl>
</dd>
</dl>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :pyskimage.morphology to generate footprints (struct..."><img alt="" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate footprints (structuring elements)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Generate footprints (structuring elements)</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.thin">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">thin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/_skeletonize.py#L252-L348"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.thin" title="Link to this definition">#</a></dt>
<dd><p>Perform morphological thinning of a binary image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">binary (M, N) ndarray</span></dt><dd><p>The image to thin. If this input isn’t already a binary image,
it gets converted into one: In this case, zero values are considered
background (False), nonzero values are considered foreground (True).</p>
</dd>
<dt><strong>max_num_iter</strong><span class="classifier">int, number of iterations, optional</span></dt><dd><p>Regardless of the value of this parameter, the thinned image
is returned immediately if an iteration produces no change.
If this parameter is specified it thus sets an upper bound on
the number of iterations performed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of bool</span></dt><dd><p>Thinned image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skeletonize</span></code></a>, <a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">medial_axis</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This algorithm <a class="reference internal" href="#r2b353e29d473-1" id="id70">[1]</a> works by making multiple passes over the image,
removing pixels matching a set of criteria designed to thin
connected regions while preserving eight-connected components and
2 x 2 squares <a class="reference internal" href="#r2b353e29d473-2" id="id71">[2]</a>. In each of the two sub-iterations the algorithm
correlates the intermediate skeleton image with a neighborhood mask,
then looks up each neighborhood in a lookup table indicating whether
the central pixel should be deleted in that sub-iteration.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r2b353e29d473-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id70">1</a><span class="fn-bracket">]</span></span>
<p>Z. Guo and R. W. Hall, “Parallel thinning with
two-subiteration algorithms,” Comm. ACM, vol. 32, no. 3,
pp. 359-373, 1989. <a class="reference external" href="https://doi.org/10.1145/62065.62074">DOI:10.1145/62065.62074</a></p>
</div>
<div class="citation" id="r2b353e29d473-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id71">2</a><span class="fn-bracket">]</span></span>
<p>Lam, L., Seong-Whan Lee, and Ching Y. Suen, “Thinning
Methodologies-A Comprehensive Survey,” IEEE Transactions on
Pattern Analysis and Machine Intelligence, Vol 14, No. 9,
p. 879, 1992. <a class="reference external" href="https://doi.org/10.1109/34.161346">DOI:10.1109/34.161346</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 1, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span> <span class="o">=</span> <span class="n">thin</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 1, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Skeletonization reduces binary objects to 1 pixel wide representations. This can be useful for ..."><img alt="" src="../_images/sphx_glr_plot_skeleton_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_skeleton.html#sphx-glr-auto-examples-edges-plot-skeleton-py"><span class="std std-ref">Skeletonize</span></a></p>
  <div class="sphx-glr-thumbnail-title">Skeletonize</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.morphology.white_tophat">
<span class="sig-prename descclassname"><span class="pre">skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">white_tophat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/morphology/gray.py#L520-L610"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.morphology.white_tophat" title="Link to this definition">#</a></dt>
<dd><p>Return white top hat of an image.</p>
<p>The white top hat of an image is defined as the image minus its
morphological opening. This operation returns the bright spots of the image
that are smaller than the footprint.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray or tuple, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use a cross-shaped footprint (connectivity=1). The footprint
can also be provided as a sequence of smaller footprints as described
in the notes below.</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>The <em class="xref py py-obj">mode</em> parameter determines how the array borders are handled.
Valid modes are: ‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’,
‘max’, ‘min’, or ‘ignore’. See <a class="reference internal" href="#skimage.morphology.opening" title="skimage.morphology.opening"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.opening()</span></code></a>.
Default is ‘reflect’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <em class="xref py py-obj">mode</em> is ‘constant’. Default
is 0.0.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.23: </span><em class="xref py py-obj">mode</em> and <em class="xref py py-obj">cval</em> were added in 0.23.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">array, same shape and type as <em class="xref py py-obj">image</em></span></dt><dd><p>The result of the morphological white top hat.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.black_tophat" title="skimage.morphology.black_tophat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">black_tophat</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The footprint can also be a provided as a sequence of 2-tuples where the
first element of each 2-tuple is a footprint ndarray and the second element
is an integer describing the number of times it should be iterated. For
example <code class="docutils literal notranslate"><span class="pre">footprint=[(np.ones((9,</span> <span class="pre">1)),</span> <span class="pre">1),</span> <span class="pre">(np.ones((1,</span> <span class="pre">9)),</span> <span class="pre">1)]</span></code>
would apply a 9x1 footprint followed by a 1x9 footprint resulting in a net
effect that is the same as <code class="docutils literal notranslate"><span class="pre">footprint=np.ones((9,</span> <span class="pre">9))</span></code>, but with lower
computational cost. Most of the builtin footprints such as
<a class="reference internal" href="#skimage.morphology.disk" title="skimage.morphology.disk"><code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.morphology.disk()</span></code></a> provide an option to automatically generate
a footprint sequence of this type.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r9700090f0649-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Top-hat_transform">https://en.wikipedia.org/wiki/Top-hat_transform</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Subtract gray background from bright peak</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bright_on_gray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">white_tophat</span><span class="p">(</span><span class="n">bright_on_gray</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 1, 5, 1, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to remove small objects from grayscale images. The top-hat transform [1]..."><img alt="" src="../_images/sphx_glr_plot_tophat_thumb.png" />
<p><a class="reference internal" href="../auto_examples/filters/plot_tophat.html#sphx-glr-auto-examples-filters-plot-tophat-py"><span class="std std-ref">Removing small objects in grayscale images with a top hat filter</span></a></p>
  <div class="sphx-glr-thumbnail-title">Removing small objects in grayscale images with a top hat filter</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><img alt="" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></p>
  <div class="sphx-glr-thumbnail-title">Morphological Filtering</div>
</div></div></dd></dl>

</section>


                </article>
              
              
              
              
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.area_closing"><code class="docutils literal notranslate"><span class="pre">area_closing()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.area_opening"><code class="docutils literal notranslate"><span class="pre">area_opening()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.ball"><code class="docutils literal notranslate"><span class="pre">ball()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.binary_closing"><code class="docutils literal notranslate"><span class="pre">binary_closing()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.binary_dilation"><code class="docutils literal notranslate"><span class="pre">binary_dilation()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.binary_erosion"><code class="docutils literal notranslate"><span class="pre">binary_erosion()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.binary_opening"><code class="docutils literal notranslate"><span class="pre">binary_opening()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.black_tophat"><code class="docutils literal notranslate"><span class="pre">black_tophat()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.closing"><code class="docutils literal notranslate"><span class="pre">closing()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.convex_hull_image"><code class="docutils literal notranslate"><span class="pre">convex_hull_image()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.convex_hull_object"><code class="docutils literal notranslate"><span class="pre">convex_hull_object()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.cube"><code class="docutils literal notranslate"><span class="pre">cube()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.diameter_closing"><code class="docutils literal notranslate"><span class="pre">diameter_closing()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.diameter_opening"><code class="docutils literal notranslate"><span class="pre">diameter_opening()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.diamond"><code class="docutils literal notranslate"><span class="pre">diamond()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.dilation"><code class="docutils literal notranslate"><span class="pre">dilation()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.disk"><code class="docutils literal notranslate"><span class="pre">disk()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.ellipse"><code class="docutils literal notranslate"><span class="pre">ellipse()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.erosion"><code class="docutils literal notranslate"><span class="pre">erosion()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.flood"><code class="docutils literal notranslate"><span class="pre">flood()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.flood_fill"><code class="docutils literal notranslate"><span class="pre">flood_fill()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.footprint_from_sequence"><code class="docutils literal notranslate"><span class="pre">footprint_from_sequence()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.h_maxima"><code class="docutils literal notranslate"><span class="pre">h_maxima()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.h_minima"><code class="docutils literal notranslate"><span class="pre">h_minima()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.isotropic_closing"><code class="docutils literal notranslate"><span class="pre">isotropic_closing()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.isotropic_dilation"><code class="docutils literal notranslate"><span class="pre">isotropic_dilation()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.isotropic_erosion"><code class="docutils literal notranslate"><span class="pre">isotropic_erosion()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.isotropic_opening"><code class="docutils literal notranslate"><span class="pre">isotropic_opening()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.label"><code class="docutils literal notranslate"><span class="pre">label()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.local_maxima"><code class="docutils literal notranslate"><span class="pre">local_maxima()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.local_minima"><code class="docutils literal notranslate"><span class="pre">local_minima()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.max_tree"><code class="docutils literal notranslate"><span class="pre">max_tree()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.max_tree_local_maxima"><code class="docutils literal notranslate"><span class="pre">max_tree_local_maxima()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.medial_axis"><code class="docutils literal notranslate"><span class="pre">medial_axis()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.mirror_footprint"><code class="docutils literal notranslate"><span class="pre">mirror_footprint()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.octagon"><code class="docutils literal notranslate"><span class="pre">octagon()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.octahedron"><code class="docutils literal notranslate"><span class="pre">octahedron()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.opening"><code class="docutils literal notranslate"><span class="pre">opening()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.pad_footprint"><code class="docutils literal notranslate"><span class="pre">pad_footprint()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.reconstruction"><code class="docutils literal notranslate"><span class="pre">reconstruction()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.rectangle"><code class="docutils literal notranslate"><span class="pre">rectangle()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.remove_objects_by_distance"><code class="docutils literal notranslate"><span class="pre">remove_objects_by_distance()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.remove_small_holes"><code class="docutils literal notranslate"><span class="pre">remove_small_holes()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.remove_small_objects"><code class="docutils literal notranslate"><span class="pre">remove_small_objects()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.skeletonize"><code class="docutils literal notranslate"><span class="pre">skeletonize()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.square"><code class="docutils literal notranslate"><span class="pre">square()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.star"><code class="docutils literal notranslate"><span class="pre">star()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.thin"><code class="docutils literal notranslate"><span class="pre">thin()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.morphology.white_tophat"><code class="docutils literal notranslate"><span class="pre">white_tophat()</span></code></a></li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">

  <div class="tocsection sourcelink">
    <a href="../_sources/api/skimage.morphology.rst.txt">
      <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2013-2024, the scikit-image team.
      <br/>
    
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    <br/>
  </p>
</div>
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.4.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>