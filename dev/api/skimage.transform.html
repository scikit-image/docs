
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>skimage.transform &#8212; skimage 0.24.1rc0.dev0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=61a4c737" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=87e54e7c" />
    <link rel="stylesheet" type="text/css" href="../_static/theme_overrides.css?v=4340df76" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=a22486ce"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script data-domain="scikit-image.org" defer="defer" src="https://views.scientific-python.org/js/script.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'api/skimage.transform';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.15.4';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://scikit-image.org/docs/dev/_static/version_switcher.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = 'dev';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = true;
        </script>
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="skimage.util" href="skimage.util.html" />
    <link rel="prev" title="skimage.segmentation" href="skimage.segmentation.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">

  
     
  

<a class="navbar-brand logo" href="https://scikit-image.org">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="scikit-image's logo, showing a snake's head overlayed with green and orange"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="scikit-image's logo, showing a snake's head overlayed with green and orange"/>`);</script>
  
  
    <p class="title logo__title">scikit-image</p>
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../user_guide/index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../auto_examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="api.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../release_notes/index.html">
    Release notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../development/index.html">
    Development
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../about/index.html">
    About
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-2"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-2"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-2"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-2">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/scikit-image/scikit-image" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/scikit-image/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-box fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../user_guide/index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../auto_examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="api.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../release_notes/index.html">
    Release notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../development/index.html">
    Development
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../about/index.html">
    About
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-3"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-3"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-3"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-3">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/scikit-image/scikit-image" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/scikit-image/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-box fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="skimage.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.color.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.color</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.data.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.data</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.draw.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.draw</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.exposure.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.exposure</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.feature.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.feature</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.filters.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.filters</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.filters.rank.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.filters.rank</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.future.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.future</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.graph.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.graph</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.io.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.io</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.measure.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.measure</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.metrics.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.metrics</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.morphology.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.morphology</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.registration.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.registration</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.restoration.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.restoration</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.segmentation.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.segmentation</span></code></a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.transform</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.util.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.util</span></code></a></li>
</ul>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="api.html" class="nav-link">API reference</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><code...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="module-skimage.transform">
<span id="skimage-transform"></span><h1><a class="reference internal" href="#module-skimage.transform" title="skimage.transform"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.transform</span></code></a><a class="headerlink" href="#module-skimage.transform" title="Link to this heading">#</a></h1>
<p>This module includes tools to transform images and volumetric data.</p>
<ul class="simple">
<li><p>Geometric transformation:
These transforms change the shape or position of an image.
They are useful for tasks such as image registration,
alignment, and geometric correction.
Examples: <a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a>,
<a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a>,
<a class="reference internal" href="#skimage.transform.EuclideanTransform" title="skimage.transform.EuclideanTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">EuclideanTransform</span></code></a>.</p></li>
<li><p>Image resizing and rescaling:
These transforms change the size or resolution of an image.
They are useful for tasks such as down-sampling an image to
reduce its size or up-sampling an image to increase its resolution.
Examples: <a class="reference internal" href="#skimage.transform.resize" title="skimage.transform.resize"><code class="xref py py-func docutils literal notranslate"><span class="pre">resize()</span></code></a>,
<a class="reference internal" href="#skimage.transform.rescale" title="skimage.transform.rescale"><code class="xref py py-func docutils literal notranslate"><span class="pre">rescale()</span></code></a>.</p></li>
<li><p>Feature detection and extraction:
These transforms identify and extract specific features or
patterns in an image. They are useful for tasks such as object
detection, image segmentation, and  feature matching.
Examples: <a class="reference internal" href="#skimage.transform.hough_circle" title="skimage.transform.hough_circle"><code class="xref py py-func docutils literal notranslate"><span class="pre">hough_circle()</span></code></a>,
<a class="reference internal" href="#skimage.transform.pyramid_expand" title="skimage.transform.pyramid_expand"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyramid_expand()</span></code></a>,
<a class="reference internal" href="#skimage.transform.radon" title="skimage.transform.radon"><code class="xref py py-func docutils literal notranslate"><span class="pre">radon()</span></code></a>.</p></li>
<li><p>Image transformation:
These transforms change the appearance of an image without changing its
content. They are useful for tasks such a creating image mosaics,
applying artistic effects, and visualizing image data.
Examples: <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-func docutils literal notranslate"><span class="pre">warp()</span></code></a>,
<a class="reference internal" href="#skimage.transform.iradon" title="skimage.transform.iradon"><code class="xref py py-func docutils literal notranslate"><span class="pre">iradon()</span></code></a>.</p></li>
</ul>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.downscale_local_mean</span></code></a></p></td>
<td><p>Down-sample N-dimensional image by local averaging.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.estimate_transform" title="skimage.transform.estimate_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.estimate_transform</span></code></a></p></td>
<td><p>Estimate 2D geometric transformation parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.frt2</span></code></a></p></td>
<td><p>Compute the 2-dimensional finite Radon transform (FRT) for the input array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.hough_circle" title="skimage.transform.hough_circle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_circle</span></code></a></p></td>
<td><p>Perform a circular Hough transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.hough_circle_peaks" title="skimage.transform.hough_circle_peaks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_circle_peaks</span></code></a></p></td>
<td><p>Return peaks in a circle Hough transform.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.hough_ellipse" title="skimage.transform.hough_ellipse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_ellipse</span></code></a></p></td>
<td><p>Perform an elliptical Hough transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_line</span></code></a></p></td>
<td><p>Perform a straight line Hough transform.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.hough_line_peaks" title="skimage.transform.hough_line_peaks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_line_peaks</span></code></a></p></td>
<td><p>Return peaks in a straight line Hough transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.ifrt2</span></code></a></p></td>
<td><p>Compute the 2-dimensional inverse finite Radon transform (iFRT) for the input array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.integral_image" title="skimage.transform.integral_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.integral_image</span></code></a></p></td>
<td><p>Integral image / summed area table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.integrate" title="skimage.transform.integrate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.integrate</span></code></a></p></td>
<td><p>Use an integral image to integrate over a given window.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.iradon" title="skimage.transform.iradon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.iradon</span></code></a></p></td>
<td><p>Inverse radon transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.iradon_sart" title="skimage.transform.iradon_sart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.iradon_sart</span></code></a></p></td>
<td><p>Inverse radon transform.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.matrix_transform" title="skimage.transform.matrix_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.matrix_transform</span></code></a></p></td>
<td><p>Apply 2D matrix transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.order_angles_golden_ratio" title="skimage.transform.order_angles_golden_ratio"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.order_angles_golden_ratio</span></code></a></p></td>
<td><p>Order angles to reduce the amount of correlated information in subsequent projections.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.probabilistic_hough_line" title="skimage.transform.probabilistic_hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.probabilistic_hough_line</span></code></a></p></td>
<td><p>Return lines from a progressive probabilistic line Hough transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.pyramid_expand" title="skimage.transform.pyramid_expand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_expand</span></code></a></p></td>
<td><p>Upsample and then smooth image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.pyramid_gaussian" title="skimage.transform.pyramid_gaussian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_gaussian</span></code></a></p></td>
<td><p>Yield images of the Gaussian pyramid formed by the input image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.pyramid_laplacian" title="skimage.transform.pyramid_laplacian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_laplacian</span></code></a></p></td>
<td><p>Yield images of the laplacian pyramid formed by the input image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.pyramid_reduce" title="skimage.transform.pyramid_reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_reduce</span></code></a></p></td>
<td><p>Smooth and then downsample image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.radon" title="skimage.transform.radon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.radon</span></code></a></p></td>
<td><p>Calculates the radon transform of an image given specified projection angles.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.rescale" title="skimage.transform.rescale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.rescale</span></code></a></p></td>
<td><p>Scale image by a certain factor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.resize" title="skimage.transform.resize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.resize</span></code></a></p></td>
<td><p>Resize image to match a certain size.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.resize_local_mean" title="skimage.transform.resize_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.resize_local_mean</span></code></a></p></td>
<td><p>Resize an array with the local mean / bilinear scaling.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.rotate" title="skimage.transform.rotate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.rotate</span></code></a></p></td>
<td><p>Rotate image by a certain angle around its center.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.swirl" title="skimage.transform.swirl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.swirl</span></code></a></p></td>
<td><p>Perform a swirl transformation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a></p></td>
<td><p>Warp an image according to a given coordinate transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.warp_coords" title="skimage.transform.warp_coords"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp_coords</span></code></a></p></td>
<td><p>Build the source coordinates for the output of a 2-D image warp.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.warp_polar" title="skimage.transform.warp_polar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp_polar</span></code></a></p></td>
<td><p>Remap image to polar or log-polar coordinates space.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.AffineTransform</span></code></a></p></td>
<td><p>Affine transformation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.EssentialMatrixTransform" title="skimage.transform.EssentialMatrixTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.EssentialMatrixTransform</span></code></a></p></td>
<td><p>Essential matrix transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.EuclideanTransform" title="skimage.transform.EuclideanTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.EuclideanTransform</span></code></a></p></td>
<td><p>Euclidean transformation, also known as a rigid transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.FundamentalMatrixTransform" title="skimage.transform.FundamentalMatrixTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.FundamentalMatrixTransform</span></code></a></p></td>
<td><p>Fundamental matrix transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.PiecewiseAffineTransform" title="skimage.transform.PiecewiseAffineTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.PiecewiseAffineTransform</span></code></a></p></td>
<td><p>Piecewise affine transformation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.PolynomialTransform" title="skimage.transform.PolynomialTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.PolynomialTransform</span></code></a></p></td>
<td><p>2D polynomial transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.ProjectiveTransform</span></code></a></p></td>
<td><p>Projective transformation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.SimilarityTransform</span></code></a></p></td>
<td><p>Similarity transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.ThinPlateSplineTransform" title="skimage.transform.ThinPlateSplineTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.ThinPlateSplineTransform</span></code></a></p></td>
<td><p>Thin-plate spline transformation.</p></td>
</tr>
</tbody>
</table>
</div>
<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.downscale_local_mean">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">downscale_local_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L456-L500"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.downscale_local_mean" title="Link to this definition">#</a></dt>
<dd><p>Down-sample N-dimensional image by local averaging.</p>
<p>The image is padded with <em class="xref py py-obj">cval</em> if it is not perfectly divisible by the
integer factors.</p>
<p>In contrast to interpolation in <a class="reference internal" href="#skimage.transform.resize" title="skimage.transform.resize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.resize</span></code></a> and
<a class="reference internal" href="#skimage.transform.rescale" title="skimage.transform.rescale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.rescale</span></code></a> this function calculates the local mean of
elements in each block of size <em class="xref py py-obj">factors</em> in the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M[, …]) ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>factors</strong><span class="classifier">array_like</span></dt><dd><p>Array containing down-sampling integer factor along each axis.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Constant padding value if image is not perfectly divisible by the
integer factors.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Unused, but kept here for API consistency with the other transforms
in this module. (The local mean will never fall outside the range
of values in the input image, assuming the provided <em class="xref py py-obj">cval</em> also
falls within that range.)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Down-sampled image with same number of dimensions as input image.
For integer inputs, the output dtype will be <code class="docutils literal notranslate"><span class="pre">float64</span></code>.
See <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.mean.html#numpy.mean" title="(in NumPy v2.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.mean()</span></code></a> for details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3,  4],</span>
<span class="go">       [ 5,  6,  7,  8,  9],</span>
<span class="go">       [10, 11, 12, 13, 14]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">downscale_local_mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([[3.5, 4. ],</span>
<span class="go">       [5.5, 4.5]])</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Rescale operation resizes an image by a given scaling factor. The scaling factor can either be ..."><img alt="" src="../_images/sphx_glr_plot_rescale_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_rescale.html#sphx-glr-auto-examples-transform-plot-rescale-py"><span class="std std-ref">Rescale, resize, and downscale</span></a></p>
  <div class="sphx-glr-thumbnail-title">Rescale, resize, and downscale</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.estimate_transform">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">estimate_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ttype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1719-L1788"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.estimate_transform" title="Link to this definition">#</a></dt>
<dd><p>Estimate 2D geometric transformation parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ttype</strong><span class="classifier">{‘euclidean’, similarity’, ‘affine’, ‘piecewise-affine’,              ‘projective’, ‘polynomial’}</span></dt><dd><p>Type of transform.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">array_like or int</span></dt><dd><p>Function parameters (src, dst, n, angle):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>NAME / TTYPE        FUNCTION PARAMETERS
&#39;euclidean&#39;         `src, `dst`
&#39;similarity&#39;        `src, `dst`
&#39;affine&#39;            `src, `dst`
&#39;piecewise-affine&#39;  `src, `dst`
&#39;projective&#39;        `src, `dst`
&#39;polynomial&#39;        `src, `dst`, `order` (polynomial order,
                                          default order is 2)
</pre></div>
</div>
<p>Also see examples below.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>tform</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">_GeometricTransform</span></code></span></dt><dd><p>Transform object containing the transformation parameters and providing
access to forward and inverse transformation functions.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">skimage</span> <span class="k">as</span> <span class="nn">ski</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimate transformation parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">ski</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">estimate_transform</span><span class="p">(</span><span class="s1">&#39;similarity&#39;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">tform</span><span class="p">(</span><span class="n">src</span><span class="p">)),</span> <span class="n">src</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># warp image using the estimated transformation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">ski</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ski</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">inverse_map</span><span class="o">=</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span> 
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># create transformation with explicit parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform2</span> <span class="o">=</span> <span class="n">ski</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># unite transformations, applied in order from left to right</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform3</span> <span class="o">=</span> <span class="n">tform</span> <span class="o">+</span> <span class="n">tform2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">tform3</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">tform2</span><span class="p">(</span><span class="n">tform</span><span class="p">(</span><span class="n">src</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.frt2">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">frt2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/finite_radon_transform.py#L12-L67"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.frt2" title="Link to this definition">#</a></dt>
<dd><p>Compute the 2-dimensional finite Radon transform (FRT) for the input array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">ndarray of int, shape (M, M)</span></dt><dd><p>Input array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>FRT</strong><span class="classifier">ndarray of int, shape (M+1, M)</span></dt><dd><p>Finite Radon Transform array of coefficients.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifrt2</span></code></a></dt><dd><p>The two-dimensional inverse FRT.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The FRT has a unique inverse if and only if M is prime. [FRT]
The idea for this algorithm is due to Vlad Negnevitski.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rdb433381c1a5-frt" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>FRT<span class="fn-bracket">]</span></span>
<p>A. Kingston and I. Svalbe, “Projective transforms on periodic
discrete image arrays,” in P. Hawkes (Ed), Advances in Imaging
and Electron Physics, 139 (2006)</p>
</div>
</div>
<p class="rubric">Examples</p>
<p>Generate a test image:
Use a prime number for the array dimensions</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SIZE</span> <span class="o">=</span> <span class="mi">59</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Finite Radon Transform:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">frt2</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.hough_circle">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">hough_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/hough_transform.py#L81-L123"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.hough_circle" title="Link to this definition">#</a></dt>
<dd><p>Perform a circular Hough transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray, shape (M, N)</span></dt><dd><p>Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">scalar or sequence of scalars</span></dt><dd><p>Radii at which to compute the Hough transform.
Floats are converted to integers.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">boolean, optional</span></dt><dd><p>Normalize the accumulator with the number
of pixels used to draw the radius.</p>
</dd>
<dt><strong>full_output</strong><span class="classifier">boolean, optional</span></dt><dd><p>Extend the output size by twice the largest
radius in order to detect centers outside the
input picture.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>H</strong><span class="classifier">ndarray, shape (radius index, M + 2R, N + 2R)</span></dt><dd><p>Hough transform accumulator for each radius.
R designates the larger radius if full_output is True.
Otherwise, R = 0.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough_circle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">circle_perimeter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">circle_perimeter</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">try_radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">hough_circle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">try_radii</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ridx</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">res</span><span class="p">),</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">try_radii</span><span class="p">[</span><span class="n">ridx</span><span class="p">]</span>
<span class="go">(25, 35, 23)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a method to detect straight lines but it can also b..."><img alt="" src="../_images/sphx_glr_plot_circular_elliptical_hough_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_circular_elliptical_hough_transform.html#sphx-glr-auto-examples-edges-plot-circular-elliptical-hough-transform-py"><span class="std std-ref">Circular and Elliptical Hough Transforms</span></a></p>
  <div class="sphx-glr-thumbnail-title">Circular and Elliptical Hough Transforms</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.hough_circle_peaks">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">hough_circle_peaks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hspaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radii</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_xdistance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_ydistance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_num_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/hough_transform.py#L305-L423"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.hough_circle_peaks" title="Link to this definition">#</a></dt>
<dd><p>Return peaks in a circle Hough transform.</p>
<p>Identifies most prominent circles separated by certain distances in given
Hough spaces. Non-maximum suppression with different sizes is applied
separately in the first and second dimension of the Hough space to
identify peaks. For circles with different radius but close in distance,
only the one with highest peak is kept.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hspaces</strong><span class="classifier">(M, N, P) array</span></dt><dd><p>Hough spaces returned by the <a class="reference internal" href="#skimage.transform.hough_circle" title="skimage.transform.hough_circle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hough_circle</span></code></a> function.</p>
</dd>
<dt><strong>radii</strong><span class="classifier">(M,) array</span></dt><dd><p>Radii corresponding to Hough spaces.</p>
</dd>
<dt><strong>min_xdistance</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum distance separating centers in the x dimension.</p>
</dd>
<dt><strong>min_ydistance</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum distance separating centers in the y dimension.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Minimum intensity of peaks in each Hough space.
Default is <em class="xref py py-obj">0.5 * max(hspace)</em>.</p>
</dd>
<dt><strong>num_peaks</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of peaks in each Hough space. When the
number of peaks exceeds <em class="xref py py-obj">num_peaks</em>, only <em class="xref py py-obj">num_peaks</em>
coordinates based on peak intensity are considered for the
corresponding radius.</p>
</dd>
<dt><strong>total_num_peaks</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of peaks. When the number of peaks exceeds <em class="xref py py-obj">num_peaks</em>,
return <em class="xref py py-obj">num_peaks</em> coordinates based on peak intensity.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, normalize the accumulator by the radius to sort the prominent
peaks.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>accum, cx, cy, rad</strong><span class="classifier">tuple of array</span></dt><dd><p>Peak values in Hough space, x and y center coordinates and radii.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Circles with bigger radius have higher peaks in Hough space. If larger
circles are preferred over smaller ones, <em class="xref py py-obj">normalize</em> should be False.
Otherwise, circles will be returned in the order of decreasing voting
number.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">transform</span><span class="p">,</span> <span class="n">draw</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">120</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">radius</span><span class="p">,</span> <span class="n">x_0</span><span class="p">,</span> <span class="n">y_0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">draw</span><span class="o">.</span><span class="n">circle_perimeter</span><span class="p">(</span><span class="n">y_0</span><span class="p">,</span> <span class="n">x_0</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hspaces</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">hough_circle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">accum</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">rad</span> <span class="o">=</span> <span class="n">hough_circle_peaks</span><span class="p">(</span><span class="n">hspaces</span><span class="p">,</span> <span class="p">[</span><span class="n">radius</span><span class="p">,])</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a method to detect straight lines but it can also b..."><img alt="" src="../_images/sphx_glr_plot_circular_elliptical_hough_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_circular_elliptical_hough_transform.html#sphx-glr-auto-examples-edges-plot-circular-elliptical-hough-transform-py"><span class="std std-ref">Circular and Elliptical Hough Transforms</span></a></p>
  <div class="sphx-glr-thumbnail-title">Circular and Elliptical Hough Transforms</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.hough_ellipse">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">hough_ellipse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accuracy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/hough_transform.py#L126-L190"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.hough_ellipse" title="Link to this definition">#</a></dt>
<dd><p>Perform an elliptical Hough transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">int, optional</span></dt><dd><p>Accumulator threshold value. A lower value will return more ellipses.</p>
</dd>
<dt><strong>accuracy</strong><span class="classifier">double, optional</span></dt><dd><p>Bin size on the minor axis used in the accumulator. A higher value
will return more ellipses, but lead to a less precise estimation of
the minor axis lengths.</p>
</dd>
<dt><strong>min_size</strong><span class="classifier">int, optional</span></dt><dd><p>Minimal major axis length.</p>
</dd>
<dt><strong>max_size</strong><span class="classifier">int, optional</span></dt><dd><p>Maximal minor axis length.
If None, the value is set to half of the smaller
image dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">ndarray with fields [(accumulator, yc, xc, a, b, orientation)].</span></dt><dd><p>Where <code class="docutils literal notranslate"><span class="pre">(yc,</span> <span class="pre">xc)</span></code> is the center, <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code> the major and minor
axes, respectively. The <em class="xref py py-obj">orientation</em> value follows the
<a class="reference internal" href="skimage.draw.html#skimage.draw.ellipse_perimeter" title="skimage.draw.ellipse_perimeter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.draw.ellipse_perimeter</span></code></a> convention.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Potential ellipses in the image are characterized by their major and
minor axis lengths. For any pair of nonzero pixels in the image that
are at least half of <em class="xref py py-obj">min_size</em> apart, an accumulator keeps track of
the minor axis lengths of potential ellipses formed with all the
other nonzero pixels. If any bin (with <em class="xref py py-obj">bin_size = accuracy * accuracy</em>)
in the histogram of those accumulated minor axis lengths is above
<em class="xref py py-obj">threshold</em>, the corresponding ellipse is added to the results.</p>
<p>A higher <em class="xref py py-obj">accuracy</em> will therefore lead to more ellipses being found
in the image, at the cost of a less precise estimation of the minor
axis length.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rf2ef66e2ec1f-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Xie, Yonghong, and Qiang Ji. “A new efficient ellipse detection
method.” Pattern Recognition, 2002. Proceedings. 16th International
Conference on. Vol. 2. IEEE, 2002</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough_ellipse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">ellipse_perimeter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">ellipse_perimeter</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">cc</span><span class="p">,</span> <span class="n">rr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">hough_ellipse</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[(10, 10.0, 10.0, 8.0, 6.0, 0.0)]</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a method to detect straight lines but it can also b..."><img alt="" src="../_images/sphx_glr_plot_circular_elliptical_hough_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_circular_elliptical_hough_transform.html#sphx-glr-auto-examples-edges-plot-circular-elliptical-hough-transform-py"><span class="std std-ref">Circular and Elliptical Hough Transforms</span></a></p>
  <div class="sphx-glr-thumbnail-title">Circular and Elliptical Hough Transforms</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.hough_line">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">hough_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/hough_transform.py#L193-L247"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.hough_line" title="Link to this definition">#</a></dt>
<dd><p>Perform a straight line Hough transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">ndarray of double, shape (K,), optional</span></dt><dd><p>Angles at which to compute the transform, in radians.
Defaults to a vector of 180 angles evenly spaced in the
range [-pi/2, pi/2).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>hspace</strong><span class="classifier">ndarray of uint64, shape (P, Q)</span></dt><dd><p>Hough transform accumulator.</p>
</dd>
<dt><strong>angles</strong><span class="classifier">ndarray</span></dt><dd><p>Angles at which the transform is computed, in radians.</p>
</dd>
<dt><strong>distances</strong><span class="classifier">ndarray</span></dt><dd><p>Distance values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The origin is the top left corner of the original image.
X and Y axis are horizontal and vertical edges respectively.
The distance is the minimal algebraic distance from the origin
to the detected line.
The angle accuracy can be improved by decreasing the step size in
the <em class="xref py py-obj">theta</em> array.</p>
<p class="rubric">Examples</p>
<p>Generate a test image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[:,</span> <span class="mi">65</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">45</span><span class="p">,</span> <span class="mi">35</span><span class="p">:</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">90</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.95</span>
</pre></div>
</div>
<p>Apply the Hough transform:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">hough_line</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a method to detect straight lines [1]_."><img alt="" src="../_images/sphx_glr_plot_line_hough_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_line_hough_transform.html#sphx-glr-auto-examples-edges-plot-line-hough-transform-py"><span class="std std-ref">Straight line Hough transform</span></a></p>
  <div class="sphx-glr-thumbnail-title">Straight line Hough transform</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.hough_line_peaks">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">hough_line_peaks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hspace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dists</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/hough_transform.py#L8-L78"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.hough_line_peaks" title="Link to this definition">#</a></dt>
<dd><p>Return peaks in a straight line Hough transform.</p>
<p>Identifies most prominent lines separated by a certain angle and distance
in a Hough transform. Non-maximum suppression with different sizes is
applied separately in the first (distances) and second (angles) dimension
of the Hough space to identify peaks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hspace</strong><span class="classifier">ndarray, shape (M, N)</span></dt><dd><p>Hough space returned by the <a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hough_line</span></code></a> function.</p>
</dd>
<dt><strong>angles</strong><span class="classifier">array, shape (N,)</span></dt><dd><p>Angles returned by the <a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hough_line</span></code></a> function. Assumed to be continuous.
(<em class="xref py py-obj">angles[-1] - angles[0] == PI</em>).</p>
</dd>
<dt><strong>dists</strong><span class="classifier">array, shape (M,)</span></dt><dd><p>Distances returned by the <a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hough_line</span></code></a> function.</p>
</dd>
<dt><strong>min_distance</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum distance separating lines (maximum filter size for first
dimension of hough space).</p>
</dd>
<dt><strong>min_angle</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum angle separating lines (maximum filter size for second
dimension of hough space).</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Minimum intensity of peaks. Default is <em class="xref py py-obj">0.5 * max(hspace)</em>.</p>
</dd>
<dt><strong>num_peaks</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of peaks. When the number of peaks exceeds <em class="xref py py-obj">num_peaks</em>,
return <em class="xref py py-obj">num_peaks</em> coordinates based on peak intensity.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>accum, angles, dists</strong><span class="classifier">tuple of array</span></dt><dd><p>Peak values in Hough space, angles and distances.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough_line</span><span class="p">,</span> <span class="n">hough_line_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">line</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">line</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">line</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">cc</span><span class="p">,</span> <span class="n">rr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hspace</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dists</span> <span class="o">=</span> <span class="n">hough_line</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hspace</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dists</span> <span class="o">=</span> <span class="n">hough_line_peaks</span><span class="p">(</span><span class="n">hspace</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a method to detect straight lines [1]_."><img alt="" src="../_images/sphx_glr_plot_line_hough_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_line_hough_transform.html#sphx-glr-auto-examples-edges-plot-line-hough-transform-py"><span class="std std-ref">Straight line Hough transform</span></a></p>
  <div class="sphx-glr-thumbnail-title">Straight line Hough transform</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.ifrt2">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">ifrt2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/finite_radon_transform.py#L70-L132"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.ifrt2" title="Link to this definition">#</a></dt>
<dd><p>Compute the 2-dimensional inverse finite Radon transform (iFRT) for the input array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">ndarray of int, shape (M+1, M)</span></dt><dd><p>Input array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>iFRT</strong><span class="classifier">ndarray of int, shape (M, M)</span></dt><dd><p>Inverse Finite Radon Transform coefficients.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frt2</span></code></a></dt><dd><p>The two-dimensional FRT</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The FRT has a unique inverse if and only if M is prime.
See <a class="reference internal" href="#r3b76f892cb20-1" id="id3">[1]</a> for an overview.
The idea for this algorithm is due to Vlad Negnevitski.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r3b76f892cb20-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">1</a><span class="fn-bracket">]</span></span>
<p>A. Kingston and I. Svalbe, “Projective transforms on periodic
discrete image arrays,” in P. Hawkes (Ed), Advances in Imaging
and Electron Physics, 139 (2006)</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SIZE</span> <span class="o">=</span> <span class="mi">59</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Finite Radon Transform:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">frt2</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Inverse Finite Radon Transform to recover the input</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fi</span> <span class="o">=</span> <span class="n">ifrt2</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Check that it’s identical to the original</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">img</span><span class="o">-</span><span class="n">fi</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.integral_image">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">integral_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/integral.py#L4-L45"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.integral_image" title="Link to this definition">#</a></dt>
<dd><p>Integral image / summed area table.</p>
<p>The integral image contains the sum of all elements above and to the
left of it, i.e.:</p>
<div class="math notranslate nohighlight">
\[S[m, n] = \sum_{i \leq m} \sum_{j \leq n} X[i, j]\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">ndarray</span></dt><dd><p>Integral image/summed area table of same shape as input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For better accuracy and to avoid potential overflow, the data type of the
output may differ from the input’s when the default dtype of None is used.
For inputs with integer dtype, the behavior matches that for
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.cumsum.html#numpy.cumsum" title="(in NumPy v2.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.cumsum()</span></code></a>. Floating point inputs will be promoted to at least
double precision. The user can set <em class="xref py py-obj">dtype</em> to override this behavior.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rd91ebd979f08-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>F.C. Crow, “Summed-area tables for texture mapping,”
ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.</p>
</div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to compute multi-block local binary pattern (MB-LBP) features as well as..."><img alt="" src="../_images/sphx_glr_plot_multiblock_local_binary_pattern_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_multiblock_local_binary_pattern.html#sphx-glr-auto-examples-features-detection-plot-multiblock-local-binary-pattern-py"><span class="std std-ref">Multi-Block Local Binary Pattern for texture classification</span></a></p>
  <div class="sphx-glr-thumbnail-title">Multi-Block Local Binary Pattern for texture classification</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Haar-like feature descriptors were successfully used to implement the first real-time face dete..."><img alt="" src="../_images/sphx_glr_plot_haar_extraction_selection_classification_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_haar_extraction_selection_classification.html#sphx-glr-auto-examples-applications-plot-haar-extraction-selection-classification-py"><span class="std std-ref">Face classification using Haar-like feature descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">Face classification using Haar-like feature descriptor</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.integrate">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">integrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ii</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/integral.py#L48-L145"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.integrate" title="Link to this definition">#</a></dt>
<dd><p>Use an integral image to integrate over a given window.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ii</strong><span class="classifier">ndarray</span></dt><dd><p>Integral image.</p>
</dd>
<dt><strong>start</strong><span class="classifier">List of tuples, each tuple of length equal to dimension of <em class="xref py py-obj">ii</em></span></dt><dd><p>Coordinates of top left corner of window(s).
Each tuple in the list contains the starting row, col, … index
i.e <em class="xref py py-obj">[(row_win1, col_win1, …), (row_win2, col_win2,…), …]</em>.</p>
</dd>
<dt><strong>end</strong><span class="classifier">List of tuples, each tuple of length equal to dimension of <em class="xref py py-obj">ii</em></span></dt><dd><p>Coordinates of bottom right corner of window(s).
Each tuple in the list containing the end row, col, … index i.e
<em class="xref py py-obj">[(row_win1, col_win1, …), (row_win2, col_win2, …), …]</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">scalar or ndarray</span></dt><dd><p>Integral (sum) over the given window(s).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.transform.integral_image" title="skimage.transform.integral_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">integral_image</span></code></a></dt><dd><p>Create an integral image / summed area table.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii</span> <span class="o">=</span> <span class="n">integral_image</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># sum from (1, 0) to (1, 2)</span>
<span class="go">array([3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>  <span class="c1"># sum from (3, 3) to (4, 5)</span>
<span class="go">array([6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># sum from (1, 0) to (1, 2) and from (3, 3) to (4, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>
<span class="go">array([3., 6.])</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.iradon">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">iradon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radon_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ramp'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/radon_transform.py#L187-L323"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.iradon" title="Link to this definition">#</a></dt>
<dd><p>Inverse radon transform.</p>
<p>Reconstruct an image from the radon transform, using the filtered
back projection algorithm.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radon_image</strong><span class="classifier">ndarray</span></dt><dd><p>Image containing radon transform (sinogram). Each column of
the image corresponds to a projection along a different
angle. The tomography rotation axis should lie at the pixel
index <code class="docutils literal notranslate"><span class="pre">radon_image.shape[0]</span> <span class="pre">//</span> <span class="pre">2</span></code> along the 0th dimension of
<code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array, optional</span></dt><dd><p>Reconstruction angles (in degrees). Default: m angles evenly spaced
between 0 and 180 (if the shape of <em class="xref py py-obj">radon_image</em> is (N, M)).</p>
</dd>
<dt><strong>output_size</strong><span class="classifier">int, optional</span></dt><dd><p>Number of rows and columns in the reconstruction.</p>
</dd>
<dt><strong>filter_name</strong><span class="classifier">str, optional</span></dt><dd><p>Filter used in frequency domain filtering. Ramp filter used by default.
Filters available: ramp, shepp-logan, cosine, hamming, hann.
Assign None to use no filter.</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">str, optional</span></dt><dd><p>Interpolation method used in reconstruction. Methods available:
‘linear’, ‘nearest’, and ‘cubic’ (‘cubic’ is slow).</p>
</dd>
<dt><strong>circle</strong><span class="classifier">boolean, optional</span></dt><dd><p>Assume the reconstructed image is zero outside the inscribed circle.
Also changes the default output_size to match the behaviour of
<code class="docutils literal notranslate"><span class="pre">radon</span></code> called with <code class="docutils literal notranslate"><span class="pre">circle=True</span></code>.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reconstructed</strong><span class="classifier">ndarray</span></dt><dd><p>Reconstructed image. The rotation axis will be located in the pixel
with indices
<code class="docutils literal notranslate"><span class="pre">(reconstructed.shape[0]</span> <span class="pre">//</span> <span class="pre">2,</span> <span class="pre">reconstructed.shape[1]</span> <span class="pre">//</span> <span class="pre">2)</span></code>.</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.19: </span>In <code class="docutils literal notranslate"><span class="pre">iradon</span></code>, <code class="docutils literal notranslate"><span class="pre">filter</span></code> argument is deprecated in favor of
<code class="docutils literal notranslate"><span class="pre">filter_name</span></code>.</p>
</div>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>It applies the Fourier slice theorem to reconstruct an image by
multiplying the frequency domain of the filter with the FFT of the
projection data. This algorithm is called filtered back projection.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r19c92af887b5-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>AC Kak, M Slaney, “Principles of Computerized Tomographic
Imaging”, IEEE Press 1988.</p>
</div>
<div class="citation" id="r19c92af887b5-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>B.R. Ramesh, N. Srinivasa, K. Rajgopal, “An Algorithm for Computing
the Discrete Radon Transform With Some Applications”, Proceedings of
the Fourth IEEE Region 10 International Conference, TENCON ‘89, 1989</p>
</div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In computed tomography, the tomography reconstruction problem is to obtain a tomographic slice ..."><img alt="" src="../_images/sphx_glr_plot_radon_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_radon_transform.html#sphx-glr-auto-examples-transform-plot-radon-transform-py"><span class="std std-ref">Radon transform</span></a></p>
  <div class="sphx-glr-thumbnail-title">Radon transform</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.iradon_sart">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">iradon_sart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radon_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection_shifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/radon_transform.py#L385-L536"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.iradon_sart" title="Link to this definition">#</a></dt>
<dd><p>Inverse radon transform.</p>
<p>Reconstruct an image from the radon transform, using a single iteration of
the Simultaneous Algebraic Reconstruction Technique (SART) algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radon_image</strong><span class="classifier">ndarray, shape (M, N)</span></dt><dd><p>Image containing radon transform (sinogram). Each column of
the image corresponds to a projection along a different angle. The
tomography rotation axis should lie at the pixel index
<code class="docutils literal notranslate"><span class="pre">radon_image.shape[0]</span> <span class="pre">//</span> <span class="pre">2</span></code> along the 0th dimension of
<code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array, shape (N,), optional</span></dt><dd><p>Reconstruction angles (in degrees). Default: m angles evenly spaced
between 0 and 180 (if the shape of <em class="xref py py-obj">radon_image</em> is (N, M)).</p>
</dd>
<dt><strong>image</strong><span class="classifier">ndarray, shape (M, M), optional</span></dt><dd><p>Image containing an initial reconstruction estimate. Default is an array of zeros.</p>
</dd>
<dt><strong>projection_shifts</strong><span class="classifier">array, shape (N,), optional</span></dt><dd><p>Shift the projections contained in <code class="docutils literal notranslate"><span class="pre">radon_image</span></code> (the sinogram) by
this many pixels before reconstructing the image. The i’th value
defines the shift of the i’th column of <code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">length-2 sequence of floats, optional</span></dt><dd><p>Force all values in the reconstructed tomogram to lie in the range
<code class="docutils literal notranslate"><span class="pre">[clip[0],</span> <span class="pre">clip[1]]</span></code></p>
</dd>
<dt><strong>relaxation</strong><span class="classifier">float, optional</span></dt><dd><p>Relaxation parameter for the update step. A higher value can
improve the convergence rate, but one runs the risk of instabilities.
Values close to or higher than 1 are not recommended.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>Output data type, must be floating point. By default, if input
data type is not float, input is cast to double, otherwise
dtype is set to input data type.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reconstructed</strong><span class="classifier">ndarray</span></dt><dd><p>Reconstructed image. The rotation axis will be located in the pixel
with indices
<code class="docutils literal notranslate"><span class="pre">(reconstructed.shape[0]</span> <span class="pre">//</span> <span class="pre">2,</span> <span class="pre">reconstructed.shape[1]</span> <span class="pre">//</span> <span class="pre">2)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Algebraic Reconstruction Techniques are based on formulating the tomography
reconstruction problem as a set of linear equations. Along each ray,
the projected value is the sum of all the values of the cross section along
the ray. A typical feature of SART (and a few other variants of algebraic
techniques) is that it samples the cross section at equidistant points
along the ray, using linear interpolation between the pixel values of the
cross section. The resulting set of linear equations are then solved using
a slightly modified Kaczmarz method.</p>
<p>When using SART, a single iteration is usually sufficient to obtain a good
reconstruction. Further iterations will tend to enhance high-frequency
information, but will also often increase the noise.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r5a4015ea6a92-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>AC Kak, M Slaney, “Principles of Computerized Tomographic
Imaging”, IEEE Press 1988.</p>
</div>
<div class="citation" id="r5a4015ea6a92-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>AH Andersen, AC Kak, “Simultaneous algebraic reconstruction
technique (SART): a superior implementation of the ART algorithm”,
Ultrasonic Imaging 6 pp 81–94 (1984)</p>
</div>
<div class="citation" id="r5a4015ea6a92-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>S Kaczmarz, “Angenäherte auflösung von systemen linearer
gleichungen”, Bulletin International de l’Academie Polonaise des
Sciences et des Lettres 35 pp 355–357 (1937)</p>
</div>
<div class="citation" id="r5a4015ea6a92-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p>Kohler, T. “A projection access scheme for iterative
reconstruction based on the golden section.” Nuclear Science
Symposium Conference Record, 2004 IEEE. Vol. 6. IEEE, 2004.</p>
</div>
<div class="citation" id="r5a4015ea6a92-5" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>Kaczmarz’ method, Wikipedia,
<a class="reference external" href="https://en.wikipedia.org/wiki/Kaczmarz_method">https://en.wikipedia.org/wiki/Kaczmarz_method</a></p>
</div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In computed tomography, the tomography reconstruction problem is to obtain a tomographic slice ..."><img alt="" src="../_images/sphx_glr_plot_radon_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_radon_transform.html#sphx-glr-auto-examples-transform-plot-radon-transform-py"><span class="std std-ref">Radon transform</span></a></p>
  <div class="sphx-glr-thumbnail-title">Radon transform</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.matrix_transform">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">matrix_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1791-L1807"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.matrix_transform" title="Link to this definition">#</a></dt>
<dd><p>Apply 2D matrix transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>x, y coordinates to transform</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">(3, 3) array_like</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Transformed coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.order_angles_golden_ratio">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">order_angles_golden_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/radon_transform.py#L326-L382"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.order_angles_golden_ratio" title="Link to this definition">#</a></dt>
<dd><p>Order angles to reduce the amount of correlated information in
subsequent projections.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">array of floats, shape (M,)</span></dt><dd><p>Projection angles in degrees. Duplicate angles are not allowed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>indices_generator</strong><span class="classifier">generator yielding unsigned integers</span></dt><dd><p>The returned generator yields indices into <code class="docutils literal notranslate"><span class="pre">theta</span></code> such that
<code class="docutils literal notranslate"><span class="pre">theta[indices]</span></code> gives the approximate golden ratio ordering
of the projections. In total, <code class="docutils literal notranslate"><span class="pre">len(theta)</span></code> indices are yielded.
All non-negative integers &lt; <code class="docutils literal notranslate"><span class="pre">len(theta)</span></code> are yielded exactly once.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The method used here is that of the golden ratio introduced
by T. Kohler.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r88d6c0557044-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Kohler, T. “A projection access scheme for iterative
reconstruction based on the golden section.” Nuclear Science
Symposium Conference Record, 2004 IEEE. Vol. 6. IEEE, 2004.</p>
</div>
<div class="citation" id="r88d6c0557044-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Winkelmann, Stefanie, et al. “An optimal radial profile order
based on the Golden Ratio for time-resolved MRI.”
Medical Imaging, IEEE Transactions on 26.1 (2007): 68-76.</p>
</div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.probabilistic_hough_line">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">probabilistic_hough_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line_gap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/hough_transform.py#L250-L302"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.probabilistic_hough_line" title="Link to this definition">#</a></dt>
<dd><p>Return lines from a progressive probabilistic line Hough transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray, shape (M, N)</span></dt><dd><p>Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">int, optional</span></dt><dd><p>Threshold</p>
</dd>
<dt><strong>line_length</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum accepted length of detected lines.
Increase the parameter to extract longer lines.</p>
</dd>
<dt><strong>line_gap</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum gap between pixels to still form a line.
Increase the parameter to merge broken lines more aggressively.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">ndarray of dtype, shape (K,), optional</span></dt><dd><p>Angles at which to compute the transform, in radians.
Defaults to a vector of 180 angles evenly spaced in the
range [-pi/2, pi/2).</p>
</dd>
<dt><strong>rng</strong><span class="classifier">{<a class="reference external" href="https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.Generator" title="(in NumPy v2.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.Generator</span></code></a>, int}, optional</span></dt><dd><p>Pseudo-random number generator.
By default, a PCG64 generator is used (see <a class="reference external" href="https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.default_rng" title="(in NumPy v2.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.random.default_rng()</span></code></a>).
If <em class="xref py py-obj">rng</em> is an int, it is used to seed the generator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lines</strong><span class="classifier">list</span></dt><dd><p>List of lines identified, lines in format ((x0, y0), (x1, y1)),
indicating line start and end.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rd9a46cdb16bc-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>C. Galamhos, J. Matas and J. Kittler, “Progressive probabilistic
Hough transform for line detection”, in IEEE Computer Society
Conference on Computer Vision and Pattern Recognition, 1999.</p>
</div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a method to detect straight lines [1]_."><img alt="" src="../_images/sphx_glr_plot_line_hough_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_line_hough_transform.html#sphx-glr-auto-examples-edges-plot-line-hough-transform-py"><span class="std std-ref">Straight line Hough transform</span></a></p>
  <div class="sphx-glr-thumbnail-title">Straight line Hough transform</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.pyramid_expand">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/pyramids.py#L114-L187"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.pyramid_expand" title="Link to this definition">#</a></dt>
<dd><p>Upsample and then smooth image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>upscale</strong><span class="classifier">float, optional</span></dt><dd><p>Upscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <em class="xref py py-obj">2 * upscale / 6.0</em> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of upsampling. See
<a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>Upsampled and smoothed float image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r53df52222c6d-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.pyramid_gaussian">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/pyramids.py#L190-L289"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.pyramid_gaussian" title="Link to this definition">#</a></dt>
<dd><p>Yield images of the Gaussian pyramid formed by the input image.</p>
<p>Recursively applies the <a class="reference internal" href="#skimage.transform.pyramid_reduce" title="skimage.transform.pyramid_reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyramid_reduce</span></code></a> function to the image, and yields
the downscaled images.</p>
<p>Note that the first image of the pyramid will be the original, unscaled
image. The total number of images is <em class="xref py py-obj">max_layer + 1</em>. In case all layers
are computed, the last image is either a one-pixel image or the image where
the reduction does not change its shape.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>max_layer</strong><span class="classifier">int, optional</span></dt><dd><p>Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</dd>
<dt><strong>downscale</strong><span class="classifier">float, optional</span></dt><dd><p>Downscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <em class="xref py py-obj">2 * downscale / 6.0</em> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of downsampling. See
<a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pyramid</strong><span class="classifier">generator</span></dt><dd><p>Generator yielding pyramid layers as float images.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r4f1da659b730-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The pyramid_gaussian function takes an image and yields successive images shrunk by a constant ..."><img alt="" src="../_images/sphx_glr_plot_pyramid_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_pyramid.html#sphx-glr-auto-examples-transform-plot-pyramid-py"><span class="std std-ref">Build image pyramids</span></a></p>
  <div class="sphx-glr-thumbnail-title">Build image pyramids</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.pyramid_laplacian">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_laplacian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/pyramids.py#L292-L408"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.pyramid_laplacian" title="Link to this definition">#</a></dt>
<dd><p>Yield images of the laplacian pyramid formed by the input image.</p>
<p>Each layer contains the difference between the downsampled and the
downsampled, smoothed image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">layer</span> <span class="o">=</span> <span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">)</span> <span class="o">-</span> <span class="n">smooth</span><span class="p">(</span><span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that the first image of the pyramid will be the difference between the
original, unscaled image and its smoothed version. The total number of
images is <em class="xref py py-obj">max_layer + 1</em>. In case all layers are computed, the last image
is either a one-pixel image or the image where the reduction does not
change its shape.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>max_layer</strong><span class="classifier">int, optional</span></dt><dd><p>Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</dd>
<dt><strong>downscale</strong><span class="classifier">float, optional</span></dt><dd><p>Downscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <em class="xref py py-obj">2 * downscale / 6.0</em> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of downsampling. See
<a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pyramid</strong><span class="classifier">generator</span></dt><dd><p>Generator yielding pyramid layers as float images.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r64565393f7ed-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</div>
<div class="citation" id="r64565393f7ed-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://sepwww.stanford.edu/data/media/public/sep/morgan/texturematch/paper_html/node3.html">http://sepwww.stanford.edu/data/media/public/sep/morgan/texturematch/paper_html/node3.html</a></p>
</div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.pyramid_reduce">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/pyramids.py#L37-L111"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.pyramid_reduce" title="Link to this definition">#</a></dt>
<dd><p>Smooth and then downsample image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>downscale</strong><span class="classifier">float, optional</span></dt><dd><p>Downscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <em class="xref py py-obj">2 * downscale / 6.0</em> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of downsampling. See
<a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>Smoothed and downsampled float image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r4f51c9e42c4a-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.radon">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">radon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/radon_transform.py#L16-L114"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.radon" title="Link to this definition">#</a></dt>
<dd><p>Calculates the radon transform of an image given specified
projection angles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image. The rotation axis will be located in the pixel with
indices <code class="docutils literal notranslate"><span class="pre">(image.shape[0]</span> <span class="pre">//</span> <span class="pre">2,</span> <span class="pre">image.shape[1]</span> <span class="pre">//</span> <span class="pre">2)</span></code>.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array, optional</span></dt><dd><p>Projection angles (in degrees). If <em class="xref py py-obj">None</em>, the value is set to
np.arange(180).</p>
</dd>
<dt><strong>circle</strong><span class="classifier">boolean, optional</span></dt><dd><p>Assume image is zero outside the inscribed circle, making the
width of each projection (the first dimension of the sinogram)
equal to <code class="docutils literal notranslate"><span class="pre">min(image.shape)</span></code>.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>radon_image</strong><span class="classifier">ndarray</span></dt><dd><p>Radon transform (sinogram).  The tomography rotation axis will lie
at the pixel index <code class="docutils literal notranslate"><span class="pre">radon_image.shape[0]</span> <span class="pre">//</span> <span class="pre">2</span></code> along the 0th
dimension of <code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Based on code of Justin K. Romberg
(<a class="reference external" href="https://www.clear.rice.edu/elec431/projects96/DSP/bpanalysis.html">https://www.clear.rice.edu/elec431/projects96/DSP/bpanalysis.html</a>)</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r0eb755fc1fae-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>AC Kak, M Slaney, “Principles of Computerized Tomographic
Imaging”, IEEE Press 1988.</p>
</div>
<div class="citation" id="r0eb755fc1fae-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>B.R. Ramesh, N. Srinivasa, K. Rajgopal, “An Algorithm for Computing
the Discrete Radon Transform With Some Applications”, Proceedings of
the Fourth IEEE Region 10 International Conference, TENCON ‘89, 1989</p>
</div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In computed tomography, the tomography reconstruction problem is to obtain a tomographic slice ..."><img alt="" src="../_images/sphx_glr_plot_radon_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_radon_transform.html#sphx-glr-auto-examples-transform-plot-radon-transform-py"><span class="std std-ref">Radon transform</span></a></p>
  <div class="sphx-glr-thumbnail-title">Radon transform</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.rescale">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">rescale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L212-L327"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.rescale" title="Link to this definition">#</a></dt>
<dd><p>Scale image by a certain factor.</p>
<p>Performs interpolation to up-scale or down-scale N-dimensional images.
Note that anti-aliasing should be enabled when down-sizing images to avoid
aliasing artifacts. For down-sampling with an integer factor also see
<a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.downscale_local_mean</span></code></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N[, …][, C]) ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">{float, tuple of floats}</span></dt><dd><p>Scale factors for spatial dimensions. Separate scale factors can be defined as
(m, n[, …]).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scaled</strong><span class="classifier">ndarray</span></dt><dd><p>Scaled version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v2.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>anti_aliasing</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to apply a Gaussian filter to smooth the image prior
to down-scaling. It is crucial to filter when down-sampling
the image to avoid aliasing artifacts. If input image data
type is bool, no anti-aliasing is applied.</p>
</dd>
<dt><strong>anti_aliasing_sigma</strong><span class="classifier">{float, tuple of floats}, optional</span></dt><dd><p>Standard deviation for Gaussian filtering to avoid aliasing artifacts.
By default, this value is chosen as (s - 1) / 2 where s is the
down-scaling factor.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">rescale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(51, 51)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(256, 256)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example illustrates the different edge modes available during interpolation in routines su..."><img alt="" src="../_images/sphx_glr_plot_edge_modes_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_edge_modes.html#sphx-glr-auto-examples-transform-plot-edge-modes-py"><span class="std std-ref">Interpolation: Edge Modes</span></a></p>
  <div class="sphx-glr-thumbnail-title">Interpolation: Edge Modes</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Rescale operation resizes an image by a given scaling factor. The scaling factor can either be ..."><img alt="" src="../_images/sphx_glr_plot_rescale_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_rescale.html#sphx-glr-auto-examples-transform-plot-rescale-py"><span class="std std-ref">Rescale, resize, and downscale</span></a></p>
  <div class="sphx-glr-thumbnail-title">Rescale, resize, and downscale</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In computed tomography, the tomography reconstruction problem is to obtain a tomographic slice ..."><img alt="" src="../_images/sphx_glr_plot_radon_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_radon_transform.html#sphx-glr-auto-examples-transform-plot-radon-transform-py"><span class="std std-ref">Radon transform</span></a></p>
  <div class="sphx-glr-thumbnail-title">Radon transform</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Phase correlation (``registration.phase_cross_correlation``) is an efficient method for determi..."><img alt="" src="../_images/sphx_glr_plot_register_rotation_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_register_rotation.html#sphx-glr-auto-examples-registration-plot-register-rotation-py"><span class="std std-ref">Using Polar and Log-Polar Transformations for Registration</span></a></p>
  <div class="sphx-glr-thumbnail-title">Using Polar and Log-Polar Transformations for Registration</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.resize">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">resize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L71-L209"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.resize" title="Link to this definition">#</a></dt>
<dd><p>Resize image to match a certain size.</p>
<p>Performs interpolation to up-size or down-size N-dimensional images. Note
that anti-aliasing should be enabled when down-sizing images to avoid
aliasing artifacts. For downsampling with an integer factor also see
<a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.downscale_local_mean</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">iterable</span></dt><dd><p>Size of the generated output image <em class="xref py py-obj">(rows, cols[, …][, dim])</em>. If
<em class="xref py py-obj">dim</em> is not provided, the number of channels is preserved. In case the
number of input channels does not equal the number of output channels a
n-dimensional interpolation is applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>resized</strong><span class="classifier">ndarray</span></dt><dd><p>Resized version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v2.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>anti_aliasing</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to apply a Gaussian filter to smooth the image prior
to downsampling. It is crucial to filter when downsampling
the image to avoid aliasing artifacts. If not specified, it is set to
True when downsampling an image whose data type is not bool.
It is also set to False when using nearest neighbor interpolation
(<code class="docutils literal notranslate"><span class="pre">order</span></code> == 0) with integer input data type.</p>
</dd>
<dt><strong>anti_aliasing_sigma</strong><span class="classifier">{float, tuple of floats}, optional</span></dt><dd><p>Standard deviation for Gaussian filtering used when anti-aliasing.
By default, this value is chosen as (s - 1) / 2 where s is the
downsampling factor, where s &gt; 1. For the up-size case, s &lt; 1, no
anti-aliasing is performed prior to rescaling.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">resize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example illustrates the different edge modes available during interpolation in routines su..."><img alt="" src="../_images/sphx_glr_plot_edge_modes_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_edge_modes.html#sphx-glr-auto-examples-transform-plot-edge-modes-py"><span class="std std-ref">Interpolation: Edge Modes</span></a></p>
  <div class="sphx-glr-thumbnail-title">Interpolation: Edge Modes</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Rescale operation resizes an image by a given scaling factor. The scaling factor can either be ..."><img alt="" src="../_images/sphx_glr_plot_rescale_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_rescale.html#sphx-glr-auto-examples-transform-plot-rescale-py"><span class="std std-ref">Rescale, resize, and downscale</span></a></p>
  <div class="sphx-glr-thumbnail-title">Rescale, resize, and downscale</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="A Fisher vector is an image feature encoding and quantization technique that can be seen as a s..."><img alt="" src="../_images/sphx_glr_plot_fisher_vector_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_fisher_vector.html#sphx-glr-auto-examples-features-detection-plot-fisher-vector-py"><span class="std std-ref">Fisher vector feature encoding</span></a></p>
  <div class="sphx-glr-thumbnail-title">Fisher vector feature encoding</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.resize_local_mean">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">resize_local_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L1274-L1388"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.resize_local_mean" title="Link to this definition">#</a></dt>
<dd><p>Resize an array with the local mean / bilinear scaling.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image. If this is a multichannel image, the axis corresponding
to channels should be specified using <em class="xref py py-obj">channel_axis</em>.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">iterable</span></dt><dd><p>Size of the generated output image. When <em class="xref py py-obj">channel_axis</em> is not None,
the <em class="xref py py-obj">channel_axis</em> should either be omitted from <em class="xref py py-obj">output_shape</em> or the
<code class="docutils literal notranslate"><span class="pre">output_shape[channel_axis]</span></code> must match
<code class="docutils literal notranslate"><span class="pre">image.shape[channel_axis]</span></code>. If the length of <em class="xref py py-obj">output_shape</em> exceeds
image.ndim, additional singleton dimensions will be appended to the
input <code class="docutils literal notranslate"><span class="pre">image</span></code> as needed.</p>
</dd>
<dt><strong>grid_mode</strong><span class="classifier">bool, optional</span></dt><dd><p>Defines <code class="docutils literal notranslate"><span class="pre">image</span></code> pixels position: if True, pixels are assumed to be at
grid intersections, otherwise at cell centers. As a consequence,
for example, a 1d signal of length 5 is considered to have length 4
when <em class="xref py py-obj">grid_mode</em> is False, but length 5 when <em class="xref py py-obj">grid_mode</em> is True. See
the following visual illustration:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| pixel 1 | pixel 2 | pixel 3 | pixel 4 | pixel 5 |
     |&lt;--------------------------------------&gt;|
                        vs.
|&lt;-----------------------------------------------&gt;|
</pre></div>
</div>
<p>The starting point of the arrow in the diagram above corresponds to
coordinate location 0 in each mode.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>resized</strong><span class="classifier">ndarray</span></dt><dd><p>Resized version of the input.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.transform.resize" title="skimage.transform.resize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resize</span></code></a>, <a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">downscale_local_mean</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This method is sometimes referred to as “area-based” interpolation or
“pixel mixing” interpolation <a class="reference internal" href="#r3d46f862a1f0-1" id="id23">[1]</a>. When <em class="xref py py-obj">grid_mode</em> is True, it is
equivalent to using OpenCV’s resize with <em class="xref py py-obj">INTER_AREA</em> interpolation mode.
It is commonly used for image downsizing. If the downsizing factors are
integers, then <a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">downscale_local_mean</span></code></a> should be preferred instead.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r3d46f862a1f0-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id23">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://entropymine.com/imageworsener/pixelmixing/">http://entropymine.com/imageworsener/pixelmixing/</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">resize_local_mean</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize_local_mean</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.rotate">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L330-L453"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.rotate" title="Link to this definition">#</a></dt>
<dd><p>Rotate image by a certain angle around its center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>angle</strong><span class="classifier">float</span></dt><dd><p>Rotation angle in degrees in counter-clockwise direction.</p>
</dd>
<dt><strong>resize</strong><span class="classifier">bool, optional</span></dt><dd><p>Determine whether the shape of the output image will be automatically
calculated, so the complete rotated image exactly fits. Default is
False.</p>
</dd>
<dt><strong>center</strong><span class="classifier">iterable of length 2</span></dt><dd><p>The rotation center. If <code class="docutils literal notranslate"><span class="pre">center=None</span></code>, the image is rotated around
its center, i.e. <code class="docutils literal notranslate"><span class="pre">center=(cols</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">-</span> <span class="pre">0.5,</span> <span class="pre">rows</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">-</span> <span class="pre">0.5)</span></code>.  Please
note that this parameter is (cols, rows), contrary to normal skimage
ordering.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rotated</strong><span class="classifier">ndarray</span></dt><dd><p>Rotated version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v2.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">rotate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(512, 512)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(530, 530)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(512, 512)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Homographies are transformations of a Euclidean space that preserve the alignment of points. Sp..."><img alt="" src="../_images/sphx_glr_plot_transform_types_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_transform_types.html#sphx-glr-auto-examples-transform-plot-transform-types-py"><span class="std std-ref">Types of homographies</span></a></p>
  <div class="sphx-glr-thumbnail-title">Types of homographies</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates how a set of images can be assembled under the hypothesis of rigid bo..."><img alt="" src="../_images/sphx_glr_plot_stitching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_stitching.html#sphx-glr-auto-examples-registration-plot-stitching-py"><span class="std std-ref">Assemble images with simple image stitching</span></a></p>
  <div class="sphx-glr-thumbnail-title">Assemble images with simple image stitching</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Phase correlation (``registration.phase_cross_correlation``) is an efficient method for determi..."><img alt="" src="../_images/sphx_glr_plot_register_rotation_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_register_rotation.html#sphx-glr-auto-examples-registration-plot-register-rotation-py"><span class="std std-ref">Using Polar and Log-Polar Transformations for Registration</span></a></p>
  <div class="sphx-glr-thumbnail-title">Using Polar and Log-Polar Transformations for Registration</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the ORB feature detection and binary description algorithm. It uses a..."><img alt="" src="../_images/sphx_glr_plot_orb_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_orb.html#sphx-glr-auto-examples-features-detection-plot-orb-py"><span class="std std-ref">ORB feature detector and binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">ORB feature detector and binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the BRIEF binary description algorithm. The descriptor consists of re..."><img alt="" src="../_images/sphx_glr_plot_brief_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_brief.html#sphx-glr-auto-examples-features-detection-plot-brief-py"><span class="std std-ref">BRIEF binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">BRIEF binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the SIFT feature detection and its description algorithm."><img alt="" src="../_images/sphx_glr_plot_sift_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_sift.html#sphx-glr-auto-examples-features-detection-plot-sift-py"><span class="std std-ref">SIFT feature detector and descriptor extractor</span></a></p>
  <div class="sphx-glr-thumbnail-title">SIFT feature detector and descriptor extractor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Histogram matching can be used for object detection in images [1]_. This example extracts a sin..."><img alt="" src="../_images/sphx_glr_plot_windowed_histogram_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_windowed_histogram.html#sphx-glr-auto-examples-features-detection-plot-windowed-histogram-py"><span class="std std-ref">Sliding window histogram</span></a></p>
  <div class="sphx-glr-thumbnail-title">Sliding window histogram</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example, we will see how to classify textures based on LBP (Local Binary Pattern). LBP ..."><img alt="" src="../_images/sphx_glr_plot_local_binary_pattern_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_local_binary_pattern.html#sphx-glr-auto-examples-features-detection-plot-local-binary-pattern-py"><span class="std std-ref">Local Binary Pattern for texture classification</span></a></p>
  <div class="sphx-glr-thumbnail-title">Local Binary Pattern for texture classification</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example, we show the error on measuring perimeters, comparing classic approximations an..."><img alt="" src="../_images/sphx_glr_plot_perimeters_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_perimeters.html#sphx-glr-auto-examples-segmentation-plot-perimeters-py"><span class="std std-ref">Measure perimeters with different estimators</span></a></p>
  <div class="sphx-glr-thumbnail-title">Measure perimeters with different estimators</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima..."><img alt="" src="../_images/sphx_glr_plot_regionprops_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></p>
  <div class="sphx-glr-thumbnail-title">Measure region properties</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Image comparison is particularly useful when performing image processing tasks such as exposure..."><img alt="" src="../_images/sphx_glr_plot_image_comparison_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_image_comparison.html#sphx-glr-auto-examples-applications-plot-image-comparison-py"><span class="std std-ref">Visual image comparison</span></a></p>
  <div class="sphx-glr-thumbnail-title">Visual image comparison</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.swirl">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">swirl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strength</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L520-L601"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.swirl" title="Link to this definition">#</a></dt>
<dd><p>Perform a swirl transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>center</strong><span class="classifier">(column, row) tuple or (2,) ndarray, optional</span></dt><dd><p>Center coordinate of transformation.</p>
</dd>
<dt><strong>strength</strong><span class="classifier">float, optional</span></dt><dd><p>The amount of swirling applied.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>The extent of the swirl in pixels.  The effect dies out
rapidly beyond <em class="xref py py-obj">radius</em>.</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Additional rotation applied to the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>swirled</strong><span class="classifier">ndarray</span></dt><dd><p>Swirled version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>output_shape</strong><span class="classifier">tuple (rows, cols), optional</span></dt><dd><p>Shape of the output image generated. By default the shape of the input
image is preserved.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode, with ‘reflect’ used as the default. Modes match
the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v2.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
</dl>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Image swirling is a non-linear image deformation that creates a whirlpool effect.  This example..."><img alt="" src="../_images/sphx_glr_plot_swirl_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_swirl.html#sphx-glr-auto-examples-transform-plot-swirl-py"><span class="std std-ref">Swirl</span></a></p>
  <div class="sphx-glr-thumbnail-title">Swirl</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.warp">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">warp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L764-L1042"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.warp" title="Link to this definition">#</a></dt>
<dd><p>Warp an image according to a given coordinate transformation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>inverse_map</strong><span class="classifier">transformation object, callable <code class="docutils literal notranslate"><span class="pre">cr</span> <span class="pre">=</span> <span class="pre">f(cr,</span> <span class="pre">**kwargs)</span></code>, or ndarray</span></dt><dd><p>Inverse coordinate map, which transforms coordinates in the output
images into their corresponding coordinates in the input image.</p>
<p>There are a number of different options to define this map, depending
on the dimensionality of the input image. A 2-D image can have 2
dimensions for gray-scale images, or 3 dimensions with color
information.</p>
<blockquote>
<div><ul class="simple">
<li><p>For 2-D images, you can directly pass a transformation object,
e.g. <a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.SimilarityTransform</span></code></a>, or its inverse.</p></li>
<li><p>For 2-D images, you can pass a <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3)</span></code> homogeneous
transformation matrix, e.g.
<em class="xref py py-obj">skimage.transform.SimilarityTransform.params</em>.</p></li>
<li><p>For 2-D images, a function that transforms a <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">2)</span></code> array of
<code class="docutils literal notranslate"><span class="pre">(col,</span> <span class="pre">row)</span></code> coordinates in the output image to their
corresponding coordinates in the input image. Extra parameters to
the function can be specified through <em class="xref py py-obj">map_args</em>.</p></li>
<li><p>For N-D images, you can directly pass an array of coordinates.
The first dimension specifies the coordinates in the input image,
while the subsequent dimensions determine the position in the
output image. E.g. in case of 2-D images, you need to pass an array
of shape <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">rows,</span> <span class="pre">cols)</span></code>, where <em class="xref py py-obj">rows</em> and <em class="xref py py-obj">cols</em> determine the
shape of the output image, and the first dimension contains the
<code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> coordinate in the input image.
See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.map_coordinates.html#scipy.ndimage.map_coordinates" title="(in SciPy v1.14.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.ndimage.map_coordinates</span></code></a> for further documentation.</p></li>
</ul>
</div></blockquote>
<p>Note, that a <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3)</span></code> matrix is interpreted as a homogeneous
transformation matrix, so you cannot interpolate values from a 3-D
input, if the output is of shape <code class="docutils literal notranslate"><span class="pre">(3,)</span></code>.</p>
<p>See example section for usage.</p>
</dd>
<dt><strong>map_args</strong><span class="classifier">dict, optional</span></dt><dd><p>Keyword arguments passed to <em class="xref py py-obj">inverse_map</em>.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">tuple (rows, cols), optional</span></dt><dd><p>Shape of the output image generated. By default the shape of the input
image is preserved.  Note that, even for multi-band images, only rows
and columns need to be specified.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><dl>
<dt>The order of interpolation. The order has to be in the range 0-5:</dt><dd><ul class="simple">
<li><p>0: Nearest-neighbor</p></li>
<li><p>1: Bi-linear (default)</p></li>
<li><p>2: Bi-quadratic</p></li>
<li><p>3: Bi-cubic</p></li>
<li><p>4: Bi-quartic</p></li>
<li><p>5: Bi-quintic</p></li>
</ul>
<p>Default is 0 if image.dtype is bool and 1 otherwise.</p>
</dd>
</dl>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v2.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>warped</strong><span class="classifier">double ndarray</span></dt><dd><p>The warped input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The input image is converted to a <em class="xref py py-obj">double</em> image.</p></li>
<li><p>In case of a <a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SimilarityTransform</span></code></a>, <a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineTransform</span></code></a> and
<a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a> and <em class="xref py py-obj">order</em> in [0, 3] this function uses the
underlying transformation matrix to warp the image with a much faster
routine.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">warp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
</pre></div>
</div>
<p>The following image warps are all equal but differ substantially in
execution time. The image is shifted to the bottom.</p>
<p>Use a geometric transform to warp an image (fast):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">SimilarityTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">tform</span><span class="p">)</span>
</pre></div>
</div>
<p>Use a callable (slow):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_down</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">shift_down</span><span class="p">)</span>
</pre></div>
</div>
<p>Use a transformation matrix to warp an image (fast):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">ProjectiveTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ProjectiveTransform</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="p">))</span>
</pre></div>
</div>
<p>You can also use the inverse of a geometric transformation (fast):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span>
</pre></div>
</div>
<p>For N-D images you can pass a coordinate array, that specifies the
coordinates in the input image for every element in the output image. E.g.
if you want to rescale a 3-D cube, you can do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cube_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">cube_shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Setup the coordinate array, that defines the scaling:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">cube_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords0</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coords0</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span><span class="p">])</span>
</pre></div>
</div>
<p>Assume that the cube contains spatial data, where the first array element
center is at coordinate (0.5, 0.5, 0.5) in real space, i.e. we have to
account for this extra offset when scaling the image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Image swirling is a non-linear image deformation that creates a whirlpool effect.  This example..."><img alt="" src="../_images/sphx_glr_plot_swirl_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_swirl.html#sphx-glr-auto-examples-transform-plot-swirl-py"><span class="std std-ref">Swirl</span></a></p>
  <div class="sphx-glr-thumbnail-title">Swirl</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use the Piecewise Affine Transformation."><img alt="" src="../_images/sphx_glr_plot_piecewise_affine_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_piecewise_affine.html#sphx-glr-auto-examples-transform-plot-piecewise-affine-py"><span class="std std-ref">Piecewise Affine Transformation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Piecewise Affine Transformation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example, we will see how to use geometric transformations in the context of image proce..."><img alt="" src="../_images/sphx_glr_plot_geometric_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_geometric.html#sphx-glr-auto-examples-transform-plot-geometric-py"><span class="std std-ref">Using geometric transformations</span></a></p>
  <div class="sphx-glr-thumbnail-title">Using geometric transformations</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Homographies are transformations of a Euclidean space that preserve the alignment of points. Sp..."><img alt="" src="../_images/sphx_glr_plot_transform_types_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_transform_types.html#sphx-glr-auto-examples-transform-plot-transform-types-py"><span class="std std-ref">Types of homographies</span></a></p>
  <div class="sphx-glr-thumbnail-title">Types of homographies</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="To warp an image, we start with a set of source and target coordinates. The goal is to deform t..."><img alt="" src="../_images/sphx_glr_plot_tps_deformation_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_tps_deformation.html#sphx-glr-auto-examples-transform-plot-tps-deformation-py"><span class="std std-ref">Use thin-plate splines for image warping</span></a></p>
  <div class="sphx-glr-thumbnail-title">Use thin-plate splines for image warping</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this simplified example we first generate two synthetic images as if they were taken from di..."><img alt="" src="../_images/sphx_glr_plot_matching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_matching.html#sphx-glr-auto-examples-transform-plot-matching-py"><span class="std std-ref">Robust matching using RANSAC</span></a></p>
  <div class="sphx-glr-thumbnail-title">Robust matching using RANSAC</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Demonstration of image registration using optical flow."><img alt="" src="../_images/sphx_glr_plot_opticalflow_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_opticalflow.html#sphx-glr-auto-examples-registration-plot-opticalflow-py"><span class="std std-ref">Registration using optical flow</span></a></p>
  <div class="sphx-glr-thumbnail-title">Registration using optical flow</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates how a set of images can be assembled under the hypothesis of rigid bo..."><img alt="" src="../_images/sphx_glr_plot_stitching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_stitching.html#sphx-glr-auto-examples-registration-plot-stitching-py"><span class="std std-ref">Assemble images with simple image stitching</span></a></p>
  <div class="sphx-glr-thumbnail-title">Assemble images with simple image stitching</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Detect corner points using the Harris corner detector and determine the subpixel position of co..."><img alt="" src="../_images/sphx_glr_plot_corner_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_corner.html#sphx-glr-auto-examples-features-detection-plot-corner-py"><span class="std std-ref">Corner detection</span></a></p>
  <div class="sphx-glr-thumbnail-title">Corner detection</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="The CENSURE feature detector is a scale-invariant center-surround detector (CENSURE) that claim..."><img alt="" src="../_images/sphx_glr_plot_censure_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_censure.html#sphx-glr-auto-examples-features-detection-plot-censure-py"><span class="std std-ref">CENSURE feature detector</span></a></p>
  <div class="sphx-glr-thumbnail-title">CENSURE feature detector</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the ORB feature detection and binary description algorithm. It uses a..."><img alt="" src="../_images/sphx_glr_plot_orb_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_orb.html#sphx-glr-auto-examples-features-detection-plot-orb-py"><span class="std std-ref">ORB feature detector and binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">ORB feature detector and binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the BRIEF binary description algorithm. The descriptor consists of re..."><img alt="" src="../_images/sphx_glr_plot_brief_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_brief.html#sphx-glr-auto-examples-features-detection-plot-brief-py"><span class="std std-ref">BRIEF binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">BRIEF binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the SIFT feature detection and its description algorithm."><img alt="" src="../_images/sphx_glr_plot_sift_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_sift.html#sphx-glr-auto-examples-features-detection-plot-sift-py"><span class="std std-ref">SIFT feature detector and descriptor extractor</span></a></p>
  <div class="sphx-glr-thumbnail-title">SIFT feature detector and descriptor extractor</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.warp_coords">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">warp_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L627-L702"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.warp_coords" title="Link to this definition">#</a></dt>
<dd><p>Build the source coordinates for the output of a 2-D image warp.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coord_map</strong><span class="classifier">callable like GeometricTransform.inverse</span></dt><dd><p>Return input coordinates for given output coordinates.
Coordinates are in the shape (P, 2), where P is the number
of coordinates and each element is a <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> pair.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple</span></dt><dd><p>Shape of output image <code class="docutils literal notranslate"><span class="pre">(rows,</span> <span class="pre">cols[,</span> <span class="pre">bands])</span></code>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">np.dtype or string</span></dt><dd><p>dtype for return value (sane choices: float32 or float64).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>coords</strong><span class="classifier">(ndim, rows, cols[, bands]) array of dtype <em class="xref py py-obj">dtype</em></span></dt><dd><p>Coordinates for <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.map_coordinates.html#scipy.ndimage.map_coordinates" title="(in SciPy v1.14.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.ndimage.map_coordinates</span></code></a>, that will yield
an image of shape (orows, ocols, bands) by drawing from source
points according to the <em class="xref py py-obj">coord_transform_fn</em>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is a lower-level routine that produces the source coordinates for 2-D
images used by <em class="xref py py-obj">warp()</em>.</p>
<p>It is provided separately from <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp</span></code></a> to give additional flexibility to
users who would like, for example, to re-use a particular coordinate
mapping, to use specific dtypes at various points along the the
image-warping process, or to implement different post-processing logic
than <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp</span></code></a> performs after the call to <em class="xref py py-obj">ndi.map_coordinates</em>.</p>
<p class="rubric">Examples</p>
<p>Produce a coordinate map that shifts an image up and to the right:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">map_coordinates</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_up10_left20</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">warp_coords</span><span class="p">(</span><span class="n">shift_up10_left20</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped_image</span> <span class="o">=</span> <span class="n">map_coordinates</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.warp_polar">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">warp_polar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L1107-L1219"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.warp_polar" title="Link to this definition">#</a></dt>
<dd><p>Remap image to polar or log-polar coordinates space.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">(M, N[, C]) ndarray</span></dt><dd><p>Input image. For multichannel images <em class="xref py py-obj">channel_axis</em> has to be specified.</p>
</dd>
<dt><strong>center</strong><span class="classifier">2-tuple, optional</span></dt><dd><p><em class="xref py py-obj">(row, col)</em> coordinates of the point in <em class="xref py py-obj">image</em> that represents the center of
the transformation (i.e., the origin in Cartesian space). Values can be of
type <em class="xref py py-obj">float</em>. If no value is given, the center is assumed to be the center point
of <em class="xref py py-obj">image</em>.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>Radius of the circle that bounds the area to be transformed.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">tuple (row, col), optional</span></dt><dd></dd>
<dt><strong>scaling</strong><span class="classifier">{‘linear’, ‘log’}, optional</span></dt><dd><p>Specify whether the image warp is polar or log-polar. Defaults to
‘linear’.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">keyword arguments</span></dt><dd><p>Passed to <em class="xref py py-obj">transform.warp</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>warped</strong><span class="classifier">ndarray</span></dt><dd><p>The polar or log-polar warped image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Perform a basic polar warp on a grayscale image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">warp_polar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">checkerboard</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p>Perform a log-polar warp on a grayscale image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Perform a log-polar warp on a grayscale image while specifying center,
radius, and output shape:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span> <span class="n">radius</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">output_shape</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Perform a log-polar warp on a color image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">channel_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Phase correlation (``registration.phase_cross_correlation``) is an efficient method for determi..."><img alt="" src="../_images/sphx_glr_plot_register_rotation_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_register_rotation.html#sphx-glr-auto-examples-registration-plot-register-rotation-py"><span class="std std-ref">Using Polar and Log-Polar Transformations for Registration</span></a></p>
  <div class="sphx-glr-thumbnail-title">Using Polar and Log-Polar Transformations for Registration</div>
</div></div></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">AffineTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shear</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L880-L1080"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.AffineTransform" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform._geometric.ProjectiveTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a></p>
<p>Affine transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a2</span>
  <span class="o">=</span>   <span class="n">sx</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="p">[</span><span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">tan</span><span class="p">(</span><span class="n">shear_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)]</span>
    <span class="o">-</span> <span class="n">sy</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="p">[</span><span class="n">tan</span><span class="p">(</span><span class="n">shear_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)]</span>
    <span class="o">+</span> <span class="n">translation_x</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">b2</span>
  <span class="o">=</span>   <span class="n">sx</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="p">[</span><span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">tan</span><span class="p">(</span><span class="n">shear_y</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)]</span>
    <span class="o">-</span> <span class="n">sy</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="p">[</span><span class="n">tan</span><span class="p">(</span><span class="n">shear_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)]</span>
    <span class="o">+</span> <span class="n">translation_y</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">sx</span></code> and <code class="docutils literal notranslate"><span class="pre">sy</span></code> are scale factors in the x and y directions.</p>
<p>This is equivalent to applying the operations in the following order:</p>
<ol class="arabic simple">
<li><p>Scale</p></li>
<li><p>Shear</p></li>
<li><p>Rotate</p></li>
<li><p>Translate</p></li>
</ol>
<p>The homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">a1</span>  <span class="n">a2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">b1</span>  <span class="n">b2</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>In 2D, the transformation parameters can be given as the homogeneous
transformation matrix, above, or as the implicit parameters, scale,
rotation, shear, and translation in x (a2) and y (b2). For 3D and higher,
only the matrix form is allowed.</p>
<p>In narrower transforms, such as the Euclidean (only rotation and
translation) or Similarity (rotation, translation, and a global scale
factor) transforms, it is possible to specify 3D transforms using implicit
parameters also.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>matrix</strong><span class="classifier">(D+1, D+1) array_like, optional</span></dt><dd><p>Homogeneous transformation matrix. If this matrix is provided, it is an
error to provide any of scale, rotation, shear, or translation.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">{s as float or (sx, sy) as array, list or tuple}, optional</span></dt><dd><p>Scale factor(s). If a single value, it will be assigned to both
sx and sy. Only available for 2D.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.17: </span>Added support for supplying a single scalar value.</p>
</div>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Rotation angle, clockwise, as radians. Only available for 2D.</p>
</dd>
<dt><strong>shear</strong><span class="classifier">float or 2-tuple of float, optional</span></dt><dd><p>The x and y shear angles, clockwise, by which these axes are
rotated around the origin [2].
If a single value is given, take that to be the x shear angle, with
the y angle remaining 0. Only available in 2D.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(tx, ty) as array, list or tuple, optional</span></dt><dd><p>Translation parameters. Only available for 2D.</p>
</dd>
<dt><strong>dimensionality</strong><span class="classifier">int, optional</span></dt><dd><p>The dimensionality of the transform. This is not used if any other
parameters are provided.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ValueError</dt><dd><p>If both <code class="docutils literal notranslate"><span class="pre">matrix</span></code> and any of the other parameters are provided.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r3ef04768c79e-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Wikipedia, “Affine transformation”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Affine_transformation#Image_transformation">https://en.wikipedia.org/wiki/Affine_transformation#Image_transformation</a></p>
</div>
<div class="citation" id="r3ef04768c79e-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Wikipedia, “Shear mapping”,
<a class="reference external" href="https://en.wikipedia.org/wiki/Shear_mapping">https://en.wikipedia.org/wiki/Shear_mapping</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">skimage</span> <span class="k">as</span> <span class="nn">ski</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">ski</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span>
</pre></div>
</div>
<p>Define source and destination points:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">150</span><span class="p">,</span> <span class="mi">150</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mi">150</span><span class="p">,</span> <span class="mi">200</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">150</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mi">150</span><span class="p">,</span> <span class="mi">400</span><span class="p">]])</span>
</pre></div>
</div>
<p>Estimate the transformation matrix:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">ski</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">AffineTransform</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Apply the transformation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">ski</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">inverse_map</span><span class="o">=</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(D+1, D+1) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shear</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L987-L1050"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.AffineTransform.__init__" title="Link to this definition">#</a></dt>
<dd><div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Homographies are transformations of a Euclidean space that preserve the alignment of points. Sp..."><img alt="" src="../_images/sphx_glr_plot_transform_types_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_transform_types.html#sphx-glr-auto-examples-transform-plot-transform-types-py"><span class="std std-ref">Types of homographies</span></a></p>
  <div class="sphx-glr-thumbnail-title">Types of homographies</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this simplified example we first generate two synthetic images as if they were taken from di..."><img alt="" src="../_images/sphx_glr_plot_matching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_matching.html#sphx-glr-auto-examples-transform-plot-matching-py"><span class="std std-ref">Robust matching using RANSAC</span></a></p>
  <div class="sphx-glr-thumbnail-title">Robust matching using RANSAC</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Detect corner points using the Harris corner detector and determine the subpixel position of co..."><img alt="" src="../_images/sphx_glr_plot_corner_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_corner.html#sphx-glr-auto-examples-features-detection-plot-corner-py"><span class="std std-ref">Corner detection</span></a></p>
  <div class="sphx-glr-thumbnail-title">Corner detection</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="The CENSURE feature detector is a scale-invariant center-surround detector (CENSURE) that claim..."><img alt="" src="../_images/sphx_glr_plot_censure_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_censure.html#sphx-glr-auto-examples-features-detection-plot-censure-py"><span class="std std-ref">CENSURE feature detector</span></a></p>
  <div class="sphx-glr-thumbnail-title">CENSURE feature detector</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the ORB feature detection and binary description algorithm. It uses a..."><img alt="" src="../_images/sphx_glr_plot_orb_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_orb.html#sphx-glr-auto-examples-features-detection-plot-orb-py"><span class="std std-ref">ORB feature detector and binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">ORB feature detector and binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the BRIEF binary description algorithm. The descriptor consists of re..."><img alt="" src="../_images/sphx_glr_plot_brief_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_brief.html#sphx-glr-auto-examples-features-detection-plot-brief-py"><span class="std std-ref">BRIEF binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">BRIEF binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the SIFT feature detection and its description algorithm."><img alt="" src="../_images/sphx_glr_plot_sift_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_sift.html#sphx-glr-auto-examples-features-detection-plot-sift-py"><span class="std std-ref">SIFT feature detector and descriptor extractor</span></a></p>
  <div class="sphx-glr-thumbnail-title">SIFT feature detector and descriptor extractor</div>
</div></div></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform.dimensionality">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dimensionality</span></span><a class="headerlink" href="#skimage.transform.AffineTransform.dimensionality" title="Link to this definition">#</a></dt>
<dd><p>The dimensionality of the transformation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L717-L839"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.AffineTransform.estimate" title="Link to this definition">#</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">c0</span> <span class="n">c1</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<p>Weights can be applied to each pair of corresponding points to
indicate, particularly in an overdetermined system, if point pairs have
higher or lower confidence or uncertainties associated with them. From
the matrix treatment of least squares problems, these weight values are
normalised, square-rooted, then built into a diagonal matrix, by which
A is multiplied.</p>
<p>In case of the affine transformation the coefficients c0 and c1 are 0.
Thus the system of equations is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">(N,) array_like, optional</span></dt><dd><p>Relative weight values for each pair of points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform.inverse">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inverse</span></span><a class="headerlink" href="#skimage.transform.AffineTransform.inverse" title="Link to this definition">#</a></dt>
<dd><p>Return a transform object representing the inverse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform.residuals">
<span class="sig-name descname"><span class="pre">residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L206-L225"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.AffineTransform.residuals" title="Link to this definition">#</a></dt>
<dd><p>Determine residuals of transformed destination coordinates.</p>
<p>For each transformed source coordinate the Euclidean distance to the
respective destination coordinate is determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N,) array</span></dt><dd><p>Residual for coordinate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform.rotation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rotation</span></span><a class="headerlink" href="#skimage.transform.AffineTransform.rotation" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform.scale">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">scale</span></span><a class="headerlink" href="#skimage.transform.AffineTransform.scale" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform.shear">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shear</span></span><a class="headerlink" href="#skimage.transform.AffineTransform.shear" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform.translation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">translation</span></span><a class="headerlink" href="#skimage.transform.AffineTransform.translation" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.EssentialMatrixTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">EssentialMatrixTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L471-L615"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.EssentialMatrixTransform" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#skimage.transform.FundamentalMatrixTransform" title="skimage.transform._geometric.FundamentalMatrixTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">FundamentalMatrixTransform</span></code></a></p>
<p>Essential matrix transformation.</p>
<p>The essential matrix relates corresponding points between a pair of
calibrated images. The matrix transforms normalized, homogeneous image
points in one image to epipolar lines in the other image.</p>
<p>The essential matrix is only defined for a pair of moving images capturing a
non-planar scene. In the case of pure rotation or planar scenes, the
homography describes the geometric relation between two images
(<a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a>). If the intrinsic calibration of the images is
unknown, the fundamental matrix describes the projective relation between
the two images (<a class="reference internal" href="#skimage.transform.FundamentalMatrixTransform" title="skimage.transform.FundamentalMatrixTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FundamentalMatrixTransform</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rotation</strong><span class="classifier">(3, 3) array_like, optional</span></dt><dd><p>Rotation matrix of the relative camera motion.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(3, 1) array_like, optional</span></dt><dd><p>Translation vector of the relative camera motion. The vector must
have unit length.</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">(3, 3) array_like, optional</span></dt><dd><p>Essential matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r2fbde33858f1-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Hartley, Richard, and Andrew Zisserman. Multiple view geometry in
computer vision. Cambridge university press, 2003.</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">skimage</span> <span class="k">as</span> <span class="nn">ski</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform_matrix</span> <span class="o">=</span> <span class="n">ski</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">EssentialMatrixTransform</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">rotation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">translation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform_matrix</span><span class="o">.</span><span class="n">params</span>
<span class="go">array([[ 0., -1.,  0.],</span>
<span class="go">       [ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.839035</span><span class="p">,</span> <span class="mf">1.924743</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span> <span class="mf">0.543582</span><span class="p">,</span> <span class="mf">0.375221</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span> <span class="mf">0.47324</span> <span class="p">,</span> <span class="mf">0.142522</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span> <span class="mf">0.96491</span> <span class="p">,</span> <span class="mf">0.598376</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span> <span class="mf">0.102388</span><span class="p">,</span> <span class="mf">0.140092</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mf">15.994343</span><span class="p">,</span> <span class="mf">9.622164</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span> <span class="mf">0.285901</span><span class="p">,</span> <span class="mf">0.430055</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span> <span class="mf">0.09115</span> <span class="p">,</span> <span class="mf">0.254594</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.002114</span><span class="p">,</span> <span class="mf">1.129644</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mf">1.521742</span><span class="p">,</span> <span class="mf">1.846002</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mf">1.084332</span><span class="p">,</span> <span class="mf">0.275134</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mf">0.293328</span><span class="p">,</span> <span class="mf">0.588992</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mf">0.839509</span><span class="p">,</span> <span class="mf">0.08729</span> <span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mf">1.779735</span><span class="p">,</span> <span class="mf">1.116857</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mf">0.878616</span><span class="p">,</span> <span class="mf">0.602447</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mf">0.642616</span><span class="p">,</span> <span class="mf">1.028681</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform_matrix</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform_matrix</span><span class="o">.</span><span class="n">residuals</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
<span class="go">array([0.42455187, 0.01460448, 0.13847034, 0.12140951, 0.27759346,</span>
<span class="go">       0.32453118, 0.00210776, 0.26512283])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(3, 3) array</span></dt><dd><p>Essential matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.EssentialMatrixTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L541-L580"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.EssentialMatrixTransform.__init__" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.EssentialMatrixTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L582-L615"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.EssentialMatrixTransform.estimate" title="Link to this definition">#</a></dt>
<dd><p>Estimate essential matrix using 8-point algorithm.</p>
<p>The 8-point algorithm requires at least 8 corresponding point pairs for
a well-conditioned solution, otherwise the over-determined solution is
estimated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.EssentialMatrixTransform.inverse">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inverse</span></span><a class="headerlink" href="#skimage.transform.EssentialMatrixTransform.inverse" title="Link to this definition">#</a></dt>
<dd><p>Return a transform object representing the inverse.</p>
<p>See Hartley &amp; Zisserman, Ch. 8: Epipolar Geometry and the Fundamental
Matrix, for an explanation of why F.T gives the inverse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.EssentialMatrixTransform.residuals">
<span class="sig-name descname"><span class="pre">residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L440-L468"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.EssentialMatrixTransform.residuals" title="Link to this definition">#</a></dt>
<dd><p>Compute the Sampson distance.</p>
<p>The Sampson distance is the first approximation to the geometric error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N,) array</span></dt><dd><p>Sampson distance.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.EuclideanTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">EuclideanTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1254-L1401"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.EuclideanTransform" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform._geometric.ProjectiveTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a></p>
<p>Euclidean transformation, also known as a rigid transform.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">a1</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span>
</pre></div>
</div>
<p>where the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span> <span class="o">-</span><span class="n">b0</span>  <span class="n">a1</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">a0</span>  <span class="n">b1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>   <span class="mi">1</span> <span class="p">]]</span>
</pre></div>
</div>
<p>The Euclidean transformation is a rigid transformation with rotation and
translation parameters. The similarity transformation extends the Euclidean
transformation with a single scaling factor.</p>
<p>In 2D and 3D, the transformation parameters may be provided either via
<em class="xref py py-obj">matrix</em>, the homogeneous transformation matrix, above, or via the
implicit parameters <a class="reference internal" href="#skimage.transform.EuclideanTransform.rotation" title="skimage.transform.EuclideanTransform.rotation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotation</span></code></a> and/or <a class="reference internal" href="#skimage.transform.EuclideanTransform.translation" title="skimage.transform.EuclideanTransform.translation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">translation</span></code></a> (where <em class="xref py py-obj">a1</em> is the
translation along <em class="xref py py-obj">x</em>, <em class="xref py py-obj">b1</em> along <em class="xref py py-obj">y</em>, etc.). Beyond 3D, if the
transformation is only a translation, you may use the implicit parameter
<a class="reference internal" href="#skimage.transform.EuclideanTransform.translation" title="skimage.transform.EuclideanTransform.translation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">translation</span></code></a>; otherwise, you must use <em class="xref py py-obj">matrix</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(D+1, D+1) array_like, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">float or sequence of float, optional</span></dt><dd><p>Rotation angle, clockwise, as radians. If given as
a vector, it is interpreted as Euler rotation angles <a class="reference internal" href="#r844fb1ca9398-1" id="id28">[1]</a>. Only 2D
(single rotation) and 3D (Euler rotations) values are supported. For
higher dimensions, you must provide or estimate the transformation
matrix.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(x, y[, z, …]) sequence of float, length D, optional</span></dt><dd><p>Translation parameters for each axis.</p>
</dd>
<dt><strong>dimensionality</strong><span class="classifier">int, optional</span></dt><dd><p>The dimensionality of the transform.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r844fb1ca9398-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id28">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions">https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions</a></p>
</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(D+1, D+1) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.EuclideanTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1307-L1359"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.EuclideanTransform.__init__" title="Link to this definition">#</a></dt>
<dd><div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In this example, we will see how to use geometric transformations in the context of image proce..."><img alt="" src="../_images/sphx_glr_plot_geometric_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_geometric.html#sphx-glr-auto-examples-transform-plot-geometric-py"><span class="std std-ref">Using geometric transformations</span></a></p>
  <div class="sphx-glr-thumbnail-title">Using geometric transformations</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Homographies are transformations of a Euclidean space that preserve the alignment of points. Sp..."><img alt="" src="../_images/sphx_glr_plot_transform_types_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_transform_types.html#sphx-glr-auto-examples-transform-plot-transform-types-py"><span class="std std-ref">Types of homographies</span></a></p>
  <div class="sphx-glr-thumbnail-title">Types of homographies</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates how a set of images can be assembled under the hypothesis of rigid bo..."><img alt="" src="../_images/sphx_glr_plot_stitching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_stitching.html#sphx-glr-auto-examples-registration-plot-stitching-py"><span class="std std-ref">Assemble images with simple image stitching</span></a></p>
  <div class="sphx-glr-thumbnail-title">Assemble images with simple image stitching</div>
</div></div></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.EuclideanTransform.dimensionality">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dimensionality</span></span><a class="headerlink" href="#skimage.transform.EuclideanTransform.dimensionality" title="Link to this definition">#</a></dt>
<dd><p>The dimensionality of the transformation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.EuclideanTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1361-L1385"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.EuclideanTransform.estimate" title="Link to this definition">#</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.EuclideanTransform.inverse">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inverse</span></span><a class="headerlink" href="#skimage.transform.EuclideanTransform.inverse" title="Link to this definition">#</a></dt>
<dd><p>Return a transform object representing the inverse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.EuclideanTransform.residuals">
<span class="sig-name descname"><span class="pre">residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L206-L225"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.EuclideanTransform.residuals" title="Link to this definition">#</a></dt>
<dd><p>Determine residuals of transformed destination coordinates.</p>
<p>For each transformed source coordinate the Euclidean distance to the
respective destination coordinate is determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N,) array</span></dt><dd><p>Residual for coordinate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.EuclideanTransform.rotation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rotation</span></span><a class="headerlink" href="#skimage.transform.EuclideanTransform.rotation" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.EuclideanTransform.translation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">translation</span></span><a class="headerlink" href="#skimage.transform.EuclideanTransform.translation" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.FundamentalMatrixTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">FundamentalMatrixTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L228-L468"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_GeometricTransform</span></code></p>
<p>Fundamental matrix transformation.</p>
<p>The fundamental matrix relates corresponding points between a pair of
uncalibrated images. The matrix transforms homogeneous image points in one
image to epipolar lines in the other image.</p>
<p>The fundamental matrix is only defined for a pair of moving images. In the
case of pure rotation or planar scenes, the homography describes the
geometric relation between two images (<a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a>). If the
intrinsic calibration of the images is known, the essential matrix describes
the metric relation between the two images (<a class="reference internal" href="#skimage.transform.EssentialMatrixTransform" title="skimage.transform.EssentialMatrixTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EssentialMatrixTransform</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(3, 3) array_like, optional</span></dt><dd><p>Fundamental matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r725e3a484348-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Hartley, Richard, and Andrew Zisserman. Multiple view geometry in
computer vision. Cambridge university press, 2003.</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">skimage</span> <span class="k">as</span> <span class="nn">ski</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform_matrix</span> <span class="o">=</span> <span class="n">ski</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">FundamentalMatrixTransform</span><span class="p">()</span>
</pre></div>
</div>
<p>Define source and destination points:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.839035</span><span class="p">,</span> <span class="mf">1.924743</span><span class="p">,</span>
<span class="gp">... </span>                <span class="mf">0.543582</span><span class="p">,</span> <span class="mf">0.375221</span><span class="p">,</span>
<span class="gp">... </span>                <span class="mf">0.473240</span><span class="p">,</span> <span class="mf">0.142522</span><span class="p">,</span>
<span class="gp">... </span>                <span class="mf">0.964910</span><span class="p">,</span> <span class="mf">0.598376</span><span class="p">,</span>
<span class="gp">... </span>                <span class="mf">0.102388</span><span class="p">,</span> <span class="mf">0.140092</span><span class="p">,</span>
<span class="gp">... </span>               <span class="mf">15.994343</span><span class="p">,</span> <span class="mf">9.622164</span><span class="p">,</span>
<span class="gp">... </span>                <span class="mf">0.285901</span><span class="p">,</span> <span class="mf">0.430055</span><span class="p">,</span>
<span class="gp">... </span>                <span class="mf">0.091150</span><span class="p">,</span> <span class="mf">0.254594</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.002114</span><span class="p">,</span> <span class="mf">1.129644</span><span class="p">,</span>
<span class="gp">... </span>                <span class="mf">1.521742</span><span class="p">,</span> <span class="mf">1.846002</span><span class="p">,</span>
<span class="gp">... </span>                <span class="mf">1.084332</span><span class="p">,</span> <span class="mf">0.275134</span><span class="p">,</span>
<span class="gp">... </span>                <span class="mf">0.293328</span><span class="p">,</span> <span class="mf">0.588992</span><span class="p">,</span>
<span class="gp">... </span>                <span class="mf">0.839509</span><span class="p">,</span> <span class="mf">0.087290</span><span class="p">,</span>
<span class="gp">... </span>                <span class="mf">1.779735</span><span class="p">,</span> <span class="mf">1.116857</span><span class="p">,</span>
<span class="gp">... </span>                <span class="mf">0.878616</span><span class="p">,</span> <span class="mf">0.602447</span><span class="p">,</span>
<span class="gp">... </span>                <span class="mf">0.642616</span><span class="p">,</span> <span class="mf">1.028681</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Estimate the transformation matrix:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tform_matrix</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform_matrix</span><span class="o">.</span><span class="n">params</span>
<span class="go">array([[-0.21785884,  0.41928191, -0.03430748],</span>
<span class="go">       [-0.07179414,  0.04516432,  0.02160726],</span>
<span class="go">       [ 0.24806211, -0.42947814,  0.02210191]])</span>
</pre></div>
</div>
<p>Compute the Sampson distance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tform_matrix</span><span class="o">.</span><span class="n">residuals</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
<span class="go">array([0.0053886 , 0.00526101, 0.08689701, 0.01850534, 0.09418259,</span>
<span class="go">       0.00185967, 0.06160489, 0.02655136])</span>
</pre></div>
</div>
<p>Apply inverse transformation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tform_matrix</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>
<span class="go">array([[-0.0513591 ,  0.04170974,  0.01213043],</span>
<span class="go">       [-0.21599496,  0.29193419,  0.00978184],</span>
<span class="go">       [-0.0079222 ,  0.03758889, -0.00915389],</span>
<span class="go">       [ 0.14187184, -0.27988959,  0.02476507],</span>
<span class="go">       [ 0.05890075, -0.07354481, -0.00481342],</span>
<span class="go">       [-0.21985267,  0.36717464, -0.01482408],</span>
<span class="go">       [ 0.01339569, -0.03388123,  0.00497605],</span>
<span class="go">       [ 0.03420927, -0.1135812 ,  0.02228236]])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(3, 3) array</span></dt><dd><p>Fundamental matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.FundamentalMatrixTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L310-L324"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.__init__" title="Link to this definition">#</a></dt>
<dd><div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates how to robustly estimate epipolar geometry &lt;https://en.wikipedia.org/..."><img alt="" src="../_images/sphx_glr_plot_fundamental_matrix_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_fundamental_matrix.html#sphx-glr-auto-examples-transform-plot-fundamental-matrix-py"><span class="std std-ref">Fundamental matrix estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Fundamental matrix estimation</div>
</div></div></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.FundamentalMatrixTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L407-L438"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.estimate" title="Link to this definition">#</a></dt>
<dd><p>Estimate fundamental matrix using 8-point algorithm.</p>
<p>The 8-point algorithm requires at least 8 corresponding point pairs for
a well-conditioned solution, otherwise the over-determined solution is
estimated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.FundamentalMatrixTransform.inverse">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inverse</span></span><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.inverse" title="Link to this definition">#</a></dt>
<dd><p>Return a transform object representing the inverse.</p>
<p>See Hartley &amp; Zisserman, Ch. 8: Epipolar Geometry and the Fundamental
Matrix, for an explanation of why F.T gives the inverse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.FundamentalMatrixTransform.residuals">
<span class="sig-name descname"><span class="pre">residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L440-L468"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.residuals" title="Link to this definition">#</a></dt>
<dd><p>Compute the Sampson distance.</p>
<p>The Sampson distance is the first approximation to the geometric error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N,) array</span></dt><dd><p>Sampson distance.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.PiecewiseAffineTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">PiecewiseAffineTransform</span></span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1083-L1195"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_GeometricTransform</span></code></p>
<p>Piecewise affine transformation.</p>
<p>Control points are used to define the mapping. The transform is based on
a Delaunay triangulation of the points to form a mesh. Each triangle is
used to find a local affine transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affines</strong><span class="classifier">list of AffineTransform objects</span></dt><dd><p>Affine transformations for each triangle in the mesh.</p>
</dd>
<dt><strong>inverse_affines</strong><span class="classifier">list of AffineTransform objects</span></dt><dd><p>Inverse affine transformations for each triangle in the mesh.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.PiecewiseAffineTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1099-L1103"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.__init__" title="Link to this definition">#</a></dt>
<dd><div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use the Piecewise Affine Transformation."><img alt="" src="../_images/sphx_glr_plot_piecewise_affine_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_piecewise_affine.html#sphx-glr-auto-examples-transform-plot-piecewise-affine-py"><span class="std std-ref">Piecewise Affine Transformation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Piecewise Affine Transformation</div>
</div></div></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.PiecewiseAffineTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1105-L1150"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.estimate" title="Link to this definition">#</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, D) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, D) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if all pieces of the model are successfully estimated.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.PiecewiseAffineTransform.inverse">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inverse</span></span><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.inverse" title="Link to this definition">#</a></dt>
<dd><p>Return a transform object representing the inverse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.PiecewiseAffineTransform.residuals">
<span class="sig-name descname"><span class="pre">residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L206-L225"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.residuals" title="Link to this definition">#</a></dt>
<dd><p>Determine residuals of transformed destination coordinates.</p>
<p>For each transformed source coordinate the Euclidean distance to the
respective destination coordinate is determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N,) array</span></dt><dd><p>Residual for coordinate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.PolynomialTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">PolynomialTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1532-L1704"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_GeometricTransform</span></code></p>
<p>2D polynomial transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
<span class="n">Y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(2, N) array_like, optional</span></dt><dd><p>Polynomial coefficients where <em class="xref py py-obj">N * 2 = (order + 1) * (order + 2)</em>. So,
a_ji is defined in <em class="xref py py-obj">params[0, :]</em> and b_ji in <em class="xref py py-obj">params[1, :]</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(2, N) array</span></dt><dd><p>Polynomial coefficients where <em class="xref py py-obj">N * 2 = (order + 1) * (order + 2)</em>. So,
a_ji is defined in <em class="xref py py-obj">params[0, :]</em> and b_ji in <em class="xref py py-obj">params[1, :]</em>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.PolynomialTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1554-L1566"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform.__init__" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.PolynomialTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1568-L1664"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform.estimate" title="Link to this definition">#</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
<span class="n">Y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span> <span class="n">x</span> <span class="n">y</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">...</span> <span class="mi">0</span> <span class="o">...</span>             <span class="mi">0</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="o">...</span>                 <span class="mi">0</span> <span class="mi">1</span> <span class="n">x</span> <span class="n">y</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a00</span> <span class="n">a10</span> <span class="n">a11</span> <span class="n">a20</span> <span class="n">a21</span> <span class="n">a22</span> <span class="o">...</span> <span class="n">ann</span>
       <span class="n">b00</span> <span class="n">b10</span> <span class="n">b11</span> <span class="n">b20</span> <span class="n">b21</span> <span class="n">b22</span> <span class="o">...</span> <span class="n">bnn</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<p>Weights can be applied to each pair of corresponding points to
indicate, particularly in an overdetermined system, if point pairs have
higher or lower confidence or uncertainties associated with them. From
the matrix treatment of least squares problems, these weight values are
normalised, square-rooted, then built into a diagonal matrix, by which
A is multiplied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Polynomial order (number of coefficients is order + 1).</p>
</dd>
<dt><strong>weights</strong><span class="classifier">(N,) array_like, optional</span></dt><dd><p>Relative weight values for each pair of points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.PolynomialTransform.inverse">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inverse</span></span><a class="headerlink" href="#skimage.transform.PolynomialTransform.inverse" title="Link to this definition">#</a></dt>
<dd><p>Return a transform object representing the inverse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.PolynomialTransform.residuals">
<span class="sig-name descname"><span class="pre">residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L206-L225"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform.residuals" title="Link to this definition">#</a></dt>
<dd><p>Determine residuals of transformed destination coordinates.</p>
<p>For each transformed source coordinate the Euclidean distance to the
respective destination coordinate is determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N,) array</span></dt><dd><p>Residual for coordinate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.ProjectiveTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">ProjectiveTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L618-L877"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_GeometricTransform</span></code></p>
<p>Projective transformation.</p>
<p>Apply a projective transformation (homography) on coordinates.</p>
<p>For each homogeneous coordinate <span class="math notranslate nohighlight">\(\mathbf{x} = [x, y, 1]^T\)</span>, its
target position is calculated by multiplying with the given matrix,
<span class="math notranslate nohighlight">\(H\)</span>, to give <span class="math notranslate nohighlight">\(H \mathbf{x}\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">c0</span> <span class="n">c1</span> <span class="mi">1</span> <span class="p">]]</span><span class="o">.</span>
</pre></div>
</div>
<p>E.g., to rotate by theta degrees clockwise, the matrix should be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>  <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>            <span class="mi">0</span>         <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>or, to translate x by 10 and y by 20:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">10</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">20</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">]]</span><span class="o">.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(D+1, D+1) array_like, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
<dt><strong>dimensionality</strong><span class="classifier">int, optional</span></dt><dd><p>The number of dimensions of the transform. This is ignored if
<code class="docutils literal notranslate"><span class="pre">matrix</span></code> is not None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(D+1, D+1) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.ProjectiveTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L658-L668"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform.__init__" title="Link to this definition">#</a></dt>
<dd><div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In this example, we will see how to use geometric transformations in the context of image proce..."><img alt="" src="../_images/sphx_glr_plot_geometric_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_geometric.html#sphx-glr-auto-examples-transform-plot-geometric-py"><span class="std std-ref">Using geometric transformations</span></a></p>
  <div class="sphx-glr-thumbnail-title">Using geometric transformations</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Homographies are transformations of a Euclidean space that preserve the alignment of points. Sp..."><img alt="" src="../_images/sphx_glr_plot_transform_types_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_transform_types.html#sphx-glr-auto-examples-transform-plot-transform-types-py"><span class="std std-ref">Types of homographies</span></a></p>
  <div class="sphx-glr-thumbnail-title">Types of homographies</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this simplified example we first generate two synthetic images as if they were taken from di..."><img alt="" src="../_images/sphx_glr_plot_matching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_matching.html#sphx-glr-auto-examples-transform-plot-matching-py"><span class="std std-ref">Robust matching using RANSAC</span></a></p>
  <div class="sphx-glr-thumbnail-title">Robust matching using RANSAC</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates how a set of images can be assembled under the hypothesis of rigid bo..."><img alt="" src="../_images/sphx_glr_plot_stitching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_stitching.html#sphx-glr-auto-examples-registration-plot-stitching-py"><span class="std std-ref">Assemble images with simple image stitching</span></a></p>
  <div class="sphx-glr-thumbnail-title">Assemble images with simple image stitching</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Detect corner points using the Harris corner detector and determine the subpixel position of co..."><img alt="" src="../_images/sphx_glr_plot_corner_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_corner.html#sphx-glr-auto-examples-features-detection-plot-corner-py"><span class="std std-ref">Corner detection</span></a></p>
  <div class="sphx-glr-thumbnail-title">Corner detection</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="The CENSURE feature detector is a scale-invariant center-surround detector (CENSURE) that claim..."><img alt="" src="../_images/sphx_glr_plot_censure_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_censure.html#sphx-glr-auto-examples-features-detection-plot-censure-py"><span class="std std-ref">CENSURE feature detector</span></a></p>
  <div class="sphx-glr-thumbnail-title">CENSURE feature detector</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the ORB feature detection and binary description algorithm. It uses a..."><img alt="" src="../_images/sphx_glr_plot_orb_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_orb.html#sphx-glr-auto-examples-features-detection-plot-orb-py"><span class="std std-ref">ORB feature detector and binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">ORB feature detector and binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the BRIEF binary description algorithm. The descriptor consists of re..."><img alt="" src="../_images/sphx_glr_plot_brief_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_brief.html#sphx-glr-auto-examples-features-detection-plot-brief-py"><span class="std std-ref">BRIEF binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">BRIEF binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the SIFT feature detection and its description algorithm."><img alt="" src="../_images/sphx_glr_plot_sift_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_sift.html#sphx-glr-auto-examples-features-detection-plot-sift-py"><span class="std std-ref">SIFT feature detector and descriptor extractor</span></a></p>
  <div class="sphx-glr-thumbnail-title">SIFT feature detector and descriptor extractor</div>
</div></div></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.ProjectiveTransform.dimensionality">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dimensionality</span></span><a class="headerlink" href="#skimage.transform.ProjectiveTransform.dimensionality" title="Link to this definition">#</a></dt>
<dd><p>The dimensionality of the transformation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.ProjectiveTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L717-L839"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform.estimate" title="Link to this definition">#</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">c0</span> <span class="n">c1</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<p>Weights can be applied to each pair of corresponding points to
indicate, particularly in an overdetermined system, if point pairs have
higher or lower confidence or uncertainties associated with them. From
the matrix treatment of least squares problems, these weight values are
normalised, square-rooted, then built into a diagonal matrix, by which
A is multiplied.</p>
<p>In case of the affine transformation the coefficients c0 and c1 are 0.
Thus the system of equations is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">(N,) array_like, optional</span></dt><dd><p>Relative weight values for each pair of points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.ProjectiveTransform.inverse">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inverse</span></span><a class="headerlink" href="#skimage.transform.ProjectiveTransform.inverse" title="Link to this definition">#</a></dt>
<dd><p>Return a transform object representing the inverse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.ProjectiveTransform.residuals">
<span class="sig-name descname"><span class="pre">residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L206-L225"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform.residuals" title="Link to this definition">#</a></dt>
<dd><p>Determine residuals of transformed destination coordinates.</p>
<p>For each transformed source coordinate the Euclidean distance to the
respective destination coordinate is determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N,) array</span></dt><dd><p>Residual for coordinate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.SimilarityTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">SimilarityTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1404-L1529"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.SimilarityTransform" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#skimage.transform.EuclideanTransform" title="skimage.transform._geometric.EuclideanTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">EuclideanTransform</span></code></a></p>
<p>Similarity transformation.</p>
<p>Has the following form in 2D:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">a1</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">s</span></code> is a scale factor and the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span> <span class="o">-</span><span class="n">b0</span>  <span class="n">a1</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">a0</span>  <span class="n">b1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>   <span class="mi">1</span> <span class="p">]]</span>
</pre></div>
</div>
<p>The similarity transformation extends the Euclidean transformation with a
single scaling factor in addition to the rotation and translation
parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(dim+1, dim+1) array_like, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">float, optional</span></dt><dd><p>Scale factor. Implemented only for 2D and 3D.</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Rotation angle, clockwise, as radians.
Implemented only for 2D and 3D. For 3D, this is given in ZYX Euler
angles.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(dim,) array_like, optional</span></dt><dd><p>x, y[, z] translation parameters. Implemented only for 2D and 3D.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(dim+1, dim+1) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.SimilarityTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1445-L1492"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.SimilarityTransform.__init__" title="Link to this definition">#</a></dt>
<dd><div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In this example, we will see how to use geometric transformations in the context of image proce..."><img alt="" src="../_images/sphx_glr_plot_geometric_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_geometric.html#sphx-glr-auto-examples-transform-plot-geometric-py"><span class="std std-ref">Using geometric transformations</span></a></p>
  <div class="sphx-glr-thumbnail-title">Using geometric transformations</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Homographies are transformations of a Euclidean space that preserve the alignment of points. Sp..."><img alt="" src="../_images/sphx_glr_plot_transform_types_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_transform_types.html#sphx-glr-auto-examples-transform-plot-transform-types-py"><span class="std std-ref">Types of homographies</span></a></p>
  <div class="sphx-glr-thumbnail-title">Types of homographies</div>
</div></div></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.SimilarityTransform.dimensionality">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dimensionality</span></span><a class="headerlink" href="#skimage.transform.SimilarityTransform.dimensionality" title="Link to this definition">#</a></dt>
<dd><p>The dimensionality of the transformation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.SimilarityTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1494-L1519"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.SimilarityTransform.estimate" title="Link to this definition">#</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.SimilarityTransform.inverse">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inverse</span></span><a class="headerlink" href="#skimage.transform.SimilarityTransform.inverse" title="Link to this definition">#</a></dt>
<dd><p>Return a transform object representing the inverse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.SimilarityTransform.residuals">
<span class="sig-name descname"><span class="pre">residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L206-L225"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.SimilarityTransform.residuals" title="Link to this definition">#</a></dt>
<dd><p>Determine residuals of transformed destination coordinates.</p>
<p>For each transformed source coordinate the Euclidean distance to the
respective destination coordinate is determined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N,) array</span></dt><dd><p>Residual for coordinate.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.SimilarityTransform.rotation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rotation</span></span><a class="headerlink" href="#skimage.transform.SimilarityTransform.rotation" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.SimilarityTransform.scale">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">scale</span></span><a class="headerlink" href="#skimage.transform.SimilarityTransform.scale" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.SimilarityTransform.translation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">translation</span></span><a class="headerlink" href="#skimage.transform.SimilarityTransform.translation" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.ThinPlateSplineTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">ThinPlateSplineTransform</span></span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_thin_plate_splines.py#L7-L188"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.ThinPlateSplineTransform" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Thin-plate spline transformation.</p>
<p>Given two matching sets of points, source and destination, this class
estimates the thin-plate spline (TPS) transformation which transforms
each point in source into its destination counterpart.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rffb9a3ce8527-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Bookstein, Fred L. “Principal warps: Thin-plate splines and the
decomposition of deformations,” IEEE Transactions on pattern analysis
and machine intelligence 11.6 (1989): 567–585.
DOI:<em class="xref py py-obj">10.1109/34.24792</em>
<a class="reference external" href="https://user.engineering.uiowa.edu/~aip/papers/bookstein-89.pdf">https://user.engineering.uiowa.edu/~aip/papers/bookstein-89.pdf</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">skimage</span> <span class="k">as</span> <span class="nn">ski</span>
</pre></div>
</div>
<p>Define source and destination control points such that they simulate
rotating by 90 degrees and generate a meshgrid from them:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
</pre></div>
</div>
<p>Estimate the transformation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tps</span> <span class="o">=</span> <span class="n">ski</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">ThinPlateSplineTransform</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tps</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Appyling the transformation to <em class="xref py py-obj">src</em> approximates <em class="xref py py-obj">dst</em>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">tps</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>
<span class="go">array([[5., 0.],</span>
<span class="go">       [0., 0.],</span>
<span class="go">       [0., 5.],</span>
<span class="go">       [5., 5.]])</span>
</pre></div>
</div>
<p>Create a meshgrid to apply the transformation to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 1, 1, 1],</span>
<span class="go">       [2, 2, 2, 2, 2],</span>
<span class="go">       [3, 3, 3, 3, 3],</span>
<span class="go">       [4, 4, 4, 4, 4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformed</span> <span class="o">=</span> <span class="n">tps</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">transformed</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [0, 1, 2, 3, 4],</span>
<span class="go">       [0, 1, 2, 3, 4],</span>
<span class="go">       [0, 1, 2, 3, 4],</span>
<span class="go">       [0, 1, 2, 3, 4]])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Coordinates of control points in source image.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.ThinPlateSplineTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_thin_plate_splines.py#L71-L74"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.ThinPlateSplineTransform.__init__" title="Link to this definition">#</a></dt>
<dd><div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="To warp an image, we start with a set of source and target coordinates. The goal is to deform t..."><img alt="" src="../_images/sphx_glr_plot_tps_deformation_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_tps_deformation.html#sphx-glr-auto-examples-transform-plot-tps-deformation-py"><span class="std std-ref">Use thin-plate splines for image warping</span></a></p>
  <div class="sphx-glr-thumbnail-title">Use thin-plate splines for image warping</div>
</div></div></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.ThinPlateSplineTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_thin_plate_splines.py#L110-L155"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.ThinPlateSplineTransform.estimate" title="Link to this definition">#</a></dt>
<dd><p>Estimate optimal spline mappings between source and destination points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Control points at source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Control points at destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>success: bool</dt><dd><p>True indicates that the estimation was successful.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The number N of source and destination points must match.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.ThinPlateSplineTransform.inverse">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inverse</span></span><a class="headerlink" href="#skimage.transform.ThinPlateSplineTransform.inverse" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>


                </article>
              
              
              
              
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.downscale_local_mean"><code class="docutils literal notranslate"><span class="pre">downscale_local_mean()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.estimate_transform"><code class="docutils literal notranslate"><span class="pre">estimate_transform()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.frt2"><code class="docutils literal notranslate"><span class="pre">frt2()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.hough_circle"><code class="docutils literal notranslate"><span class="pre">hough_circle()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.hough_circle_peaks"><code class="docutils literal notranslate"><span class="pre">hough_circle_peaks()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.hough_ellipse"><code class="docutils literal notranslate"><span class="pre">hough_ellipse()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.hough_line"><code class="docutils literal notranslate"><span class="pre">hough_line()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.hough_line_peaks"><code class="docutils literal notranslate"><span class="pre">hough_line_peaks()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.ifrt2"><code class="docutils literal notranslate"><span class="pre">ifrt2()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.integral_image"><code class="docutils literal notranslate"><span class="pre">integral_image()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.integrate"><code class="docutils literal notranslate"><span class="pre">integrate()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.iradon"><code class="docutils literal notranslate"><span class="pre">iradon()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.iradon_sart"><code class="docutils literal notranslate"><span class="pre">iradon_sart()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.matrix_transform"><code class="docutils literal notranslate"><span class="pre">matrix_transform()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.order_angles_golden_ratio"><code class="docutils literal notranslate"><span class="pre">order_angles_golden_ratio()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.probabilistic_hough_line"><code class="docutils literal notranslate"><span class="pre">probabilistic_hough_line()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.pyramid_expand"><code class="docutils literal notranslate"><span class="pre">pyramid_expand()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.pyramid_gaussian"><code class="docutils literal notranslate"><span class="pre">pyramid_gaussian()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.pyramid_laplacian"><code class="docutils literal notranslate"><span class="pre">pyramid_laplacian()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.pyramid_reduce"><code class="docutils literal notranslate"><span class="pre">pyramid_reduce()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.radon"><code class="docutils literal notranslate"><span class="pre">radon()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.rescale"><code class="docutils literal notranslate"><span class="pre">rescale()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.resize"><code class="docutils literal notranslate"><span class="pre">resize()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.resize_local_mean"><code class="docutils literal notranslate"><span class="pre">resize_local_mean()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.rotate"><code class="docutils literal notranslate"><span class="pre">rotate()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.swirl"><code class="docutils literal notranslate"><span class="pre">swirl()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.warp"><code class="docutils literal notranslate"><span class="pre">warp()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.warp_coords"><code class="docutils literal notranslate"><span class="pre">warp_coords()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.warp_polar"><code class="docutils literal notranslate"><span class="pre">warp_polar()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.AffineTransform"><code class="docutils literal notranslate"><span class="pre">AffineTransform</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.AffineTransform.__init__"><code class="docutils literal notranslate"><span class="pre">AffineTransform.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.AffineTransform.dimensionality"><code class="docutils literal notranslate"><span class="pre">AffineTransform.dimensionality</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.AffineTransform.estimate"><code class="docutils literal notranslate"><span class="pre">AffineTransform.estimate()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.AffineTransform.inverse"><code class="docutils literal notranslate"><span class="pre">AffineTransform.inverse</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.AffineTransform.residuals"><code class="docutils literal notranslate"><span class="pre">AffineTransform.residuals()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.AffineTransform.rotation"><code class="docutils literal notranslate"><span class="pre">AffineTransform.rotation</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.AffineTransform.scale"><code class="docutils literal notranslate"><span class="pre">AffineTransform.scale</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.AffineTransform.shear"><code class="docutils literal notranslate"><span class="pre">AffineTransform.shear</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.AffineTransform.translation"><code class="docutils literal notranslate"><span class="pre">AffineTransform.translation</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.EssentialMatrixTransform"><code class="docutils literal notranslate"><span class="pre">EssentialMatrixTransform</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.EssentialMatrixTransform.__init__"><code class="docutils literal notranslate"><span class="pre">EssentialMatrixTransform.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.EssentialMatrixTransform.estimate"><code class="docutils literal notranslate"><span class="pre">EssentialMatrixTransform.estimate()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.EssentialMatrixTransform.inverse"><code class="docutils literal notranslate"><span class="pre">EssentialMatrixTransform.inverse</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.EssentialMatrixTransform.residuals"><code class="docutils literal notranslate"><span class="pre">EssentialMatrixTransform.residuals()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.EuclideanTransform"><code class="docutils literal notranslate"><span class="pre">EuclideanTransform</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.EuclideanTransform.__init__"><code class="docutils literal notranslate"><span class="pre">EuclideanTransform.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.EuclideanTransform.dimensionality"><code class="docutils literal notranslate"><span class="pre">EuclideanTransform.dimensionality</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.EuclideanTransform.estimate"><code class="docutils literal notranslate"><span class="pre">EuclideanTransform.estimate()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.EuclideanTransform.inverse"><code class="docutils literal notranslate"><span class="pre">EuclideanTransform.inverse</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.EuclideanTransform.residuals"><code class="docutils literal notranslate"><span class="pre">EuclideanTransform.residuals()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.EuclideanTransform.rotation"><code class="docutils literal notranslate"><span class="pre">EuclideanTransform.rotation</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.EuclideanTransform.translation"><code class="docutils literal notranslate"><span class="pre">EuclideanTransform.translation</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.FundamentalMatrixTransform"><code class="docutils literal notranslate"><span class="pre">FundamentalMatrixTransform</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.FundamentalMatrixTransform.__init__"><code class="docutils literal notranslate"><span class="pre">FundamentalMatrixTransform.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.FundamentalMatrixTransform.estimate"><code class="docutils literal notranslate"><span class="pre">FundamentalMatrixTransform.estimate()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.FundamentalMatrixTransform.inverse"><code class="docutils literal notranslate"><span class="pre">FundamentalMatrixTransform.inverse</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.FundamentalMatrixTransform.residuals"><code class="docutils literal notranslate"><span class="pre">FundamentalMatrixTransform.residuals()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.PiecewiseAffineTransform"><code class="docutils literal notranslate"><span class="pre">PiecewiseAffineTransform</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.PiecewiseAffineTransform.__init__"><code class="docutils literal notranslate"><span class="pre">PiecewiseAffineTransform.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.PiecewiseAffineTransform.estimate"><code class="docutils literal notranslate"><span class="pre">PiecewiseAffineTransform.estimate()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.PiecewiseAffineTransform.inverse"><code class="docutils literal notranslate"><span class="pre">PiecewiseAffineTransform.inverse</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.PiecewiseAffineTransform.residuals"><code class="docutils literal notranslate"><span class="pre">PiecewiseAffineTransform.residuals()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.PolynomialTransform"><code class="docutils literal notranslate"><span class="pre">PolynomialTransform</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.PolynomialTransform.__init__"><code class="docutils literal notranslate"><span class="pre">PolynomialTransform.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.PolynomialTransform.estimate"><code class="docutils literal notranslate"><span class="pre">PolynomialTransform.estimate()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.PolynomialTransform.inverse"><code class="docutils literal notranslate"><span class="pre">PolynomialTransform.inverse</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.PolynomialTransform.residuals"><code class="docutils literal notranslate"><span class="pre">PolynomialTransform.residuals()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.ProjectiveTransform"><code class="docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.ProjectiveTransform.__init__"><code class="docutils literal notranslate"><span class="pre">ProjectiveTransform.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.ProjectiveTransform.dimensionality"><code class="docutils literal notranslate"><span class="pre">ProjectiveTransform.dimensionality</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.ProjectiveTransform.estimate"><code class="docutils literal notranslate"><span class="pre">ProjectiveTransform.estimate()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.ProjectiveTransform.inverse"><code class="docutils literal notranslate"><span class="pre">ProjectiveTransform.inverse</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.ProjectiveTransform.residuals"><code class="docutils literal notranslate"><span class="pre">ProjectiveTransform.residuals()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.SimilarityTransform"><code class="docutils literal notranslate"><span class="pre">SimilarityTransform</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.SimilarityTransform.__init__"><code class="docutils literal notranslate"><span class="pre">SimilarityTransform.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.SimilarityTransform.dimensionality"><code class="docutils literal notranslate"><span class="pre">SimilarityTransform.dimensionality</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.SimilarityTransform.estimate"><code class="docutils literal notranslate"><span class="pre">SimilarityTransform.estimate()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.SimilarityTransform.inverse"><code class="docutils literal notranslate"><span class="pre">SimilarityTransform.inverse</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.SimilarityTransform.residuals"><code class="docutils literal notranslate"><span class="pre">SimilarityTransform.residuals()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.SimilarityTransform.rotation"><code class="docutils literal notranslate"><span class="pre">SimilarityTransform.rotation</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.SimilarityTransform.scale"><code class="docutils literal notranslate"><span class="pre">SimilarityTransform.scale</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.SimilarityTransform.translation"><code class="docutils literal notranslate"><span class="pre">SimilarityTransform.translation</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.ThinPlateSplineTransform"><code class="docutils literal notranslate"><span class="pre">ThinPlateSplineTransform</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.ThinPlateSplineTransform.__init__"><code class="docutils literal notranslate"><span class="pre">ThinPlateSplineTransform.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.ThinPlateSplineTransform.estimate"><code class="docutils literal notranslate"><span class="pre">ThinPlateSplineTransform.estimate()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.transform.ThinPlateSplineTransform.inverse"><code class="docutils literal notranslate"><span class="pre">ThinPlateSplineTransform.inverse</span></code></a></li>
</ul>
</li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">

  <div class="tocsection sourcelink">
    <a href="../_sources/api/skimage.transform.rst.txt">
      <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2013-2024, the scikit-image team.
      <br/>
    
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    <br/>
  </p>
</div>
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.4.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>