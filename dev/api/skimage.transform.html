
<!DOCTYPE html>
<html lang="en">
<head>
        <title>Module: transform &mdash; skimage v0.20.0.dev0 docs</title><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../_static/css/custom.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
        <link rel="stylesheet" href="../_static/none" type="text/css" />
        <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
        <link rel="stylesheet" href="../_static/plot_directive.css" type="text/css" />
        <link rel="stylesheet" href="../_static/sg_gallery.css" type="text/css" />
        <link rel="stylesheet" href="../_static/sg_gallery-binder.css" type="text/css" />
        <link rel="stylesheet" href="../_static/sg_gallery-dataframe.css" type="text/css" />
        <link rel="stylesheet" href="../_static/sg_gallery-rendered-html.css" type="text/css" />
    
    <script src="https://code.jquery.com/jquery-latest.js"></script>
    <script src="../_static/js/bootstrap.min.js"></script>
    <script src="../_static/js/togglebutton.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.20.0.dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        LINK_SUFFIX: '.html',
        SOURCELINK_SUFFIX: '.txt',
        HAS_SOURCE:  true
      };
    </script>
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <link rel="index" title="Index" href="../genindex.html" />
        <link rel="search" title="Search" href="../search.html" />
        <link rel="top" title="skimage v0.20.0.dev0 docs" href="../index.html" />
        <link rel="up" title="API Reference for skimage 0.20.0.dev0" href="api.html" />
        <link rel="next" title="Module: util" href="skimage.util.html" />
        <link rel="prev" title="Module: segmentation" href="skimage.segmentation.html" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="shortcut icon" href="../_static/favicon.ico">
    <!-- Plausible analytics -->
    <script async defer data-domain="scikit-image.org" src="https://plausible.io/js/plausible.outbound-links.js"></script>
</head>
<body class="container">
    <a href="https://scikit-image.org" class="logo"><img src="../_static/img/logo.png" alt=""></a>
    <div class="clearfix"></div>
    <div class="navbar">
        <div class="navbar-inner">
            <ul class="nav">
                <li><a href="/docs/stable/install.html">Installation</a></li>
<li><a href="../auto_examples/index.html">Gallery</a></li>
<li><a href="../index.html">Documentation</a></li>
<li><a href="/community_guidelines.html">Community</a></li>

<li><a href="https://github.com/scikit-image/scikit-image">
    <img src="../_static/GitHub-Mark-32px.png"
        style="height: 15px; width: 15px;
               display: inline; float: none;
               padding-bottom: 3px;">
    Source</a>
</li>
            </ul>
        </div>
    </div>
    <div class="row">
        <div class="span3"><div style="padding-bottom: 3em">
  <form class="navbar-form pull-right" action="../search.html" method="get">
    <input type="text" class="search span3" name="q" placeholder="Search documentation ...">
    <input type="hidden" name="check_keywords" value="yes" >
    <input type="hidden" name="area" value="default" >
  </form>
</div><!-- 
        <h4 class="sidebar-box-heading">Contents</h4>
        <div class="well sidebar-box toc">
            <ul class="nav nav-list">
<li><a class="reference internal" href="#">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">transform</span></code></a><ul class="nav nav-list">
<li><a class="reference internal" href="#downscale-local-mean">downscale_local_mean</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-downscale-local-mean">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.downscale_local_mean</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#estimate-transform">estimate_transform</a></li>
<li><a class="reference internal" href="#frt2">frt2</a></li>
<li><a class="reference internal" href="#hough-circle">hough_circle</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-hough-circle">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_circle</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hough-circle-peaks">hough_circle_peaks</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-hough-circle-peaks">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_circle_peaks</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hough-ellipse">hough_ellipse</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-hough-ellipse">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_ellipse</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hough-line">hough_line</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-hough-line">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_line</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hough-line-peaks">hough_line_peaks</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-hough-line-peaks">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_line_peaks</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ifrt2">ifrt2</a></li>
<li><a class="reference internal" href="#integral-image">integral_image</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-integral-image">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.integral_image</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#integrate">integrate</a></li>
<li><a class="reference internal" href="#iradon">iradon</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-iradon">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.iradon</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#iradon-sart">iradon_sart</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-iradon-sart">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.iradon_sart</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#matrix-transform">matrix_transform</a></li>
<li><a class="reference internal" href="#order-angles-golden-ratio">order_angles_golden_ratio</a></li>
<li><a class="reference internal" href="#probabilistic-hough-line">probabilistic_hough_line</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-probabilistic-hough-line">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.probabilistic_hough_line</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pyramid-expand">pyramid_expand</a></li>
<li><a class="reference internal" href="#pyramid-gaussian">pyramid_gaussian</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-pyramid-gaussian">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.pyramid_gaussian</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pyramid-laplacian">pyramid_laplacian</a></li>
<li><a class="reference internal" href="#pyramid-reduce">pyramid_reduce</a></li>
<li><a class="reference internal" href="#radon">radon</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-radon">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.radon</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#rescale">rescale</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-rescale">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.rescale</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#resize">resize</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-resize">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.resize</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#resize-local-mean">resize_local_mean</a></li>
<li><a class="reference internal" href="#rotate">rotate</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-rotate">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.rotate</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#swirl">swirl</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-swirl">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.swirl</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#warp">warp</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-warp">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#warp-coords">warp_coords</a></li>
<li><a class="reference internal" href="#warp-polar">warp_polar</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-warp-polar">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.warp_polar</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#affinetransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-affinetransform">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.AffineTransform</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#essentialmatrixtransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">EssentialMatrixTransform</span></code></a></li>
<li><a class="reference internal" href="#euclideantransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">EuclideanTransform</span></code></a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-euclideantransform">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.EuclideanTransform</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fundamentalmatrixtransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">FundamentalMatrixTransform</span></code></a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-fundamentalmatrixtransform">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.FundamentalMatrixTransform</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#piecewiseaffinetransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseAffineTransform</span></code></a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-piecewiseaffinetransform">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.PiecewiseAffineTransform</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#polynomialtransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolynomialTransform</span></code></a></li>
<li><a class="reference internal" href="#projectivetransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-projectivetransform">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.ProjectiveTransform</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#similaritytransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimilarityTransform</span></code></a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-similaritytransform">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.SimilarityTransform</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>


 --><div class="well">
    <strong>Docs for 0.20.0.dev0<br></strong>

    <a id="other">All versions</a>

    <ul id="versionList" style="display: none;">
        <script src="../../dev/_static/docversions.js"></script>
        <script type="text/javascript">
            insert_version_links();
        </script>
    </ul>

 </div>

<script type="text/javascript">
	$("#other").click(function() {
		$("#versionList").toggle();
	});
</script>
        </div>
        <div class="span9" class="body" role="main">
            
  <section id="module-skimage.transform">
<span id="module-transform"></span><h1>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">transform</span></code><a class="headerlink" href="#module-skimage.transform" title="Permalink to this heading">¶</a></h1>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.downscale_local_mean</span></code></a>(...)</p></td>
<td><p>Down-sample N-dimensional image by local averaging.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.estimate_transform" title="skimage.transform.estimate_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.estimate_transform</span></code></a>(ttype, ...)</p></td>
<td><p>Estimate 2D geometric transformation parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.frt2</span></code></a>(a)</p></td>
<td><p>Compute the 2-dimensional finite radon transform (FRT) for an n x n integer array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.hough_circle" title="skimage.transform.hough_circle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_circle</span></code></a>(image, radius)</p></td>
<td><p>Perform a circular Hough transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.hough_circle_peaks" title="skimage.transform.hough_circle_peaks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_circle_peaks</span></code></a>(...[, ...])</p></td>
<td><p>Return peaks in a circle Hough transform.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.hough_ellipse" title="skimage.transform.hough_ellipse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_ellipse</span></code></a>(image[, ...])</p></td>
<td><p>Perform an elliptical Hough transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_line</span></code></a>(image[, theta])</p></td>
<td><p>Perform a straight line Hough transform.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.hough_line_peaks" title="skimage.transform.hough_line_peaks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_line_peaks</span></code></a>(hspace, ...)</p></td>
<td><p>Return peaks in a straight line Hough transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.ifrt2</span></code></a>(a)</p></td>
<td><p>Compute the 2-dimensional inverse finite radon transform (iFRT) for an (n+1) x n integer array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.integral_image" title="skimage.transform.integral_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.integral_image</span></code></a>(image, *[, ...])</p></td>
<td><p>Integral image / summed area table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.integrate" title="skimage.transform.integrate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.integrate</span></code></a>(ii, start, end)</p></td>
<td><p>Use an integral image to integrate over a given window.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.iradon" title="skimage.transform.iradon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.iradon</span></code></a>(radon_image[, ...])</p></td>
<td><p>Inverse radon transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.iradon_sart" title="skimage.transform.iradon_sart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.iradon_sart</span></code></a>(radon_image[, ...])</p></td>
<td><p>Inverse radon transform.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.matrix_transform" title="skimage.transform.matrix_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.matrix_transform</span></code></a>(coords, ...)</p></td>
<td><p>Apply 2D matrix transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.order_angles_golden_ratio" title="skimage.transform.order_angles_golden_ratio"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.order_angles_golden_ratio</span></code></a>(theta)</p></td>
<td><p>Order angles to reduce the amount of correlated information in subsequent projections.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.probabilistic_hough_line" title="skimage.transform.probabilistic_hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.probabilistic_hough_line</span></code></a>(image)</p></td>
<td><p>Return lines from a progressive probabilistic line Hough transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.pyramid_expand" title="skimage.transform.pyramid_expand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_expand</span></code></a>(image[, ...])</p></td>
<td><p>Upsample and then smooth image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.pyramid_gaussian" title="skimage.transform.pyramid_gaussian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_gaussian</span></code></a>(image[, ...])</p></td>
<td><p>Yield images of the Gaussian pyramid formed by the input image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.pyramid_laplacian" title="skimage.transform.pyramid_laplacian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_laplacian</span></code></a>(image[, ...])</p></td>
<td><p>Yield images of the laplacian pyramid formed by the input image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.pyramid_reduce" title="skimage.transform.pyramid_reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_reduce</span></code></a>(image[, ...])</p></td>
<td><p>Smooth and then downsample image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.radon" title="skimage.transform.radon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.radon</span></code></a>(image[, theta, ...])</p></td>
<td><p>Calculates the radon transform of an image given specified projection angles.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.rescale" title="skimage.transform.rescale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.rescale</span></code></a>(image, scale[, ...])</p></td>
<td><p>Scale image by a certain factor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.resize" title="skimage.transform.resize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.resize</span></code></a>(image, output_shape)</p></td>
<td><p>Resize image to match a certain size.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.resize_local_mean" title="skimage.transform.resize_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.resize_local_mean</span></code></a>(image, ...)</p></td>
<td><p>Resize an array with the local mean / bilinear scaling.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.rotate" title="skimage.transform.rotate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.rotate</span></code></a>(image, angle[, ...])</p></td>
<td><p>Rotate image by a certain angle around its center.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.swirl" title="skimage.transform.swirl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.swirl</span></code></a>(image[, center, ...])</p></td>
<td><p>Perform a swirl transformation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a>(image, inverse_map[, ...])</p></td>
<td><p>Warp an image according to a given coordinate transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.warp_coords" title="skimage.transform.warp_coords"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp_coords</span></code></a>(coord_map, shape)</p></td>
<td><p>Build the source coordinates for the output of a 2-D image warp.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.warp_polar" title="skimage.transform.warp_polar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp_polar</span></code></a>(image[, ...])</p></td>
<td><p>Remap image to polar or log-polar coordinates space.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.AffineTransform</span></code></a>([matrix, ...])</p></td>
<td><p>Affine transformation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.EssentialMatrixTransform" title="skimage.transform.EssentialMatrixTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.EssentialMatrixTransform</span></code></a>([...])</p></td>
<td><p>Essential matrix transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.EuclideanTransform" title="skimage.transform.EuclideanTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.EuclideanTransform</span></code></a>([...])</p></td>
<td><p>Euclidean transformation, also known as a rigid transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.FundamentalMatrixTransform" title="skimage.transform.FundamentalMatrixTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.FundamentalMatrixTransform</span></code></a>([...])</p></td>
<td><p>Fundamental matrix transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.PiecewiseAffineTransform" title="skimage.transform.PiecewiseAffineTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.PiecewiseAffineTransform</span></code></a>()</p></td>
<td><p>Piecewise affine transformation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.PolynomialTransform" title="skimage.transform.PolynomialTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.PolynomialTransform</span></code></a>([...])</p></td>
<td><p>2D polynomial transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.ProjectiveTransform</span></code></a>([...])</p></td>
<td><p>Projective transformation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.SimilarityTransform</span></code></a>([...])</p></td>
<td><p>Similarity transformation.</p></td>
</tr>
</tbody>
</table>
<section id="downscale-local-mean">
<h2>downscale_local_mean<a class="headerlink" href="#downscale-local-mean" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.downscale_local_mean">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">downscale_local_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L465-L509"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.downscale_local_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Down-sample N-dimensional image by local averaging.</p>
<p>The image is padded with <em class="xref py py-obj">cval</em> if it is not perfectly divisible by the
integer factors.</p>
<p>In contrast to interpolation in <a class="reference internal" href="#skimage.transform.resize" title="skimage.transform.resize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.resize</span></code></a> and
<a class="reference internal" href="#skimage.transform.rescale" title="skimage.transform.rescale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.rescale</span></code></a> this function calculates the local mean of
elements in each block of size <em class="xref py py-obj">factors</em> in the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>N-dimensional input image.</p>
</dd>
<dt><strong>factors</strong><span class="classifier">array_like</span></dt><dd><p>Array containing down-sampling integer factor along each axis.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Constant padding value if image is not perfectly divisible by the
integer factors.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Unused, but kept here for API consistency with the other transforms
in this module. (The local mean will never fall outside the range
of values in the input image, assuming the provided <em class="xref py py-obj">cval</em> also
falls within that range.)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Down-sampled image with same number of dimensions as input image.
For integer inputs, the output dtype will be <code class="docutils literal notranslate"><span class="pre">float64</span></code>.
See <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.mean.html#numpy.mean" title="(in NumPy v1.23)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.mean()</span></code></a> for details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3,  4],</span>
<span class="go">       [ 5,  6,  7,  8,  9],</span>
<span class="go">       [10, 11, 12, 13, 14]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">downscale_local_mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([[3.5, 4. ],</span>
<span class="go">       [5.5, 4.5]])</span>
</pre></div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-downscale-local-mean">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.downscale_local_mean</span></code><a class="headerlink" href="#examples-using-skimage-transform-downscale-local-mean" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Rescale operation resizes an image by a given scaling factor. The scaling factor can either be ..."><img alt="Rescale, resize, and downscale" src="../_images/sphx_glr_plot_rescale_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_rescale.html#sphx-glr-auto-examples-transform-plot-rescale-py"><span class="std std-ref">Rescale, resize, and downscale</span></a></p>
  <div class="sphx-glr-thumbnail-title">Rescale, resize, and downscale</div>
</div></div></section>
</section>
<section id="estimate-transform">
<h2>estimate_transform<a class="headerlink" href="#estimate-transform" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.estimate_transform">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">estimate_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ttype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1589-L1660"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.estimate_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate 2D geometric transformation parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ttype</strong><span class="classifier">{‘euclidean’, similarity’, ‘affine’, ‘piecewise-affine’,              ‘projective’, ‘polynomial’}</span></dt><dd><p>Type of transform.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">array_like or int</span></dt><dd><p>Function parameters (src, dst, n, angle):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>NAME / TTYPE        FUNCTION PARAMETERS
&#39;euclidean&#39;         `src, `dst`
&#39;similarity&#39;        `src, `dst`
&#39;affine&#39;            `src, `dst`
&#39;piecewise-affine&#39;  `src, `dst`
&#39;projective&#39;        `src, `dst`
&#39;polynomial&#39;        `src, `dst`, `order` (polynomial order,
                                          default order is 2)
</pre></div>
</div>
<p>Also see examples below.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>tform</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeometricTransform</span></code></span></dt><dd><p>Transform object containing the transformation parameters and providing
access to forward and inverse transformation functions.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">transform</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimate transformation parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">estimate_transform</span><span class="p">(</span><span class="s1">&#39;similarity&#39;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">tform</span><span class="p">(</span><span class="n">src</span><span class="p">)),</span> <span class="n">src</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># warp image using the estimated transformation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">inverse_map</span><span class="o">=</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span> 
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># create transformation with explicit parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform2</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># unite transformations, applied in order from left to right</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform3</span> <span class="o">=</span> <span class="n">tform</span> <span class="o">+</span> <span class="n">tform2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">tform3</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">tform2</span><span class="p">(</span><span class="n">tform</span><span class="p">(</span><span class="n">src</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="frt2">
<h2>frt2<a class="headerlink" href="#frt2" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.frt2">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">frt2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/finite_radon_transform.py#L12-L68"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.frt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 2-dimensional finite radon transform (FRT) for an n x n
integer array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>A 2-D square n x n integer array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>FRT</strong><span class="classifier">2-D ndarray</span></dt><dd><p>Finite Radon Transform array of (n+1) x n integer coefficients.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifrt2</span></code></a></dt><dd><p>The two-dimensional inverse FRT.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The FRT has a unique inverse if and only if n is prime. [FRT]
The idea for this algorithm is due to Vlad Negnevitski.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rdb433381c1a5-frt" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>FRT<span class="fn-bracket">]</span></span>
<p>A. Kingston and I. Svalbe, “Projective transforms on periodic
discrete image arrays,” in P. Hawkes (Ed), Advances in Imaging
and Electron Physics, 139 (2006)</p>
</div>
</div>
<p class="rubric">Examples</p>
<p>Generate a test image:
Use a prime number for the array dimensions</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SIZE</span> <span class="o">=</span> <span class="mi">59</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Finite Radon Transform:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">frt2</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="hough-circle">
<h2>hough_circle<a class="headerlink" href="#hough-circle" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.hough_circle">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">hough_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/hough_transform.py#L71-L112"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.hough_circle" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a circular Hough transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">scalar or sequence of scalars</span></dt><dd><p>Radii at which to compute the Hough transform.
Floats are converted to integers.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">boolean, optional (default True)</span></dt><dd><p>Normalize the accumulator with the number
of pixels used to draw the radius.</p>
</dd>
<dt><strong>full_output</strong><span class="classifier">boolean, optional (default False)</span></dt><dd><p>Extend the output size by twice the largest
radius in order to detect centers outside the
input picture.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>H</strong><span class="classifier">3D ndarray (radius index, (M + 2R, N + 2R) ndarray)</span></dt><dd><p>Hough transform accumulator for each radius.
R designates the larger radius if full_output is True.
Otherwise, R = 0.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough_circle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">circle_perimeter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">circle_perimeter</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">try_radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">hough_circle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">try_radii</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ridx</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">res</span><span class="p">),</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">try_radii</span><span class="p">[</span><span class="n">ridx</span><span class="p">]</span>
<span class="go">(25, 35, 23)</span>
</pre></div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-hough-circle">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_circle</span></code><a class="headerlink" href="#examples-using-skimage-transform-hough-circle" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a `method to detect straight lines &lt;https://en.wiki..."><img alt="Circular and Elliptical Hough Transforms" src="../_images/sphx_glr_plot_circular_elliptical_hough_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_circular_elliptical_hough_transform.html#sphx-glr-auto-examples-edges-plot-circular-elliptical-hough-transform-py"><span class="std std-ref">Circular and Elliptical Hough Transforms</span></a></p>
  <div class="sphx-glr-thumbnail-title">Circular and Elliptical Hough Transforms</div>
</div></div></section>
</section>
<section id="hough-circle-peaks">
<h2>hough_circle_peaks<a class="headerlink" href="#hough-circle-peaks" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.hough_circle_peaks">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">hough_circle_peaks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hspaces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radii</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_xdistance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_ydistance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_num_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/hough_transform.py#L274-L380"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.hough_circle_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return peaks in a circle Hough transform.</p>
<p>Identifies most prominent circles separated by certain distances in given
Hough spaces. Non-maximum suppression with different sizes is applied
separately in the first and second dimension of the Hough space to
identify peaks. For circles with different radius but close in distance,
only the one with highest peak is kept.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hspaces</strong><span class="classifier">(N, M) array</span></dt><dd><p>Hough spaces returned by the <a class="reference internal" href="#skimage.transform.hough_circle" title="skimage.transform.hough_circle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hough_circle</span></code></a> function.</p>
</dd>
<dt><strong>radii</strong><span class="classifier">(M,) array</span></dt><dd><p>Radii corresponding to Hough spaces.</p>
</dd>
<dt><strong>min_xdistance</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum distance separating centers in the x dimension.</p>
</dd>
<dt><strong>min_ydistance</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum distance separating centers in the y dimension.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Minimum intensity of peaks in each Hough space.
Default is <em class="xref py py-obj">0.5 * max(hspace)</em>.</p>
</dd>
<dt><strong>num_peaks</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of peaks in each Hough space. When the
number of peaks exceeds <em class="xref py py-obj">num_peaks</em>, only <em class="xref py py-obj">num_peaks</em>
coordinates based on peak intensity are considered for the
corresponding radius.</p>
</dd>
<dt><strong>total_num_peaks</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of peaks. When the number of peaks exceeds <em class="xref py py-obj">num_peaks</em>,
return <em class="xref py py-obj">num_peaks</em> coordinates based on peak intensity.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, normalize the accumulator by the radius to sort the prominent
peaks.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>accum, cx, cy, rad</strong><span class="classifier">tuple of array</span></dt><dd><p>Peak values in Hough space, x and y center coordinates and radii.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Circles with bigger radius have higher peaks in Hough space. If larger
circles are preferred over smaller ones, <em class="xref py py-obj">normalize</em> should be False.
Otherwise, circles will be returned in the order of decreasing voting
number.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">transform</span><span class="p">,</span> <span class="n">draw</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">120</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">radius</span><span class="p">,</span> <span class="n">x_0</span><span class="p">,</span> <span class="n">y_0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">draw</span><span class="o">.</span><span class="n">circle_perimeter</span><span class="p">(</span><span class="n">y_0</span><span class="p">,</span> <span class="n">x_0</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hspaces</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">hough_circle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">accum</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">rad</span> <span class="o">=</span> <span class="n">hough_circle_peaks</span><span class="p">(</span><span class="n">hspaces</span><span class="p">,</span> <span class="p">[</span><span class="n">radius</span><span class="p">,])</span>
</pre></div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-hough-circle-peaks">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_circle_peaks</span></code><a class="headerlink" href="#examples-using-skimage-transform-hough-circle-peaks" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a `method to detect straight lines &lt;https://en.wiki..."><img alt="Circular and Elliptical Hough Transforms" src="../_images/sphx_glr_plot_circular_elliptical_hough_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_circular_elliptical_hough_transform.html#sphx-glr-auto-examples-edges-plot-circular-elliptical-hough-transform-py"><span class="std std-ref">Circular and Elliptical Hough Transforms</span></a></p>
  <div class="sphx-glr-thumbnail-title">Circular and Elliptical Hough Transforms</div>
</div></div></section>
</section>
<section id="hough-ellipse">
<h2>hough_ellipse<a class="headerlink" href="#hough-ellipse" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.hough_ellipse">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">hough_ellipse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accuracy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/hough_transform.py#L115-L164"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.hough_ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an elliptical Hough transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">int, optional</span></dt><dd><p>Accumulator threshold value.</p>
</dd>
<dt><strong>accuracy</strong><span class="classifier">double, optional</span></dt><dd><p>Bin size on the minor axis used in the accumulator.</p>
</dd>
<dt><strong>min_size</strong><span class="classifier">int, optional</span></dt><dd><p>Minimal major axis length.</p>
</dd>
<dt><strong>max_size</strong><span class="classifier">int, optional</span></dt><dd><p>Maximal minor axis length.
If None, the value is set to the half of the smaller
image dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">ndarray with fields [(accumulator, yc, xc, a, b, orientation)].</span></dt><dd><p>Where <code class="docutils literal notranslate"><span class="pre">(yc,</span> <span class="pre">xc)</span></code> is the center, <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code> the major and minor
axes, respectively. The <em class="xref py py-obj">orientation</em> value follows
<a class="reference internal" href="skimage.draw.html#skimage.draw.ellipse_perimeter" title="skimage.draw.ellipse_perimeter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.draw.ellipse_perimeter</span></code></a> convention.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The accuracy must be chosen to produce a peak in the accumulator
distribution. In other words, a flat accumulator distribution with low
values may be caused by a too low bin size.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rf2ef66e2ec1f-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Xie, Yonghong, and Qiang Ji. “A new efficient ellipse detection
method.” Pattern Recognition, 2002. Proceedings. 16th International
Conference on. Vol. 2. IEEE, 2002</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough_ellipse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">ellipse_perimeter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">ellipse_perimeter</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">cc</span><span class="p">,</span> <span class="n">rr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">hough_ellipse</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[(10, 10.0, 10.0, 8.0, 6.0, 0.0)]</span>
</pre></div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-hough-ellipse">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_ellipse</span></code><a class="headerlink" href="#examples-using-skimage-transform-hough-ellipse" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a `method to detect straight lines &lt;https://en.wiki..."><img alt="Circular and Elliptical Hough Transforms" src="../_images/sphx_glr_plot_circular_elliptical_hough_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_circular_elliptical_hough_transform.html#sphx-glr-auto-examples-edges-plot-circular-elliptical-hough-transform-py"><span class="std std-ref">Circular and Elliptical Hough Transforms</span></a></p>
  <div class="sphx-glr-thumbnail-title">Circular and Elliptical Hough Transforms</div>
</div></div></section>
</section>
<section id="hough-line">
<h2>hough_line<a class="headerlink" href="#hough-line" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.hough_line">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">hough_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/hough_transform.py#L167-L224"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.hough_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a straight line Hough transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">1D ndarray of double, optional</span></dt><dd><p>Angles at which to compute the transform, in radians.
Defaults to a vector of 180 angles evenly spaced in the
range [-pi/2, pi/2).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>hspace</strong><span class="classifier">2-D ndarray of uint64</span></dt><dd><p>Hough transform accumulator.</p>
</dd>
<dt><strong>angles</strong><span class="classifier">ndarray</span></dt><dd><p>Angles at which the transform is computed, in radians.</p>
</dd>
<dt><strong>distances</strong><span class="classifier">ndarray</span></dt><dd><p>Distance values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The origin is the top left corner of the original image.
X and Y axis are horizontal and vertical edges respectively.
The distance is the minimal algebraic distance from the origin
to the detected line.
The angle accuracy can be improved by decreasing the step size in
the <em class="xref py py-obj">theta</em> array.</p>
<p class="rubric">Examples</p>
<p>Generate a test image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[:,</span> <span class="mi">65</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">45</span><span class="p">,</span> <span class="mi">35</span><span class="p">:</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">90</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.95</span>
</pre></div>
</div>
<p>Apply the Hough transform:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">hough_line</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough_line</span>
<span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">line</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">img</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span><span class="p">[:,</span> <span class="mi">65</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">45</span><span class="p">,</span> <span class="mi">35</span><span class="p">:</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">line</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">img</span><span class="p">[</span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="n">img</span> <span class="o">+=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.95</span>

<span class="n">out</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">hough_line</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

<span class="n">fix</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Input image&#39;</span><span class="p">)</span>

<span class="n">angle_step</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
<span class="n">d_step</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">angle_step</span><span class="p">,</span>
          <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">angle_step</span><span class="p">,</span>
          <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">d_step</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_step</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">bone</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Hough transform&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Angle (degree)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Distance (pixel)&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../plots/hough_tf.py">Source code</a>, <a class="reference external" href="../plots/hough_tf.png">png</a>, <a class="reference external" href="../plots/hough_tf.pdf">pdf</a>)</p>
<figure class="align-default">
<img alt="../_images/hough_tf.png" class="plot-directive" src="../_images/hough_tf.png" />
</figure>
</dd></dl>

<section id="examples-using-skimage-transform-hough-line">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_line</span></code><a class="headerlink" href="#examples-using-skimage-transform-hough-line" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a method to detect straight lines [1]_."><img alt="Straight line Hough transform" src="../_images/sphx_glr_plot_line_hough_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_line_hough_transform.html#sphx-glr-auto-examples-edges-plot-line-hough-transform-py"><span class="std std-ref">Straight line Hough transform</span></a></p>
  <div class="sphx-glr-thumbnail-title">Straight line Hough transform</div>
</div></div></section>
</section>
<section id="hough-line-peaks">
<h2>hough_line_peaks<a class="headerlink" href="#hough-line-peaks" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.hough_line_peaks">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">hough_line_peaks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hspace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dists</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/hough_transform.py#L8-L68"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.hough_line_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return peaks in a straight line Hough transform.</p>
<p>Identifies most prominent lines separated by a certain angle and distance
in a Hough transform. Non-maximum suppression with different sizes is
applied separately in the first (distances) and second (angles) dimension
of the Hough space to identify peaks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hspace</strong><span class="classifier">(N, M) array</span></dt><dd><p>Hough space returned by the <a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hough_line</span></code></a> function.</p>
</dd>
<dt><strong>angles</strong><span class="classifier">(M,) array</span></dt><dd><p>Angles returned by the <a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hough_line</span></code></a> function. Assumed to be continuous.
(<em class="xref py py-obj">angles[-1] - angles[0] == PI</em>).</p>
</dd>
<dt><strong>dists</strong><span class="classifier">(N, ) array</span></dt><dd><p>Distances returned by the <a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hough_line</span></code></a> function.</p>
</dd>
<dt><strong>min_distance</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum distance separating lines (maximum filter size for first
dimension of hough space).</p>
</dd>
<dt><strong>min_angle</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum angle separating lines (maximum filter size for second
dimension of hough space).</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Minimum intensity of peaks. Default is <em class="xref py py-obj">0.5 * max(hspace)</em>.</p>
</dd>
<dt><strong>num_peaks</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of peaks. When the number of peaks exceeds <em class="xref py py-obj">num_peaks</em>,
return <em class="xref py py-obj">num_peaks</em> coordinates based on peak intensity.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>accum, angles, dists</strong><span class="classifier">tuple of array</span></dt><dd><p>Peak values in Hough space, angles and distances.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough_line</span><span class="p">,</span> <span class="n">hough_line_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">line</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">line</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">line</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">cc</span><span class="p">,</span> <span class="n">rr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hspace</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dists</span> <span class="o">=</span> <span class="n">hough_line</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hspace</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dists</span> <span class="o">=</span> <span class="n">hough_line_peaks</span><span class="p">(</span><span class="n">hspace</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-hough-line-peaks">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_line_peaks</span></code><a class="headerlink" href="#examples-using-skimage-transform-hough-line-peaks" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a method to detect straight lines [1]_."><img alt="Straight line Hough transform" src="../_images/sphx_glr_plot_line_hough_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_line_hough_transform.html#sphx-glr-auto-examples-edges-plot-line-hough-transform-py"><span class="std std-ref">Straight line Hough transform</span></a></p>
  <div class="sphx-glr-thumbnail-title">Straight line Hough transform</div>
</div></div></section>
</section>
<section id="ifrt2">
<h2>ifrt2<a class="headerlink" href="#ifrt2" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.ifrt2">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">ifrt2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/finite_radon_transform.py#L71-L134"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.ifrt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 2-dimensional inverse finite radon transform (iFRT) for
an (n+1) x n integer array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>A 2-D (n+1) row x n column integer array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>iFRT</strong><span class="classifier">2-D n x n ndarray</span></dt><dd><p>Inverse Finite Radon Transform array of n x n integer coefficients.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frt2</span></code></a></dt><dd><p>The two-dimensional FRT</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The FRT has a unique inverse if and only if n is prime.
See <a class="reference internal" href="#r3b76f892cb20-1" id="id3">[1]</a> for an overview.
The idea for this algorithm is due to Vlad Negnevitski.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r3b76f892cb20-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">1</a><span class="fn-bracket">]</span></span>
<p>A. Kingston and I. Svalbe, “Projective transforms on periodic
discrete image arrays,” in P. Hawkes (Ed), Advances in Imaging
and Electron Physics, 139 (2006)</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SIZE</span> <span class="o">=</span> <span class="mi">59</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Finite Radon Transform:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">frt2</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Inverse Finite Radon Transform to recover the input</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fi</span> <span class="o">=</span> <span class="n">ifrt2</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Check that it’s identical to the original</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">img</span><span class="o">-</span><span class="n">fi</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="integral-image">
<h2>integral_image<a class="headerlink" href="#integral-image" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.integral_image">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">integral_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/integral.py#L4-L45"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.integral_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Integral image / summed area table.</p>
<p>The integral image contains the sum of all elements above and to the
left of it, i.e.:</p>
<div class="math notranslate nohighlight">
\[S[m, n] = \sum_{i \leq m} \sum_{j \leq n} X[i, j]\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">ndarray</span></dt><dd><p>Integral image/summed area table of same shape as input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For better accuracy and to avoid potential overflow, the data type of the
output may differ from the input’s when the default dtype of None is used.
For inputs with integer dtype, the behavior matches that for
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.cumsum.html#numpy.cumsum" title="(in NumPy v1.23)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.cumsum()</span></code></a>. Floating point inputs will be promoted to at least
double precision. The user can set <em class="xref py py-obj">dtype</em> to override this behavior.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rd91ebd979f08-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>F.C. Crow, “Summed-area tables for texture mapping,”
ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.</p>
</div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-integral-image">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.integral_image</span></code><a class="headerlink" href="#examples-using-skimage-transform-integral-image" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to compute multi-block local binary pattern (MB-LBP) features as well as..."><img alt="Multi-Block Local Binary Pattern for texture classification" src="../_images/sphx_glr_plot_multiblock_local_binary_pattern_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_multiblock_local_binary_pattern.html#sphx-glr-auto-examples-features-detection-plot-multiblock-local-binary-pattern-py"><span class="std std-ref">Multi-Block Local Binary Pattern for texture classification</span></a></p>
  <div class="sphx-glr-thumbnail-title">Multi-Block Local Binary Pattern for texture classification</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Haar-like feature descriptors were successfully used to implement the first real-time face dete..."><img alt="Face classification using Haar-like feature descriptor" src="../_images/sphx_glr_plot_haar_extraction_selection_classification_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_haar_extraction_selection_classification.html#sphx-glr-auto-examples-applications-plot-haar-extraction-selection-classification-py"><span class="std std-ref">Face classification using Haar-like feature descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">Face classification using Haar-like feature descriptor</div>
</div></div></section>
</section>
<section id="integrate">
<h2>integrate<a class="headerlink" href="#integrate" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.integrate">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">integrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ii</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/integral.py#L48-L140"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Use an integral image to integrate over a given window.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>ii</strong><span class="classifier">ndarray</span></dt><dd><p>Integral image.</p>
</dd>
<dt><strong>start</strong><span class="classifier">List of tuples, each tuple of length equal to dimension of <em class="xref py py-obj">ii</em></span></dt><dd><p>Coordinates of top left corner of window(s).
Each tuple in the list contains the starting row, col, … index
i.e <em class="xref py py-obj">[(row_win1, col_win1, …), (row_win2, col_win2,…), …]</em>.</p>
</dd>
<dt><strong>end</strong><span class="classifier">List of tuples, each tuple of length equal to dimension of <em class="xref py py-obj">ii</em></span></dt><dd><p>Coordinates of bottom right corner of window(s).
Each tuple in the list containing the end row, col, … index i.e
<em class="xref py py-obj">[(row_win1, col_win1, …), (row_win2, col_win2, …), …]</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">scalar or ndarray</span></dt><dd><p>Integral (sum) over the given window(s).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii</span> <span class="o">=</span> <span class="n">integral_image</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># sum from (1, 0) to (1, 2)</span>
<span class="go">array([3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>  <span class="c1"># sum from (3, 3) to (4, 5)</span>
<span class="go">array([6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># sum from (1, 0) to (1, 2) and from (3, 3) to (4, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>
<span class="go">array([3., 6.])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="iradon">
<h2>iradon<a class="headerlink" href="#iradon" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.iradon">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">iradon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radon_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ramp'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/radon_transform.py#L176-L304"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.iradon" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse radon transform.</p>
<p>Reconstruct an image from the radon transform, using the filtered
back projection algorithm.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radon_image</strong><span class="classifier">array</span></dt><dd><p>Image containing radon transform (sinogram). Each column of
the image corresponds to a projection along a different
angle. The tomography rotation axis should lie at the pixel
index <code class="docutils literal notranslate"><span class="pre">radon_image.shape[0]</span> <span class="pre">//</span> <span class="pre">2</span></code> along the 0th dimension of
<code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array_like, optional</span></dt><dd><p>Reconstruction angles (in degrees). Default: m angles evenly spaced
between 0 and 180 (if the shape of <em class="xref py py-obj">radon_image</em> is (N, M)).</p>
</dd>
<dt><strong>output_size</strong><span class="classifier">int, optional</span></dt><dd><p>Number of rows and columns in the reconstruction.</p>
</dd>
<dt><strong>filter_name</strong><span class="classifier">str, optional</span></dt><dd><p>Filter used in frequency domain filtering. Ramp filter used by default.
Filters available: ramp, shepp-logan, cosine, hamming, hann.
Assign None to use no filter.</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">str, optional</span></dt><dd><p>Interpolation method used in reconstruction. Methods available:
‘linear’, ‘nearest’, and ‘cubic’ (‘cubic’ is slow).</p>
</dd>
<dt><strong>circle</strong><span class="classifier">boolean, optional</span></dt><dd><p>Assume the reconstructed image is zero outside the inscribed circle.
Also changes the default output_size to match the behaviour of
<code class="docutils literal notranslate"><span class="pre">radon</span></code> called with <code class="docutils literal notranslate"><span class="pre">circle=True</span></code>.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reconstructed</strong><span class="classifier">ndarray</span></dt><dd><p>Reconstructed image. The rotation axis will be located in the pixel
with indices
<code class="docutils literal notranslate"><span class="pre">(reconstructed.shape[0]</span> <span class="pre">//</span> <span class="pre">2,</span> <span class="pre">reconstructed.shape[1]</span> <span class="pre">//</span> <span class="pre">2)</span></code>.</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.19: </span>In <code class="docutils literal notranslate"><span class="pre">iradon</span></code>, <code class="docutils literal notranslate"><span class="pre">filter</span></code> argument is deprecated in favor of
<code class="docutils literal notranslate"><span class="pre">filter_name</span></code>.</p>
</div>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>It applies the Fourier slice theorem to reconstruct an image by
multiplying the frequency domain of the filter with the FFT of the
projection data. This algorithm is called filtered back projection.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r19c92af887b5-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>AC Kak, M Slaney, “Principles of Computerized Tomographic
Imaging”, IEEE Press 1988.</p>
</div>
<div class="citation" id="r19c92af887b5-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>B.R. Ramesh, N. Srinivasa, K. Rajgopal, “An Algorithm for Computing
the Discrete Radon Transform With Some Applications”, Proceedings of
the Fourth IEEE Region 10 International Conference, TENCON ‘89, 1989</p>
</div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-iradon">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.iradon</span></code><a class="headerlink" href="#examples-using-skimage-transform-iradon" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In computed tomography, the tomography reconstruction problem is to obtain a tomographic slice ..."><img alt="Radon transform" src="../_images/sphx_glr_plot_radon_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_radon_transform.html#sphx-glr-auto-examples-transform-plot-radon-transform-py"><span class="std std-ref">Radon transform</span></a></p>
  <div class="sphx-glr-thumbnail-title">Radon transform</div>
</div></div></section>
</section>
<section id="iradon-sart">
<h2>iradon_sart<a class="headerlink" href="#iradon-sart" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.iradon_sart">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">iradon_sart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radon_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection_shifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relaxation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/radon_transform.py#L366-L505"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.iradon_sart" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse radon transform.</p>
<p>Reconstruct an image from the radon transform, using a single iteration of
the Simultaneous Algebraic Reconstruction Technique (SART) algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radon_image</strong><span class="classifier">2D array</span></dt><dd><p>Image containing radon transform (sinogram). Each column of
the image corresponds to a projection along a different angle. The
tomography rotation axis should lie at the pixel index
<code class="docutils literal notranslate"><span class="pre">radon_image.shape[0]</span> <span class="pre">//</span> <span class="pre">2</span></code> along the 0th dimension of
<code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">1D array, optional</span></dt><dd><p>Reconstruction angles (in degrees). Default: m angles evenly spaced
between 0 and 180 (if the shape of <em class="xref py py-obj">radon_image</em> is (N, M)).</p>
</dd>
<dt><strong>image</strong><span class="classifier">2D array, optional</span></dt><dd><p>Image containing an initial reconstruction estimate. Shape of this
array should be <code class="docutils literal notranslate"><span class="pre">(radon_image.shape[0],</span> <span class="pre">radon_image.shape[0])</span></code>. The
default is an array of zeros.</p>
</dd>
<dt><strong>projection_shifts</strong><span class="classifier">1D array, optional</span></dt><dd><p>Shift the projections contained in <code class="docutils literal notranslate"><span class="pre">radon_image</span></code> (the sinogram) by
this many pixels before reconstructing the image. The i’th value
defines the shift of the i’th column of <code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">length-2 sequence of floats, optional</span></dt><dd><p>Force all values in the reconstructed tomogram to lie in the range
<code class="docutils literal notranslate"><span class="pre">[clip[0],</span> <span class="pre">clip[1]]</span></code></p>
</dd>
<dt><strong>relaxation</strong><span class="classifier">float, optional</span></dt><dd><p>Relaxation parameter for the update step. A higher value can
improve the convergence rate, but one runs the risk of instabilities.
Values close to or higher than 1 are not recommended.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>Output data type, must be floating point. By default, if input
data type is not float, input is cast to double, otherwise
dtype is set to input data type.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reconstructed</strong><span class="classifier">ndarray</span></dt><dd><p>Reconstructed image. The rotation axis will be located in the pixel
with indices
<code class="docutils literal notranslate"><span class="pre">(reconstructed.shape[0]</span> <span class="pre">//</span> <span class="pre">2,</span> <span class="pre">reconstructed.shape[1]</span> <span class="pre">//</span> <span class="pre">2)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Algebraic Reconstruction Techniques are based on formulating the tomography
reconstruction problem as a set of linear equations. Along each ray,
the projected value is the sum of all the values of the cross section along
the ray. A typical feature of SART (and a few other variants of algebraic
techniques) is that it samples the cross section at equidistant points
along the ray, using linear interpolation between the pixel values of the
cross section. The resulting set of linear equations are then solved using
a slightly modified Kaczmarz method.</p>
<p>When using SART, a single iteration is usually sufficient to obtain a good
reconstruction. Further iterations will tend to enhance high-frequency
information, but will also often increase the noise.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r5a4015ea6a92-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>AC Kak, M Slaney, “Principles of Computerized Tomographic
Imaging”, IEEE Press 1988.</p>
</div>
<div class="citation" id="r5a4015ea6a92-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>AH Andersen, AC Kak, “Simultaneous algebraic reconstruction
technique (SART): a superior implementation of the ART algorithm”,
Ultrasonic Imaging 6 pp 81–94 (1984)</p>
</div>
<div class="citation" id="r5a4015ea6a92-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>S Kaczmarz, “Angenäherte auflösung von systemen linearer
gleichungen”, Bulletin International de l’Academie Polonaise des
Sciences et des Lettres 35 pp 355–357 (1937)</p>
</div>
<div class="citation" id="r5a4015ea6a92-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p>Kohler, T. “A projection access scheme for iterative
reconstruction based on the golden section.” Nuclear Science
Symposium Conference Record, 2004 IEEE. Vol. 6. IEEE, 2004.</p>
</div>
<div class="citation" id="r5a4015ea6a92-5" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p>Kaczmarz’ method, Wikipedia,
<a class="reference external" href="https://en.wikipedia.org/wiki/Kaczmarz_method">https://en.wikipedia.org/wiki/Kaczmarz_method</a></p>
</div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-iradon-sart">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.iradon_sart</span></code><a class="headerlink" href="#examples-using-skimage-transform-iradon-sart" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In computed tomography, the tomography reconstruction problem is to obtain a tomographic slice ..."><img alt="Radon transform" src="../_images/sphx_glr_plot_radon_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_radon_transform.html#sphx-glr-auto-examples-transform-plot-radon-transform-py"><span class="std std-ref">Radon transform</span></a></p>
  <div class="sphx-glr-thumbnail-title">Radon transform</div>
</div></div></section>
</section>
<section id="matrix-transform">
<h2>matrix_transform<a class="headerlink" href="#matrix-transform" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.matrix_transform">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">matrix_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1663-L1679"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.matrix_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply 2D matrix transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>x, y coordinates to transform</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">(3, 3) array_like</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Transformed coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="order-angles-golden-ratio">
<h2>order_angles_golden_ratio<a class="headerlink" href="#order-angles-golden-ratio" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.order_angles_golden_ratio">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">order_angles_golden_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/radon_transform.py#L307-L363"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.order_angles_golden_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Order angles to reduce the amount of correlated information in
subsequent projections.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">1D array of floats</span></dt><dd><p>Projection angles in degrees. Duplicate angles are not allowed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>indices_generator</strong><span class="classifier">generator yielding unsigned integers</span></dt><dd><p>The returned generator yields indices into <code class="docutils literal notranslate"><span class="pre">theta</span></code> such that
<code class="docutils literal notranslate"><span class="pre">theta[indices]</span></code> gives the approximate golden ratio ordering
of the projections. In total, <code class="docutils literal notranslate"><span class="pre">len(theta)</span></code> indices are yielded.
All non-negative integers &lt; <code class="docutils literal notranslate"><span class="pre">len(theta)</span></code> are yielded exactly once.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The method used here is that of the golden ratio introduced
by T. Kohler.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r88d6c0557044-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Kohler, T. “A projection access scheme for iterative
reconstruction based on the golden section.” Nuclear Science
Symposium Conference Record, 2004 IEEE. Vol. 6. IEEE, 2004.</p>
</div>
<div class="citation" id="r88d6c0557044-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Winkelmann, Stefanie, et al. “An optimal radial profile order
based on the Golden Ratio for time-resolved MRI.”
Medical Imaging, IEEE Transactions on 26.1 (2007): 68-76.</p>
</div>
</div>
</dd></dl>

</section>
<section id="probabilistic-hough-line">
<h2>probabilistic_hough_line<a class="headerlink" href="#probabilistic-hough-line" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.probabilistic_hough_line">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">probabilistic_hough_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line_length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line_gap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/hough_transform.py#L227-L271"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.probabilistic_hough_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Return lines from a progressive probabilistic line Hough transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">int, optional</span></dt><dd><p>Threshold</p>
</dd>
<dt><strong>line_length</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum accepted length of detected lines.
Increase the parameter to extract longer lines.</p>
</dd>
<dt><strong>line_gap</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum gap between pixels to still form a line.
Increase the parameter to merge broken lines more aggressively.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">1D ndarray, dtype=double, optional</span></dt><dd><p>Angles at which to compute the transform, in radians.
Defaults to a vector of 180 angles evenly spaced in the
range [-pi/2, pi/2).</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Seed to initialize the random number generator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lines</strong><span class="classifier">list</span></dt><dd><p>List of lines identified, lines in format ((x0, y0), (x1, y1)),
indicating line start and end.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rd9a46cdb16bc-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>C. Galamhos, J. Matas and J. Kittler, “Progressive probabilistic
Hough transform for line detection”, in IEEE Computer Society
Conference on Computer Vision and Pattern Recognition, 1999.</p>
</div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-probabilistic-hough-line">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.probabilistic_hough_line</span></code><a class="headerlink" href="#examples-using-skimage-transform-probabilistic-hough-line" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a method to detect straight lines [1]_."><img alt="Straight line Hough transform" src="../_images/sphx_glr_plot_line_hough_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_line_hough_transform.html#sphx-glr-auto-examples-edges-plot-line-hough-transform-py"><span class="std std-ref">Straight line Hough transform</span></a></p>
  <div class="sphx-glr-thumbnail-title">Straight line Hough transform</div>
</div></div></section>
</section>
<section id="pyramid-expand">
<h2>pyramid_expand<a class="headerlink" href="#pyramid-expand" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.pyramid_expand">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/pyramids.py#L105-L174"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.pyramid_expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Upsample and then smooth image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>upscale</strong><span class="classifier">float, optional</span></dt><dd><p>Upscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <em class="xref py py-obj">2 * upscale / 6.0</em> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of upsampling. See
<a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension. This argument is deprecated:
specify <em class="xref py py-obj">channel_axis</em> instead.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>Upsampled and smoothed float image.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>multichannel</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <em class="xref py py-obj">channel_axis</em>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 0.19.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r53df52222c6d-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</div>
</div>
</dd></dl>

</section>
<section id="pyramid-gaussian">
<h2>pyramid_gaussian<a class="headerlink" href="#pyramid-gaussian" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.pyramid_gaussian">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/pyramids.py#L177-L265"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.pyramid_gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield images of the Gaussian pyramid formed by the input image.</p>
<p>Recursively applies the <a class="reference internal" href="#skimage.transform.pyramid_reduce" title="skimage.transform.pyramid_reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyramid_reduce</span></code></a> function to the image, and yields
the downscaled images.</p>
<p>Note that the first image of the pyramid will be the original, unscaled
image. The total number of images is <em class="xref py py-obj">max_layer + 1</em>. In case all layers
are computed, the last image is either a one-pixel image or the image where
the reduction does not change its shape.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>max_layer</strong><span class="classifier">int, optional</span></dt><dd><p>Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</dd>
<dt><strong>downscale</strong><span class="classifier">float, optional</span></dt><dd><p>Downscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <em class="xref py py-obj">2 * downscale / 6.0</em> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of downsampling. See
<a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension. This argument is deprecated:
specify <em class="xref py py-obj">channel_axis</em> instead.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pyramid</strong><span class="classifier">generator</span></dt><dd><p>Generator yielding pyramid layers as float images.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>multichannel</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <em class="xref py py-obj">channel_axis</em>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 0.19.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r4f1da659b730-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-pyramid-gaussian">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.pyramid_gaussian</span></code><a class="headerlink" href="#examples-using-skimage-transform-pyramid-gaussian" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="The pyramid_gaussian function takes an image and yields successive images shrunk by a constant ..."><img alt="Build image pyramids" src="../_images/sphx_glr_plot_pyramid_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_pyramid.html#sphx-glr-auto-examples-transform-plot-pyramid-py"><span class="std std-ref">Build image pyramids</span></a></p>
  <div class="sphx-glr-thumbnail-title">Build image pyramids</div>
</div></div></section>
</section>
<section id="pyramid-laplacian">
<h2>pyramid_laplacian<a class="headerlink" href="#pyramid-laplacian" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.pyramid_laplacian">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_laplacian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/pyramids.py#L268-L377"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.pyramid_laplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield images of the laplacian pyramid formed by the input image.</p>
<p>Each layer contains the difference between the downsampled and the
downsampled, smoothed image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">layer</span> <span class="o">=</span> <span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">)</span> <span class="o">-</span> <span class="n">smooth</span><span class="p">(</span><span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that the first image of the pyramid will be the difference between the
original, unscaled image and its smoothed version. The total number of
images is <em class="xref py py-obj">max_layer + 1</em>. In case all layers are computed, the last image
is either a one-pixel image or the image where the reduction does not
change its shape.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>max_layer</strong><span class="classifier">int, optional</span></dt><dd><p>Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</dd>
<dt><strong>downscale</strong><span class="classifier">float, optional</span></dt><dd><p>Downscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <em class="xref py py-obj">2 * downscale / 6.0</em> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of downsampling. See
<a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension. This argument is deprecated:
specify <em class="xref py py-obj">channel_axis</em> instead.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pyramid</strong><span class="classifier">generator</span></dt><dd><p>Generator yielding pyramid layers as float images.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>multichannel</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <em class="xref py py-obj">channel_axis</em>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 0.19.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r64565393f7ed-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</div>
<div class="citation" id="r64565393f7ed-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://sepwww.stanford.edu/data/media/public/sep/morgan/texturematch/paper_html/node3.html">http://sepwww.stanford.edu/data/media/public/sep/morgan/texturematch/paper_html/node3.html</a></p>
</div>
</div>
</dd></dl>

</section>
<section id="pyramid-reduce">
<h2>pyramid_reduce<a class="headerlink" href="#pyramid-reduce" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.pyramid_reduce">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/pyramids.py#L32-L102"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.pyramid_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth and then downsample image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>downscale</strong><span class="classifier">float, optional</span></dt><dd><p>Downscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <em class="xref py py-obj">2 * downscale / 6.0</em> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of downsampling. See
<a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension. This argument is deprecated:
specify <em class="xref py py-obj">channel_axis</em> instead.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>Smoothed and downsampled float image.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>multichannel</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <em class="xref py py-obj">channel_axis</em>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 0.19.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r4f51c9e42c4a-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</div>
</div>
</dd></dl>

</section>
<section id="radon">
<h2>radon<a class="headerlink" href="#radon" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.radon">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">radon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/radon_transform.py#L16-L107"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.radon" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the radon transform of an image given specified
projection angles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array_like</span></dt><dd><p>Input image. The rotation axis will be located in the pixel with
indices <code class="docutils literal notranslate"><span class="pre">(image.shape[0]</span> <span class="pre">//</span> <span class="pre">2,</span> <span class="pre">image.shape[1]</span> <span class="pre">//</span> <span class="pre">2)</span></code>.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array_like, optional</span></dt><dd><p>Projection angles (in degrees). If <em class="xref py py-obj">None</em>, the value is set to
np.arange(180).</p>
</dd>
<dt><strong>circle</strong><span class="classifier">boolean, optional</span></dt><dd><p>Assume image is zero outside the inscribed circle, making the
width of each projection (the first dimension of the sinogram)
equal to <code class="docutils literal notranslate"><span class="pre">min(image.shape)</span></code>.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>radon_image</strong><span class="classifier">ndarray</span></dt><dd><p>Radon transform (sinogram).  The tomography rotation axis will lie
at the pixel index <code class="docutils literal notranslate"><span class="pre">radon_image.shape[0]</span> <span class="pre">//</span> <span class="pre">2</span></code> along the 0th
dimension of <code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Based on code of Justin K. Romberg
(<a class="reference external" href="https://www.clear.rice.edu/elec431/projects96/DSP/bpanalysis.html">https://www.clear.rice.edu/elec431/projects96/DSP/bpanalysis.html</a>)</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r0eb755fc1fae-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>AC Kak, M Slaney, “Principles of Computerized Tomographic
Imaging”, IEEE Press 1988.</p>
</div>
<div class="citation" id="r0eb755fc1fae-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>B.R. Ramesh, N. Srinivasa, K. Rajgopal, “An Algorithm for Computing
the Discrete Radon Transform With Some Applications”, Proceedings of
the Fourth IEEE Region 10 International Conference, TENCON ‘89, 1989</p>
</div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-radon">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.radon</span></code><a class="headerlink" href="#examples-using-skimage-transform-radon" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In computed tomography, the tomography reconstruction problem is to obtain a tomographic slice ..."><img alt="Radon transform" src="../_images/sphx_glr_plot_radon_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_radon_transform.html#sphx-glr-auto-examples-transform-plot-radon-transform-py"><span class="std std-ref">Radon transform</span></a></p>
  <div class="sphx-glr-thumbnail-title">Radon transform</div>
</div></div></section>
</section>
<section id="rescale">
<h2>rescale<a class="headerlink" href="#rescale" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.rescale">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">rescale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L244-L348"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.rescale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale image by a certain factor.</p>
<p>Performs interpolation to up-scale or down-scale N-dimensional images.
Note that anti-aliasing should be enabled when down-sizing images to avoid
aliasing artifacts. For down-sampling with an integer factor also see
<a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.downscale_local_mean</span></code></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">{float, tuple of floats}</span></dt><dd><p>Scale factors. Separate scale factors can be defined as
<em class="xref py py-obj">(rows, cols[, …][, dim])</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scaled</strong><span class="classifier">ndarray</span></dt><dd><p>Scaled version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.23)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension. This argument is deprecated:
specify <em class="xref py py-obj">channel_axis</em> instead.</p>
</dd>
<dt><strong>anti_aliasing</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to apply a Gaussian filter to smooth the image prior
to down-scaling. It is crucial to filter when down-sampling
the image to avoid aliasing artifacts. If input image data
type is bool, no anti-aliasing is applied.</p>
</dd>
<dt><strong>anti_aliasing_sigma</strong><span class="classifier">{float, tuple of floats}, optional</span></dt><dd><p>Standard deviation for Gaussian filtering to avoid aliasing artifacts.
By default, this value is chosen as (s - 1) / 2 where s is the
down-scaling factor.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
<dt><strong>multichannel</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <em class="xref py py-obj">channel_axis</em>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 0.19.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">rescale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(51, 51)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(256, 256)</span>
</pre></div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-rescale">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.rescale</span></code><a class="headerlink" href="#examples-using-skimage-transform-rescale" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example illustrates the different edge modes available during interpolation in routines su..."><img alt="Interpolation: Edge Modes" src="../_images/sphx_glr_plot_edge_modes_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_edge_modes.html#sphx-glr-auto-examples-transform-plot-edge-modes-py"><span class="std std-ref">Interpolation: Edge Modes</span></a></p>
  <div class="sphx-glr-thumbnail-title">Interpolation: Edge Modes</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Rescale operation resizes an image by a given scaling factor. The scaling factor can either be ..."><img alt="Rescale, resize, and downscale" src="../_images/sphx_glr_plot_rescale_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_rescale.html#sphx-glr-auto-examples-transform-plot-rescale-py"><span class="std std-ref">Rescale, resize, and downscale</span></a></p>
  <div class="sphx-glr-thumbnail-title">Rescale, resize, and downscale</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In computed tomography, the tomography reconstruction problem is to obtain a tomographic slice ..."><img alt="Radon transform" src="../_images/sphx_glr_plot_radon_transform_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_radon_transform.html#sphx-glr-auto-examples-transform-plot-radon-transform-py"><span class="std std-ref">Radon transform</span></a></p>
  <div class="sphx-glr-thumbnail-title">Radon transform</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Phase correlation (``registration.phase_cross_correlation``) is an efficient method for determi..."><img alt="Using Polar and Log-Polar Transformations for Registration" src="../_images/sphx_glr_plot_register_rotation_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_register_rotation.html#sphx-glr-auto-examples-registration-plot-register-rotation-py"><span class="std std-ref">Using Polar and Log-Polar Transformations for Registration</span></a></p>
  <div class="sphx-glr-thumbnail-title">Using Polar and Log-Polar Transformations for Registration</div>
</div></div></section>
</section>
<section id="resize">
<h2>resize<a class="headerlink" href="#resize" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.resize">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">resize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L72-L241"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize image to match a certain size.</p>
<p>Performs interpolation to up-size or down-size N-dimensional images. Note
that anti-aliasing should be enabled when down-sizing images to avoid
aliasing artifacts. For downsampling with an integer factor also see
<a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.downscale_local_mean</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">iterable</span></dt><dd><p>Size of the generated output image <em class="xref py py-obj">(rows, cols[, …][, dim])</em>. If
<em class="xref py py-obj">dim</em> is not provided, the number of channels is preserved. In case the
number of input channels does not equal the number of output channels a
n-dimensional interpolation is applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>resized</strong><span class="classifier">ndarray</span></dt><dd><p>Resized version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.23)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>anti_aliasing</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to apply a Gaussian filter to smooth the image prior
to downsampling. It is crucial to filter when downsampling
the image to avoid aliasing artifacts. If not specified, it is set to
True when downsampling an image whose data type is not bool.
It is also set to False when using nearest neighbor interpolation
(<code class="docutils literal notranslate"><span class="pre">order</span></code> == 0) with integer input data type.</p>
</dd>
<dt><strong>anti_aliasing_sigma</strong><span class="classifier">{float, tuple of floats}, optional</span></dt><dd><p>Standard deviation for Gaussian filtering used when anti-aliasing.
By default, this value is chosen as (s - 1) / 2 where s is the
downsampling factor, where s &gt; 1. For the up-size case, s &lt; 1, no
anti-aliasing is performed prior to rescaling.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">resize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-resize">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.resize</span></code><a class="headerlink" href="#examples-using-skimage-transform-resize" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example illustrates the different edge modes available during interpolation in routines su..."><img alt="Interpolation: Edge Modes" src="../_images/sphx_glr_plot_edge_modes_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_edge_modes.html#sphx-glr-auto-examples-transform-plot-edge-modes-py"><span class="std std-ref">Interpolation: Edge Modes</span></a></p>
  <div class="sphx-glr-thumbnail-title">Interpolation: Edge Modes</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Rescale operation resizes an image by a given scaling factor. The scaling factor can either be ..."><img alt="Rescale, resize, and downscale" src="../_images/sphx_glr_plot_rescale_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_rescale.html#sphx-glr-auto-examples-transform-plot-rescale-py"><span class="std std-ref">Rescale, resize, and downscale</span></a></p>
  <div class="sphx-glr-thumbnail-title">Rescale, resize, and downscale</div>
</div></div></section>
</section>
<section id="resize-local-mean">
<h2>resize_local_mean<a class="headerlink" href="#resize-local-mean" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.resize_local_mean">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">resize_local_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L1223-L1339"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.resize_local_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize an array with the local mean / bilinear scaling.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image. If this is a multichannel image, the axis corresponding
to channels should be specified using <em class="xref py py-obj">channel_axis</em></p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">iterable</span></dt><dd><p>Size of the generated output image. When <em class="xref py py-obj">channel_axis</em> is not None,
the <em class="xref py py-obj">channel_axis</em> should either be omitted from <em class="xref py py-obj">output_shape</em> or the
<code class="docutils literal notranslate"><span class="pre">output_shape[channel_axis]</span></code> must match
<code class="docutils literal notranslate"><span class="pre">image.shape[channel_axis]</span></code>. If the length of <em class="xref py py-obj">output_shape</em> exceeds
image.ndim, additional singleton dimensions will be appended to the
input <code class="docutils literal notranslate"><span class="pre">image</span></code> as needed.</p>
</dd>
<dt><strong>grid_mode</strong><span class="classifier">bool, optional</span></dt><dd><p>Defines <code class="docutils literal notranslate"><span class="pre">image</span></code> pixels position: if True, pixels are assumed to be at
grid intersections, otherwise at cell centers. As a consequence,
for example, a 1d signal of length 5 is considered to have length 4
when <em class="xref py py-obj">grid_mode</em> is False, but length 5 when <em class="xref py py-obj">grid_mode</em> is True. See
the following visual illustration:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>| pixel 1 | pixel 2 | pixel 3 | pixel 4 | pixel 5 |
     |&lt;--------------------------------------&gt;|
                        vs.
|&lt;-----------------------------------------------&gt;|
</pre></div>
</div>
<p>The starting point of the arrow in the diagram above corresponds to
coordinate location 0 in each mode.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>resized</strong><span class="classifier">ndarray</span></dt><dd><p>Resized version of the input.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.transform.resize" title="skimage.transform.resize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resize</span></code></a>, <a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">downscale_local_mean</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This method is sometimes referred to as “area-based” interpolation or
“pixel mixing” interpolation <a class="reference internal" href="#r3d46f862a1f0-1" id="id23">[1]</a>. When <em class="xref py py-obj">grid_mode</em> is True, it is
equivalent to using OpenCV’s resize with <em class="xref py py-obj">INTER_AREA</em> interpolation mode.
It is commonly used for image downsizing. If the downsizing factors are
integers, then <a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">downscale_local_mean</span></code></a> should be preferred instead.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r3d46f862a1f0-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id23">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://entropymine.com/imageworsener/pixelmixing/">http://entropymine.com/imageworsener/pixelmixing/</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">resize_local_mean</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize_local_mean</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="rotate">
<h2>rotate<a class="headerlink" href="#rotate" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.rotate">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L351-L462"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate image by a certain angle around its center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>angle</strong><span class="classifier">float</span></dt><dd><p>Rotation angle in degrees in counter-clockwise direction.</p>
</dd>
<dt><strong>resize</strong><span class="classifier">bool, optional</span></dt><dd><p>Determine whether the shape of the output image will be automatically
calculated, so the complete rotated image exactly fits. Default is
False.</p>
</dd>
<dt><strong>center</strong><span class="classifier">iterable of length 2</span></dt><dd><p>The rotation center. If <code class="docutils literal notranslate"><span class="pre">center=None</span></code>, the image is rotated around
its center, i.e. <code class="docutils literal notranslate"><span class="pre">center=(cols</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">-</span> <span class="pre">0.5,</span> <span class="pre">rows</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">-</span> <span class="pre">0.5)</span></code>.  Please
note that this parameter is (cols, rows), contrary to normal skimage
ordering.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rotated</strong><span class="classifier">ndarray</span></dt><dd><p>Rotated version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.23)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">rotate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(512, 512)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(530, 530)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(512, 512)</span>
</pre></div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-rotate">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.rotate</span></code><a class="headerlink" href="#examples-using-skimage-transform-rotate" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="`Homographies &lt;https://en.wikipedia.org/wiki/Homography&gt;`_ are transformations of a Euclidean s..."><img alt="Types of homographies" src="../_images/sphx_glr_plot_transform_types_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_transform_types.html#sphx-glr-auto-examples-transform-plot-transform-types-py"><span class="std std-ref">Types of homographies</span></a></p>
  <div class="sphx-glr-thumbnail-title">Types of homographies</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates how a set of images can be assembled under the hypothesis of rigid bo..."><img alt="Assemble images with simple image stitching" src="../_images/sphx_glr_plot_stitching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_stitching.html#sphx-glr-auto-examples-registration-plot-stitching-py"><span class="std std-ref">Assemble images with simple image stitching</span></a></p>
  <div class="sphx-glr-thumbnail-title">Assemble images with simple image stitching</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Phase correlation (``registration.phase_cross_correlation``) is an efficient method for determi..."><img alt="Using Polar and Log-Polar Transformations for Registration" src="../_images/sphx_glr_plot_register_rotation_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_register_rotation.html#sphx-glr-auto-examples-registration-plot-register-rotation-py"><span class="std std-ref">Using Polar and Log-Polar Transformations for Registration</span></a></p>
  <div class="sphx-glr-thumbnail-title">Using Polar and Log-Polar Transformations for Registration</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the ORB feature detection and binary description algorithm. It uses a..."><img alt="ORB feature detector and binary descriptor" src="../_images/sphx_glr_plot_orb_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_orb.html#sphx-glr-auto-examples-features-detection-plot-orb-py"><span class="std std-ref">ORB feature detector and binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">ORB feature detector and binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the BRIEF binary description algorithm. The descriptor consists of re..."><img alt="BRIEF binary descriptor" src="../_images/sphx_glr_plot_brief_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_brief.html#sphx-glr-auto-examples-features-detection-plot-brief-py"><span class="std std-ref">BRIEF binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">BRIEF binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the SIFT feature detection and its description algorithm."><img alt="SIFT feature detector and descriptor extractor" src="../_images/sphx_glr_plot_sift_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_sift.html#sphx-glr-auto-examples-features-detection-plot-sift-py"><span class="std std-ref">SIFT feature detector and descriptor extractor</span></a></p>
  <div class="sphx-glr-thumbnail-title">SIFT feature detector and descriptor extractor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Histogram matching can be used for object detection in images [1]_. This example extracts a sin..."><img alt="Sliding window histogram" src="../_images/sphx_glr_plot_windowed_histogram_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_windowed_histogram.html#sphx-glr-auto-examples-features-detection-plot-windowed-histogram-py"><span class="std std-ref">Sliding window histogram</span></a></p>
  <div class="sphx-glr-thumbnail-title">Sliding window histogram</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example, we will see how to classify textures based on LBP (Local Binary Pattern). LBP ..."><img alt="Local Binary Pattern for texture classification" src="../_images/sphx_glr_plot_local_binary_pattern_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_local_binary_pattern.html#sphx-glr-auto-examples-features-detection-plot-local-binary-pattern-py"><span class="std std-ref">Local Binary Pattern for texture classification</span></a></p>
  <div class="sphx-glr-thumbnail-title">Local Binary Pattern for texture classification</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example, we show the error on measuring perimeters, comparing classic approximations an..."><img alt="Measure perimeters with different estimators" src="../_images/sphx_glr_plot_perimeters_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_perimeters.html#sphx-glr-auto-examples-segmentation-plot-perimeters-py"><span class="std std-ref">Measure perimeters with different estimators</span></a></p>
  <div class="sphx-glr-thumbnail-title">Measure perimeters with different estimators</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima..."><img alt="Measure region properties" src="../_images/sphx_glr_plot_regionprops_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></p>
  <div class="sphx-glr-thumbnail-title">Measure region properties</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Image comparison is particularly useful when performing image processing tasks such as exposure..."><img alt="Visual image comparison" src="../_images/sphx_glr_plot_image_comparison_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_image_comparison.html#sphx-glr-auto-examples-applications-plot-image-comparison-py"><span class="std std-ref">Visual image comparison</span></a></p>
  <div class="sphx-glr-thumbnail-title">Visual image comparison</div>
</div></div></section>
</section>
<section id="swirl">
<h2>swirl<a class="headerlink" href="#swirl" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.swirl">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">swirl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strength</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L531-L592"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.swirl" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a swirl transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>center</strong><span class="classifier">(column, row) tuple or (2,) ndarray, optional</span></dt><dd><p>Center coordinate of transformation.</p>
</dd>
<dt><strong>strength</strong><span class="classifier">float, optional</span></dt><dd><p>The amount of swirling applied.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>The extent of the swirl in pixels.  The effect dies out
rapidly beyond <em class="xref py py-obj">radius</em>.</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Additional rotation applied to the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>swirled</strong><span class="classifier">ndarray</span></dt><dd><p>Swirled version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>output_shape</strong><span class="classifier">tuple (rows, cols), optional</span></dt><dd><p>Shape of the output image generated. By default the shape of the input
image is preserved.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode, with ‘constant’ used as the default. Modes match
the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.23)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<section id="examples-using-skimage-transform-swirl">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.swirl</span></code><a class="headerlink" href="#examples-using-skimage-transform-swirl" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Image swirling is a non-linear image deformation that creates a whirlpool effect.  This example..."><img alt="Swirl" src="../_images/sphx_glr_plot_swirl_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_swirl.html#sphx-glr-auto-examples-transform-plot-swirl-py"><span class="std std-ref">Swirl</span></a></p>
  <div class="sphx-glr-thumbnail-title">Swirl</div>
</div></div></section>
</section>
<section id="warp">
<h2>warp<a class="headerlink" href="#warp" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.warp">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">warp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L751-L1003"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.warp" title="Permalink to this definition">¶</a></dt>
<dd><p>Warp an image according to a given coordinate transformation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>inverse_map</strong><span class="classifier">transformation object, callable <code class="docutils literal notranslate"><span class="pre">cr</span> <span class="pre">=</span> <span class="pre">f(cr,</span> <span class="pre">**kwargs)</span></code>, or ndarray</span></dt><dd><p>Inverse coordinate map, which transforms coordinates in the output
images into their corresponding coordinates in the input image.</p>
<p>There are a number of different options to define this map, depending
on the dimensionality of the input image. A 2-D image can have 2
dimensions for gray-scale images, or 3 dimensions with color
information.</p>
<blockquote>
<div><ul class="simple">
<li><p>For 2-D images, you can directly pass a transformation object,
e.g. <a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.SimilarityTransform</span></code></a>, or its inverse.</p></li>
<li><p>For 2-D images, you can pass a <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3)</span></code> homogeneous
transformation matrix, e.g.
<em class="xref py py-obj">skimage.transform.SimilarityTransform.params</em>.</p></li>
<li><p>For 2-D images, a function that transforms a <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">2)</span></code> array of
<code class="docutils literal notranslate"><span class="pre">(col,</span> <span class="pre">row)</span></code> coordinates in the output image to their
corresponding coordinates in the input image. Extra parameters to
the function can be specified through <em class="xref py py-obj">map_args</em>.</p></li>
<li><p>For N-D images, you can directly pass an array of coordinates.
The first dimension specifies the coordinates in the input image,
while the subsequent dimensions determine the position in the
output image. E.g. in case of 2-D images, you need to pass an array
of shape <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">rows,</span> <span class="pre">cols)</span></code>, where <em class="xref py py-obj">rows</em> and <em class="xref py py-obj">cols</em> determine the
shape of the output image, and the first dimension contains the
<code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> coordinate in the input image.
See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.map_coordinates.html#scipy.ndimage.map_coordinates" title="(in SciPy v1.9.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.ndimage.map_coordinates</span></code></a> for further documentation.</p></li>
</ul>
</div></blockquote>
<p>Note, that a <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3)</span></code> matrix is interpreted as a homogeneous
transformation matrix, so you cannot interpolate values from a 3-D
input, if the output is of shape <code class="docutils literal notranslate"><span class="pre">(3,)</span></code>.</p>
<p>See example section for usage.</p>
</dd>
<dt><strong>map_args</strong><span class="classifier">dict, optional</span></dt><dd><p>Keyword arguments passed to <em class="xref py py-obj">inverse_map</em>.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">tuple (rows, cols), optional</span></dt><dd><p>Shape of the output image generated. By default the shape of the input
image is preserved.  Note that, even for multi-band images, only rows
and columns need to be specified.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><dl>
<dt>The order of interpolation. The order has to be in the range 0-5:</dt><dd><ul class="simple">
<li><p>0: Nearest-neighbor</p></li>
<li><p>1: Bi-linear (default)</p></li>
<li><p>2: Bi-quadratic</p></li>
<li><p>3: Bi-cubic</p></li>
<li><p>4: Bi-quartic</p></li>
<li><p>5: Bi-quintic</p></li>
</ul>
<p>Default is 0 if image.dtype is bool and 1 otherwise.</p>
</dd>
</dl>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.23)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>warped</strong><span class="classifier">double ndarray</span></dt><dd><p>The warped input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The input image is converted to a <em class="xref py py-obj">double</em> image.</p></li>
<li><p>In case of a <a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SimilarityTransform</span></code></a>, <a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineTransform</span></code></a> and
<a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a> and <em class="xref py py-obj">order</em> in [0, 3] this function uses the
underlying transformation matrix to warp the image with a much faster
routine.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">warp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
</pre></div>
</div>
<p>The following image warps are all equal but differ substantially in
execution time. The image is shifted to the bottom.</p>
<p>Use a geometric transform to warp an image (fast):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">SimilarityTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">tform</span><span class="p">)</span>
</pre></div>
</div>
<p>Use a callable (slow):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_down</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">shift_down</span><span class="p">)</span>
</pre></div>
</div>
<p>Use a transformation matrix to warp an image (fast):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">ProjectiveTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ProjectiveTransform</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="p">))</span>
</pre></div>
</div>
<p>You can also use the inverse of a geometric transformation (fast):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span>
</pre></div>
</div>
<p>For N-D images you can pass a coordinate array, that specifies the
coordinates in the input image for every element in the output image. E.g.
if you want to rescale a 3-D cube, you can do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cube_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">cube_shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Setup the coordinate array, that defines the scaling:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">cube_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords0</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coords0</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span><span class="p">])</span>
</pre></div>
</div>
<p>Assume that the cube contains spatial data, where the first array element
center is at coordinate (0.5, 0.5, 0.5) in real space, i.e. we have to
account for this extra offset when scaling the image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-warp">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code><a class="headerlink" href="#examples-using-skimage-transform-warp" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Image swirling is a non-linear image deformation that creates a whirlpool effect.  This example..."><img alt="Swirl" src="../_images/sphx_glr_plot_swirl_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_swirl.html#sphx-glr-auto-examples-transform-plot-swirl-py"><span class="std std-ref">Swirl</span></a></p>
  <div class="sphx-glr-thumbnail-title">Swirl</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use the Piecewise Affine Transformation."><img alt="Piecewise Affine Transformation" src="../_images/sphx_glr_plot_piecewise_affine_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_piecewise_affine.html#sphx-glr-auto-examples-transform-plot-piecewise-affine-py"><span class="std std-ref">Piecewise Affine Transformation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Piecewise Affine Transformation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example, we will see how to use geometric transformations in the context of image proce..."><img alt="Using geometric transformations" src="../_images/sphx_glr_plot_geometric_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_geometric.html#sphx-glr-auto-examples-transform-plot-geometric-py"><span class="std std-ref">Using geometric transformations</span></a></p>
  <div class="sphx-glr-thumbnail-title">Using geometric transformations</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="`Homographies &lt;https://en.wikipedia.org/wiki/Homography&gt;`_ are transformations of a Euclidean s..."><img alt="Types of homographies" src="../_images/sphx_glr_plot_transform_types_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_transform_types.html#sphx-glr-auto-examples-transform-plot-transform-types-py"><span class="std std-ref">Types of homographies</span></a></p>
  <div class="sphx-glr-thumbnail-title">Types of homographies</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this simplified example we first generate two synthetic images as if they were taken from di..."><img alt="Robust matching using RANSAC" src="../_images/sphx_glr_plot_matching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_matching.html#sphx-glr-auto-examples-transform-plot-matching-py"><span class="std std-ref">Robust matching using RANSAC</span></a></p>
  <div class="sphx-glr-thumbnail-title">Robust matching using RANSAC</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Demonstration of image registration using optical flow."><img alt="Registration using optical flow" src="../_images/sphx_glr_plot_opticalflow_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_opticalflow.html#sphx-glr-auto-examples-registration-plot-opticalflow-py"><span class="std std-ref">Registration using optical flow</span></a></p>
  <div class="sphx-glr-thumbnail-title">Registration using optical flow</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates how a set of images can be assembled under the hypothesis of rigid bo..."><img alt="Assemble images with simple image stitching" src="../_images/sphx_glr_plot_stitching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_stitching.html#sphx-glr-auto-examples-registration-plot-stitching-py"><span class="std std-ref">Assemble images with simple image stitching</span></a></p>
  <div class="sphx-glr-thumbnail-title">Assemble images with simple image stitching</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Detect corner points using the Harris corner detector and determine the subpixel position of co..."><img alt="Corner detection" src="../_images/sphx_glr_plot_corner_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_corner.html#sphx-glr-auto-examples-features-detection-plot-corner-py"><span class="std std-ref">Corner detection</span></a></p>
  <div class="sphx-glr-thumbnail-title">Corner detection</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="The CENSURE feature detector is a scale-invariant center-surround detector (CENSURE) that claim..."><img alt="CENSURE feature detector" src="../_images/sphx_glr_plot_censure_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_censure.html#sphx-glr-auto-examples-features-detection-plot-censure-py"><span class="std std-ref">CENSURE feature detector</span></a></p>
  <div class="sphx-glr-thumbnail-title">CENSURE feature detector</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the ORB feature detection and binary description algorithm. It uses a..."><img alt="ORB feature detector and binary descriptor" src="../_images/sphx_glr_plot_orb_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_orb.html#sphx-glr-auto-examples-features-detection-plot-orb-py"><span class="std std-ref">ORB feature detector and binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">ORB feature detector and binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the BRIEF binary description algorithm. The descriptor consists of re..."><img alt="BRIEF binary descriptor" src="../_images/sphx_glr_plot_brief_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_brief.html#sphx-glr-auto-examples-features-detection-plot-brief-py"><span class="std std-ref">BRIEF binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">BRIEF binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the SIFT feature detection and its description algorithm."><img alt="SIFT feature detector and descriptor extractor" src="../_images/sphx_glr_plot_sift_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_sift.html#sphx-glr-auto-examples-features-detection-plot-sift-py"><span class="std std-ref">SIFT feature detector and descriptor extractor</span></a></p>
  <div class="sphx-glr-thumbnail-title">SIFT feature detector and descriptor extractor</div>
</div></div></section>
</section>
<section id="warp-coords">
<h2>warp_coords<a class="headerlink" href="#warp-coords" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.warp_coords">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">warp_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L618-L693"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.warp_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the source coordinates for the output of a 2-D image warp.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coord_map</strong><span class="classifier">callable like GeometricTransform.inverse</span></dt><dd><p>Return input coordinates for given output coordinates.
Coordinates are in the shape (P, 2), where P is the number
of coordinates and each element is a <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> pair.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple</span></dt><dd><p>Shape of output image <code class="docutils literal notranslate"><span class="pre">(rows,</span> <span class="pre">cols[,</span> <span class="pre">bands])</span></code>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">np.dtype or string</span></dt><dd><p>dtype for return value (sane choices: float32 or float64).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>coords</strong><span class="classifier">(ndim, rows, cols[, bands]) array of dtype <em class="xref py py-obj">dtype</em></span></dt><dd><p>Coordinates for <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.map_coordinates.html#scipy.ndimage.map_coordinates" title="(in SciPy v1.9.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.ndimage.map_coordinates</span></code></a>, that will yield
an image of shape (orows, ocols, bands) by drawing from source
points according to the <em class="xref py py-obj">coord_transform_fn</em>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is a lower-level routine that produces the source coordinates for 2-D
images used by <em class="xref py py-obj">warp()</em>.</p>
<p>It is provided separately from <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp</span></code></a> to give additional flexibility to
users who would like, for example, to re-use a particular coordinate
mapping, to use specific dtypes at various points along the the
image-warping process, or to implement different post-processing logic
than <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp</span></code></a> performs after the call to <em class="xref py py-obj">ndi.map_coordinates</em>.</p>
<p class="rubric">Examples</p>
<p>Produce a coordinate map that shifts an image up and to the right:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">map_coordinates</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_up10_left20</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">warp_coords</span><span class="p">(</span><span class="n">shift_up10_left20</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped_image</span> <span class="o">=</span> <span class="n">map_coordinates</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="warp-polar">
<h2>warp_polar<a class="headerlink" href="#warp-polar" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="skimage.transform.warp_polar">
<span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">warp_polar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_warps.py#L1068-L1175"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.warp_polar" title="Permalink to this definition">¶</a></dt>
<dd><p>Remap image to polar or log-polar coordinates space.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image. Only 2-D arrays are accepted by default. 3-D arrays are
accepted if a <em class="xref py py-obj">channel_axis</em> is specified.</p>
</dd>
<dt><strong>center</strong><span class="classifier">tuple (row, col), optional</span></dt><dd><p>Point in image that represents the center of the transformation (i.e.,
the origin in cartesian space). Values can be of type <em class="xref py py-obj">float</em>.
If no value is given, the center is assumed to be the center point
of the image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>Radius of the circle that bounds the area to be transformed.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">tuple (row, col), optional</span></dt><dd></dd>
<dt><strong>scaling</strong><span class="classifier">{‘linear’, ‘log’}, optional</span></dt><dd><p>Specify whether the image warp is polar or log-polar. Defaults to
‘linear’.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the image is a 3-D array in which the third axis is to be
interpreted as multiple channels. If set to <em class="xref py py-obj">False</em> (default), only 2-D
arrays are accepted. This argument is deprecated: specify
<em class="xref py py-obj">channel_axis</em> instead.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">keyword arguments</span></dt><dd><p>Passed to <em class="xref py py-obj">transform.warp</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>warped</strong><span class="classifier">ndarray</span></dt><dd><p>The polar or log-polar warped image.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>multichannel</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <em class="xref py py-obj">channel_axis</em>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 0.19.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Perform a basic polar warp on a grayscale image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">warp_polar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">checkerboard</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p>Perform a log-polar warp on a grayscale image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Perform a log-polar warp on a grayscale image while specifying center,
radius, and output shape:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span> <span class="n">radius</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">output_shape</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Perform a log-polar warp on a color image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">channel_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<section id="examples-using-skimage-transform-warp-polar">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.warp_polar</span></code><a class="headerlink" href="#examples-using-skimage-transform-warp-polar" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Phase correlation (``registration.phase_cross_correlation``) is an efficient method for determi..."><img alt="Using Polar and Log-Polar Transformations for Registration" src="../_images/sphx_glr_plot_register_rotation_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_register_rotation.html#sphx-glr-auto-examples-registration-plot-register-rotation-py"><span class="std std-ref">Using Polar and Log-Polar Transformations for Registration</span></a></p>
  <div class="sphx-glr-thumbnail-title">Using Polar and Log-Polar Transformations for Registration</div>
</div></div></section>
</section>
<section id="affinetransform">
<h2><a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a><a class="headerlink" href="#affinetransform" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">AffineTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shear</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L813-L945"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.AffineTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform._geometric.ProjectiveTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a></p>
<p>Affine transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">sx</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">sy</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">rotation</span> <span class="o">+</span> <span class="n">shear</span><span class="p">)</span> <span class="o">+</span> <span class="n">a2</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">sx</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">sy</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">rotation</span> <span class="o">+</span> <span class="n">shear</span><span class="p">)</span> <span class="o">+</span> <span class="n">b2</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">sx</span></code> and <code class="docutils literal notranslate"><span class="pre">sy</span></code> are scale factors in the x and y directions,
and the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">a1</span>  <span class="n">a2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">b1</span>  <span class="n">b2</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>In 2D, the transformation parameters can be given as the homogeneous
transformation matrix, above, or as the implicit parameters, scale,
rotation, shear, and translation in x (a2) and y (b2). For 3D and higher,
only the matrix form is allowed.</p>
<p>In narrower transforms, such as the Euclidean (only rotation and
translation) or Similarity (rotation, translation, and a global scale
factor) transforms, it is possible to specify 3D transforms using implicit
parameters also.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>matrix</strong><span class="classifier">(D+1, D+1) array_like, optional</span></dt><dd><p>Homogeneous transformation matrix. If this matrix is provided, it is an
error to provide any of scale, rotation, shear, or translation.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">{s as float or (sx, sy) as array, list or tuple}, optional</span></dt><dd><p>Scale factor(s). If a single value, it will be assigned to both
sx and sy. Only available for 2D.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17: </span>Added support for supplying a single scalar value.</p>
</div>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Rotation angle in counter-clockwise direction as radians. Only
available for 2D.</p>
</dd>
<dt><strong>shear</strong><span class="classifier">float, optional</span></dt><dd><p>Shear angle in counter-clockwise direction as radians. Only available
for 2D.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(tx, ty) as array, list or tuple, optional</span></dt><dd><p>Translation parameters. Only available for 2D.</p>
</dd>
<dt><strong>dimensionality</strong><span class="classifier">int, optional</span></dt><dd><p>The dimensionality of the transform. This is not used if any other
parameters are provided.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ValueError</dt><dd><p>If both <code class="docutils literal notranslate"><span class="pre">matrix</span></code> and any of the other parameters are provided.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(D+1, D+1) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shear</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L875-L920"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.AffineTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform.rotation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rotation</span></span><a class="headerlink" href="#skimage.transform.AffineTransform.rotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform.scale">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">scale</span></span><a class="headerlink" href="#skimage.transform.AffineTransform.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform.shear">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shear</span></span><a class="headerlink" href="#skimage.transform.AffineTransform.shear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.AffineTransform.translation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">translation</span></span><a class="headerlink" href="#skimage.transform.AffineTransform.translation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<section id="examples-using-skimage-transform-affinetransform">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.AffineTransform</span></code><a class="headerlink" href="#examples-using-skimage-transform-affinetransform" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="`Homographies &lt;https://en.wikipedia.org/wiki/Homography&gt;`_ are transformations of a Euclidean s..."><img alt="Types of homographies" src="../_images/sphx_glr_plot_transform_types_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_transform_types.html#sphx-glr-auto-examples-transform-plot-transform-types-py"><span class="std std-ref">Types of homographies</span></a></p>
  <div class="sphx-glr-thumbnail-title">Types of homographies</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this simplified example we first generate two synthetic images as if they were taken from di..."><img alt="Robust matching using RANSAC" src="../_images/sphx_glr_plot_matching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_matching.html#sphx-glr-auto-examples-transform-plot-matching-py"><span class="std std-ref">Robust matching using RANSAC</span></a></p>
  <div class="sphx-glr-thumbnail-title">Robust matching using RANSAC</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Detect corner points using the Harris corner detector and determine the subpixel position of co..."><img alt="Corner detection" src="../_images/sphx_glr_plot_corner_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_corner.html#sphx-glr-auto-examples-features-detection-plot-corner-py"><span class="std std-ref">Corner detection</span></a></p>
  <div class="sphx-glr-thumbnail-title">Corner detection</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="The CENSURE feature detector is a scale-invariant center-surround detector (CENSURE) that claim..."><img alt="CENSURE feature detector" src="../_images/sphx_glr_plot_censure_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_censure.html#sphx-glr-auto-examples-features-detection-plot-censure-py"><span class="std std-ref">CENSURE feature detector</span></a></p>
  <div class="sphx-glr-thumbnail-title">CENSURE feature detector</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the ORB feature detection and binary description algorithm. It uses a..."><img alt="ORB feature detector and binary descriptor" src="../_images/sphx_glr_plot_orb_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_orb.html#sphx-glr-auto-examples-features-detection-plot-orb-py"><span class="std std-ref">ORB feature detector and binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">ORB feature detector and binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the BRIEF binary description algorithm. The descriptor consists of re..."><img alt="BRIEF binary descriptor" src="../_images/sphx_glr_plot_brief_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_brief.html#sphx-glr-auto-examples-features-detection-plot-brief-py"><span class="std std-ref">BRIEF binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">BRIEF binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the SIFT feature detection and its description algorithm."><img alt="SIFT feature detector and descriptor extractor" src="../_images/sphx_glr_plot_sift_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_sift.html#sphx-glr-auto-examples-features-detection-plot-sift-py"><span class="std std-ref">SIFT feature detector and descriptor extractor</span></a></p>
  <div class="sphx-glr-thumbnail-title">SIFT feature detector and descriptor extractor</div>
</div></div></section>
</section>
<section id="essentialmatrixtransform">
<h2><a class="reference internal" href="#skimage.transform.EssentialMatrixTransform" title="skimage.transform.EssentialMatrixTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">EssentialMatrixTransform</span></code></a><a class="headerlink" href="#essentialmatrixtransform" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.EssentialMatrixTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">EssentialMatrixTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L432-L532"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.EssentialMatrixTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#skimage.transform.FundamentalMatrixTransform" title="skimage.transform._geometric.FundamentalMatrixTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">FundamentalMatrixTransform</span></code></a></p>
<p>Essential matrix transformation.</p>
<p>The essential matrix relates corresponding points between a pair of
calibrated images. The matrix transforms normalized, homogeneous image
points in one image to epipolar lines in the other image.</p>
<p>The essential matrix is only defined for a pair of moving images capturing a
non-planar scene. In the case of pure rotation or planar scenes, the
homography describes the geometric relation between two images
(<a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a>). If the intrinsic calibration of the images is
unknown, the fundamental matrix describes the projective relation between
the two images (<a class="reference internal" href="#skimage.transform.FundamentalMatrixTransform" title="skimage.transform.FundamentalMatrixTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FundamentalMatrixTransform</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rotation</strong><span class="classifier">(3, 3) array_like, optional</span></dt><dd><p>Rotation matrix of the relative camera motion.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(3, 1) array_like, optional</span></dt><dd><p>Translation vector of the relative camera motion. The vector must
have unit length.</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">(3, 3) array_like, optional</span></dt><dd><p>Essential matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r2fbde33858f1-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Hartley, Richard, and Andrew Zisserman. Multiple view geometry in
computer vision. Cambridge university press, 2003.</p>
</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(3, 3) array</span></dt><dd><p>Essential matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.EssentialMatrixTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L468-L496"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.EssentialMatrixTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.EssentialMatrixTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L498-L532"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.EssentialMatrixTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate essential matrix using 8-point algorithm.</p>
<p>The 8-point algorithm requires at least 8 corresponding point pairs for
a well-conditioned solution, otherwise the over-determined solution is
estimated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="euclideantransform">
<h2><a class="reference internal" href="#skimage.transform.EuclideanTransform" title="skimage.transform.EuclideanTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">EuclideanTransform</span></code></a><a class="headerlink" href="#euclideantransform" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.EuclideanTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">EuclideanTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1145-L1280"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.EuclideanTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform._geometric.ProjectiveTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a></p>
<p>Euclidean transformation, also known as a rigid transform.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">a1</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span>
</pre></div>
</div>
<p>where the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">b0</span>  <span class="n">a1</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">a0</span>  <span class="n">b1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>The Euclidean transformation is a rigid transformation with rotation and
translation parameters. The similarity transformation extends the Euclidean
transformation with a single scaling factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(D+1, D+1) array_like, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">float or sequence of float, optional</span></dt><dd><p>Rotation angle in counter-clockwise direction as radians. If given as
a vector, it is interpreted as Euler rotation angles <a class="reference internal" href="#r844fb1ca9398-1" id="id26">[1]</a>. Only 2D
(single rotation) and 3D (Euler rotations) values are supported. For
higher dimensions, you must provide or estimate the transformation
matrix.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">sequence of float, length D, optional</span></dt><dd><p>Translation parameters for each axis.</p>
</dd>
<dt><strong>dimensionality</strong><span class="classifier">int, optional</span></dt><dd><p>The dimensionality of the transform.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r844fb1ca9398-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id26">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions">https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions</a></p>
</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(D+1, D+1) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.EuclideanTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1191-L1238"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.EuclideanTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.EuclideanTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1240-L1264"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.EuclideanTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.EuclideanTransform.rotation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rotation</span></span><a class="headerlink" href="#skimage.transform.EuclideanTransform.rotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.EuclideanTransform.translation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">translation</span></span><a class="headerlink" href="#skimage.transform.EuclideanTransform.translation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<section id="examples-using-skimage-transform-euclideantransform">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.EuclideanTransform</span></code><a class="headerlink" href="#examples-using-skimage-transform-euclideantransform" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In this example, we will see how to use geometric transformations in the context of image proce..."><img alt="Using geometric transformations" src="../_images/sphx_glr_plot_geometric_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_geometric.html#sphx-glr-auto-examples-transform-plot-geometric-py"><span class="std std-ref">Using geometric transformations</span></a></p>
  <div class="sphx-glr-thumbnail-title">Using geometric transformations</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="`Homographies &lt;https://en.wikipedia.org/wiki/Homography&gt;`_ are transformations of a Euclidean s..."><img alt="Types of homographies" src="../_images/sphx_glr_plot_transform_types_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_transform_types.html#sphx-glr-auto-examples-transform-plot-transform-types-py"><span class="std std-ref">Types of homographies</span></a></p>
  <div class="sphx-glr-thumbnail-title">Types of homographies</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates how a set of images can be assembled under the hypothesis of rigid bo..."><img alt="Assemble images with simple image stitching" src="../_images/sphx_glr_plot_stitching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_stitching.html#sphx-glr-auto-examples-registration-plot-stitching-py"><span class="std std-ref">Assemble images with simple image stitching</span></a></p>
  <div class="sphx-glr-thumbnail-title">Assemble images with simple image stitching</div>
</div></div></section>
</section>
<section id="fundamentalmatrixtransform">
<h2><a class="reference internal" href="#skimage.transform.FundamentalMatrixTransform" title="skimage.transform.FundamentalMatrixTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">FundamentalMatrixTransform</span></code></a><a class="headerlink" href="#fundamentalmatrixtransform" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.FundamentalMatrixTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">FundamentalMatrixTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L232-L429"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">GeometricTransform</span></code></p>
<p>Fundamental matrix transformation.</p>
<p>The fundamental matrix relates corresponding points between a pair of
uncalibrated images. The matrix transforms homogeneous image points in one
image to epipolar lines in the other image.</p>
<p>The fundamental matrix is only defined for a pair of moving images. In the
case of pure rotation or planar scenes, the homography describes the
geometric relation between two images (<a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a>). If the
intrinsic calibration of the images is known, the essential matrix describes
the metric relation between the two images (<a class="reference internal" href="#skimage.transform.EssentialMatrixTransform" title="skimage.transform.EssentialMatrixTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EssentialMatrixTransform</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(3, 3) array_like, optional</span></dt><dd><p>Fundamental matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r725e3a484348-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Hartley, Richard, and Andrew Zisserman. Multiple view geometry in
computer vision. Cambridge university press, 2003.</p>
</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(3, 3) array</span></dt><dd><p>Fundamental matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.FundamentalMatrixTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L262-L276"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.FundamentalMatrixTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L368-L400"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate fundamental matrix using 8-point algorithm.</p>
<p>The 8-point algorithm requires at least 8 corresponding point pairs for
a well-conditioned solution, otherwise the over-determined solution is
estimated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.FundamentalMatrixTransform.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L296-L312"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 3) array</span></dt><dd><p>Epipolar lines in the source image.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.FundamentalMatrixTransform.residuals">
<span class="sig-name descname"><span class="pre">residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L402-L429"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Sampson distance.</p>
<p>The Sampson distance is the first approximation to the geometric error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N, ) array</span></dt><dd><p>Sampson distance.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<section id="examples-using-skimage-transform-fundamentalmatrixtransform">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.FundamentalMatrixTransform</span></code><a class="headerlink" href="#examples-using-skimage-transform-fundamentalmatrixtransform" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates how to robustly estimate  epipolar geometry &lt;https://en.wikipedia.org..."><img alt="Fundamental matrix estimation" src="../_images/sphx_glr_plot_fundamental_matrix_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_fundamental_matrix.html#sphx-glr-auto-examples-transform-plot-fundamental-matrix-py"><span class="std std-ref">Fundamental matrix estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Fundamental matrix estimation</div>
</div></div></section>
</section>
<section id="piecewiseaffinetransform">
<h2><a class="reference internal" href="#skimage.transform.PiecewiseAffineTransform" title="skimage.transform.PiecewiseAffineTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseAffineTransform</span></code></a><a class="headerlink" href="#piecewiseaffinetransform" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.PiecewiseAffineTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">PiecewiseAffineTransform</span></span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L948-L1085"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">GeometricTransform</span></code></p>
<p>Piecewise affine transformation.</p>
<p>Control points are used to define the mapping. The transform is based on
a Delaunay triangulation of the points to form a mesh. Each triangle is
used to find a local affine transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affines</strong><span class="classifier">list of AffineTransform objects</span></dt><dd><p>Affine transformations for each triangle in the mesh.</p>
</dd>
<dt><strong>inverse_affines</strong><span class="classifier">list of AffineTransform objects</span></dt><dd><p>Inverse affine transformations for each triangle in the mesh.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.PiecewiseAffineTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L964-L968"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.PiecewiseAffineTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L970-L1015"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, D) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, D) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if all pieces of the model are successfully estimated.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.PiecewiseAffineTransform.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1052-L1085"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<p>Coordinates outside of the mesh will be set to <em class="xref py py-obj">- 1</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) array</span></dt><dd><p>Transformed coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<section id="examples-using-skimage-transform-piecewiseaffinetransform">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.PiecewiseAffineTransform</span></code><a class="headerlink" href="#examples-using-skimage-transform-piecewiseaffinetransform" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use the Piecewise Affine Transformation."><img alt="Piecewise Affine Transformation" src="../_images/sphx_glr_plot_piecewise_affine_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_piecewise_affine.html#sphx-glr-auto-examples-transform-plot-piecewise-affine-py"><span class="std std-ref">Piecewise Affine Transformation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Piecewise Affine Transformation</div>
</div></div></section>
</section>
<section id="polynomialtransform">
<h2><a class="reference internal" href="#skimage.transform.PolynomialTransform" title="skimage.transform.PolynomialTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolynomialTransform</span></code></a><a class="headerlink" href="#polynomialtransform" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.PolynomialTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">PolynomialTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1404-L1574"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">GeometricTransform</span></code></p>
<p>2D polynomial transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
<span class="n">Y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(2, N) array_like, optional</span></dt><dd><p>Polynomial coefficients where <em class="xref py py-obj">N * 2 = (order + 1) * (order + 2)</em>. So,
a_ji is defined in <em class="xref py py-obj">params[0, :]</em> and b_ji in <em class="xref py py-obj">params[1, :]</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(2, N) array</span></dt><dd><p>Polynomial coefficients where <em class="xref py py-obj">N * 2 = (order + 1) * (order + 2)</em>. So,
a_ji is defined in <em class="xref py py-obj">params[0, :]</em> and b_ji in <em class="xref py py-obj">params[1, :]</em>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.PolynomialTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1426-L1438"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.PolynomialTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1440-L1536"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
<span class="n">Y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span> <span class="n">x</span> <span class="n">y</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">...</span> <span class="mi">0</span> <span class="o">...</span>             <span class="mi">0</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="o">...</span>                 <span class="mi">0</span> <span class="mi">1</span> <span class="n">x</span> <span class="n">y</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a00</span> <span class="n">a10</span> <span class="n">a11</span> <span class="n">a20</span> <span class="n">a21</span> <span class="n">a22</span> <span class="o">...</span> <span class="n">ann</span>
       <span class="n">b00</span> <span class="n">b10</span> <span class="n">b11</span> <span class="n">b20</span> <span class="n">b21</span> <span class="n">b22</span> <span class="o">...</span> <span class="n">bnn</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<p>Weights can be applied to each pair of corresponding points to
indicate, particularly in an overdetermined system, if point pairs have
higher or lower confidence or uncertainties associated with them. From
the matrix treatment of least squares problems, these weight values are
normalised, square-rooted, then built into a diagonal matrix, by which
A is multiplied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Polynomial order (number of coefficients is order + 1).</p>
</dd>
<dt><strong>weights</strong><span class="classifier">(N,) array_like, optional</span></dt><dd><p>Relative weight values for each pair of points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.PolynomialTransform.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1569-L1574"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="projectivetransform">
<h2><a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a><a class="headerlink" href="#projectivetransform" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.ProjectiveTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">ProjectiveTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L535-L810"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">GeometricTransform</span></code></p>
<p>Projective transformation.</p>
<p>Apply a projective transformation (homography) on coordinates.</p>
<p>For each homogeneous coordinate <span class="math notranslate nohighlight">\(\mathbf{x} = [x, y, 1]^T\)</span>, its
target position is calculated by multiplying with the given matrix,
<span class="math notranslate nohighlight">\(H\)</span>, to give <span class="math notranslate nohighlight">\(H \mathbf{x}\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">c0</span> <span class="n">c1</span> <span class="mi">1</span> <span class="p">]]</span><span class="o">.</span>
</pre></div>
</div>
<p>E.g., to rotate by theta degrees clockwise, the matrix should be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>  <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>            <span class="mi">0</span>         <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>or, to translate x by 10 and y by 20:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">10</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">20</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">]]</span><span class="o">.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(D+1, D+1) array_like, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
<dt><strong>dimensionality</strong><span class="classifier">int, optional</span></dt><dd><p>The number of dimensions of the transform. This is ignored if
<code class="docutils literal notranslate"><span class="pre">matrix</span></code> is not None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(D+1, D+1) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.ProjectiveTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L575-L585"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.ProjectiveTransform.dimensionality">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dimensionality</span></span><a class="headerlink" href="#skimage.transform.ProjectiveTransform.dimensionality" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimensionality of the transformation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.ProjectiveTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L645-L767"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">c0</span> <span class="n">c1</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<p>Weights can be applied to each pair of corresponding points to
indicate, particularly in an overdetermined system, if point pairs have
higher or lower confidence or uncertainties associated with them. From
the matrix treatment of least squares problems, these weight values are
normalised, square-rooted, then built into a diagonal matrix, by which
A is multiplied.</p>
<p>In case of the affine transformation the coefficients c0 and c1 are 0.
Thus the system of equations is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">(N,) array_like, optional</span></dt><dd><p>Relative weight values for each pair of points.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.ProjectiveTransform.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L629-L643"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords_out</strong><span class="classifier">(N, D) array</span></dt><dd><p>Source coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<section id="examples-using-skimage-transform-projectivetransform">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.ProjectiveTransform</span></code><a class="headerlink" href="#examples-using-skimage-transform-projectivetransform" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In this example, we will see how to use geometric transformations in the context of image proce..."><img alt="Using geometric transformations" src="../_images/sphx_glr_plot_geometric_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_geometric.html#sphx-glr-auto-examples-transform-plot-geometric-py"><span class="std std-ref">Using geometric transformations</span></a></p>
  <div class="sphx-glr-thumbnail-title">Using geometric transformations</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="`Homographies &lt;https://en.wikipedia.org/wiki/Homography&gt;`_ are transformations of a Euclidean s..."><img alt="Types of homographies" src="../_images/sphx_glr_plot_transform_types_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_transform_types.html#sphx-glr-auto-examples-transform-plot-transform-types-py"><span class="std std-ref">Types of homographies</span></a></p>
  <div class="sphx-glr-thumbnail-title">Types of homographies</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this simplified example we first generate two synthetic images as if they were taken from di..."><img alt="Robust matching using RANSAC" src="../_images/sphx_glr_plot_matching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_matching.html#sphx-glr-auto-examples-transform-plot-matching-py"><span class="std std-ref">Robust matching using RANSAC</span></a></p>
  <div class="sphx-glr-thumbnail-title">Robust matching using RANSAC</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates how a set of images can be assembled under the hypothesis of rigid bo..."><img alt="Assemble images with simple image stitching" src="../_images/sphx_glr_plot_stitching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_stitching.html#sphx-glr-auto-examples-registration-plot-stitching-py"><span class="std std-ref">Assemble images with simple image stitching</span></a></p>
  <div class="sphx-glr-thumbnail-title">Assemble images with simple image stitching</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Detect corner points using the Harris corner detector and determine the subpixel position of co..."><img alt="Corner detection" src="../_images/sphx_glr_plot_corner_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_corner.html#sphx-glr-auto-examples-features-detection-plot-corner-py"><span class="std std-ref">Corner detection</span></a></p>
  <div class="sphx-glr-thumbnail-title">Corner detection</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="The CENSURE feature detector is a scale-invariant center-surround detector (CENSURE) that claim..."><img alt="CENSURE feature detector" src="../_images/sphx_glr_plot_censure_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_censure.html#sphx-glr-auto-examples-features-detection-plot-censure-py"><span class="std std-ref">CENSURE feature detector</span></a></p>
  <div class="sphx-glr-thumbnail-title">CENSURE feature detector</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the ORB feature detection and binary description algorithm. It uses a..."><img alt="ORB feature detector and binary descriptor" src="../_images/sphx_glr_plot_orb_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_orb.html#sphx-glr-auto-examples-features-detection-plot-orb-py"><span class="std std-ref">ORB feature detector and binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">ORB feature detector and binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the BRIEF binary description algorithm. The descriptor consists of re..."><img alt="BRIEF binary descriptor" src="../_images/sphx_glr_plot_brief_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_brief.html#sphx-glr-auto-examples-features-detection-plot-brief-py"><span class="std std-ref">BRIEF binary descriptor</span></a></p>
  <div class="sphx-glr-thumbnail-title">BRIEF binary descriptor</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the SIFT feature detection and its description algorithm."><img alt="SIFT feature detector and descriptor extractor" src="../_images/sphx_glr_plot_sift_thumb.png" />
<p><a class="reference internal" href="../auto_examples/features_detection/plot_sift.html#sphx-glr-auto-examples-features-detection-plot-sift-py"><span class="std std-ref">SIFT feature detector and descriptor extractor</span></a></p>
  <div class="sphx-glr-thumbnail-title">SIFT feature detector and descriptor extractor</div>
</div></div></section>
</section>
<section id="similaritytransform">
<h2><a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimilarityTransform</span></code></a><a class="headerlink" href="#similaritytransform" title="Permalink to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="skimage.transform.SimilarityTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.transform.</span></span><span class="sig-name descname"><span class="pre">SimilarityTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1283-L1401"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.SimilarityTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#skimage.transform.EuclideanTransform" title="skimage.transform._geometric.EuclideanTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">EuclideanTransform</span></code></a></p>
<p>Similarity transformation.</p>
<p>Has the following form in 2D:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">a1</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">s</span></code> is a scale factor and the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">b0</span>  <span class="n">a1</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">a0</span>  <span class="n">b1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>The similarity transformation extends the Euclidean transformation with a
single scaling factor in addition to the rotation and translation
parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(dim+1, dim+1) array_like, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">float, optional</span></dt><dd><p>Scale factor. Implemented only for 2D and 3D.</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Rotation angle in counter-clockwise direction as radians.
Implemented only for 2D and 3D. For 3D, this is given in ZYX Euler
angles.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(dim,) array_like, optional</span></dt><dd><p>x, y[, z] translation parameters. Implemented only for 2D and 3D.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(dim+1, dim+1) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.SimilarityTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimensionality</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1324-L1363"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.SimilarityTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.transform.SimilarityTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/transform/_geometric.py#L1365-L1390"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.transform.SimilarityTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array_like</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="skimage.transform.SimilarityTransform.scale">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">scale</span></span><a class="headerlink" href="#skimage.transform.SimilarityTransform.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<section id="examples-using-skimage-transform-similaritytransform">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.SimilarityTransform</span></code><a class="headerlink" href="#examples-using-skimage-transform-similaritytransform" title="Permalink to this heading">¶</a></h3>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In this example, we will see how to use geometric transformations in the context of image proce..."><img alt="Using geometric transformations" src="../_images/sphx_glr_plot_geometric_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_geometric.html#sphx-glr-auto-examples-transform-plot-geometric-py"><span class="std std-ref">Using geometric transformations</span></a></p>
  <div class="sphx-glr-thumbnail-title">Using geometric transformations</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="`Homographies &lt;https://en.wikipedia.org/wiki/Homography&gt;`_ are transformations of a Euclidean s..."><img alt="Types of homographies" src="../_images/sphx_glr_plot_transform_types_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_transform_types.html#sphx-glr-auto-examples-transform-plot-transform-types-py"><span class="std std-ref">Types of homographies</span></a></p>
  <div class="sphx-glr-thumbnail-title">Types of homographies</div>
</div></div></section>
</section>
</section>


        </div>
    </div>
    <div class="forum link" role="contentinfo">
	 
    </div>
    <div class="well footer" role="contentinfo">
        <small>
            &copy; Copyright the scikit-image development team.
            Created using <a href="https://getbootstrap.com/">Bootstrap</a> and <a href="https://www.sphinx-doc.org/">Sphinx</a>.
        </small>
    </div>
</body>
</html>
