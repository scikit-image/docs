
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>skimage.restoration &#8212; skimage 0.24.1rc0.dev0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/theme_overrides.css?v=4340df76" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=a22486ce"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script data-domain="scikit-image.org" defer="defer" src="https://views.scientific-python.org/js/script.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'api/skimage.restoration';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.15.4';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://scikit-image.org/docs/dev/_static/version_switcher.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = 'dev';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = true;
        </script>
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="skimage.segmentation" href="skimage.segmentation.html" />
    <link rel="prev" title="skimage.registration" href="skimage.registration.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">

  
     
  

<a class="navbar-brand logo" href="https://scikit-image.org">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="scikit-image's logo, showing a snake's head overlayed with green and orange"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="scikit-image's logo, showing a snake's head overlayed with green and orange"/>`);</script>
  
  
    <p class="title logo__title">scikit-image</p>
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../user_guide/index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../auto_examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="api.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../release_notes/index.html">
    Release notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../development/index.html">
    Development
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../about/index.html">
    About
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-2"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-2"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-2"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-2">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/scikit-image/scikit-image" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/scikit-image/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-box fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../user_guide/index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../auto_examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="api.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../release_notes/index.html">
    Release notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../development/index.html">
    Development
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../about/index.html">
    About
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-3"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-3"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-3"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-3">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/scikit-image/scikit-image" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/scikit-image/" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-box fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="skimage.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.color.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.color</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.data.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.data</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.draw.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.draw</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.exposure.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.exposure</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.feature.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.feature</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.filters.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.filters</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.filters.rank.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.filters.rank</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.future.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.future</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.graph.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.graph</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.io.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.io</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.measure.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.measure</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.metrics.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.metrics</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.morphology.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.morphology</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.registration.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.registration</span></code></a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.restoration</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.segmentation.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.segmentation</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.transform.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.transform</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.util.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.util</span></code></a></li>
</ul>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="api.html" class="nav-link">API reference</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><code...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="module-skimage.restoration">
<span id="skimage-restoration"></span><h1><a class="reference internal" href="#module-skimage.restoration" title="skimage.restoration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.restoration</span></code></a><a class="headerlink" href="#module-skimage.restoration" title="Link to this heading">#</a></h1>
<p>Image restoration module.</p>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.restoration.ball_kernel" title="skimage.restoration.ball_kernel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ball_kernel</span></code></a></p></td>
<td><p>Create a ball kernel for restoration.rolling_ball.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.restoration.calibrate_denoiser" title="skimage.restoration.calibrate_denoiser"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calibrate_denoiser</span></code></a></p></td>
<td><p>Calibrate a denoising function and return optimal J-invariant version.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.restoration.cycle_spin" title="skimage.restoration.cycle_spin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cycle_spin</span></code></a></p></td>
<td><p>Cycle spinning (repeatedly apply func to shifted versions of x).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.restoration.denoise_bilateral" title="skimage.restoration.denoise_bilateral"><code class="xref py py-obj docutils literal notranslate"><span class="pre">denoise_bilateral</span></code></a></p></td>
<td><p>Denoise image using bilateral filter.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.restoration.denoise_invariant" title="skimage.restoration.denoise_invariant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">denoise_invariant</span></code></a></p></td>
<td><p>Apply a J-invariant version of a denoising function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.restoration.denoise_nl_means" title="skimage.restoration.denoise_nl_means"><code class="xref py py-obj docutils literal notranslate"><span class="pre">denoise_nl_means</span></code></a></p></td>
<td><p>Perform non-local means denoising on 2D-4D grayscale or RGB images.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.restoration.denoise_tv_bregman" title="skimage.restoration.denoise_tv_bregman"><code class="xref py py-obj docutils literal notranslate"><span class="pre">denoise_tv_bregman</span></code></a></p></td>
<td><p>Perform total variation denoising using split-Bregman optimization.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.restoration.denoise_tv_chambolle" title="skimage.restoration.denoise_tv_chambolle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">denoise_tv_chambolle</span></code></a></p></td>
<td><p>Perform total variation denoising in nD.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.restoration.denoise_wavelet" title="skimage.restoration.denoise_wavelet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">denoise_wavelet</span></code></a></p></td>
<td><p>Perform wavelet denoising on an image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.restoration.ellipsoid_kernel" title="skimage.restoration.ellipsoid_kernel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ellipsoid_kernel</span></code></a></p></td>
<td><p>Create an ellipoid kernel for restoration.rolling_ball.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.restoration.estimate_sigma" title="skimage.restoration.estimate_sigma"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_sigma</span></code></a></p></td>
<td><p>Robust wavelet-based estimator of the (Gaussian) noise standard deviation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.restoration.inpaint_biharmonic" title="skimage.restoration.inpaint_biharmonic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inpaint_biharmonic</span></code></a></p></td>
<td><p>Inpaint masked points in image with biharmonic equations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.restoration.richardson_lucy" title="skimage.restoration.richardson_lucy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">richardson_lucy</span></code></a></p></td>
<td><p>Richardson-Lucy deconvolution.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.restoration.rolling_ball" title="skimage.restoration.rolling_ball"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rolling_ball</span></code></a></p></td>
<td><p>Estimate background intensity by rolling/translating a kernel.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.restoration.unsupervised_wiener" title="skimage.restoration.unsupervised_wiener"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unsupervised_wiener</span></code></a></p></td>
<td><p>Unsupervised Wiener-Hunt deconvolution.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.restoration.unwrap_phase" title="skimage.restoration.unwrap_phase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unwrap_phase</span></code></a></p></td>
<td><p>Recover the original from a wrapped phase image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.restoration.wiener" title="skimage.restoration.wiener"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wiener</span></code></a></p></td>
<td><p>Wiener-Hunt deconvolution</p></td>
</tr>
</tbody>
</table>
</div>
<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.ball_kernel">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">ball_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ndim</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/_rolling_ball.py#L130-L164"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.ball_kernel" title="Link to this definition">#</a></dt>
<dd><p>Create a ball kernel for restoration.rolling_ball.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>Radius of the ball.</p>
</dd>
<dt><strong>ndim</strong><span class="classifier">int</span></dt><dd><p>Number of dimensions of the ball. <code class="docutils literal notranslate"><span class="pre">ndim</span></code> should match the
dimensionality of the image the kernel will be applied to.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>kernel</strong><span class="classifier">ndarray</span></dt><dd><p>The kernel containing the surface intensity of the top half
of the ellipsoid.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.restoration.rolling_ball" title="skimage.restoration.rolling_ball"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rolling_ball</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.calibrate_denoiser">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">calibrate_denoiser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">denoise_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">denoise_parameters</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approximate_loss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/j_invariant.py#L200-L300"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.calibrate_denoiser" title="Link to this definition">#</a></dt>
<dd><p>Calibrate a denoising function and return optimal J-invariant version.</p>
<p>The returned function is partially evaluated with optimal parameter values
set for denoising the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input data to be denoised (converted using <code class="xref py py-obj docutils literal notranslate"><span class="pre">img_as_float</span></code>).</p>
</dd>
<dt><strong>denoise_function</strong><span class="classifier">function</span></dt><dd><p>Denoising function to be calibrated.</p>
</dd>
<dt><strong>denoise_parameters</strong><span class="classifier">dict of list</span></dt><dd><p>Ranges of parameters for <code class="xref py py-obj docutils literal notranslate"><span class="pre">denoise_function</span></code> to be calibrated over.</p>
</dd>
<dt><strong>stride</strong><span class="classifier">int, optional</span></dt><dd><p>Stride used in masking procedure that converts <code class="xref py py-obj docutils literal notranslate"><span class="pre">denoise_function</span></code>
to J-invariance.</p>
</dd>
<dt><strong>approximate_loss</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to approximate the self-supervised loss used to evaluate the
denoiser by only computing it on one masked version of the image.
If False, the runtime will be a factor of <code class="xref py py-obj docutils literal notranslate"><span class="pre">stride**image.ndim</span></code> longer.</p>
</dd>
<dt><strong>extra_output</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, return parameters and losses in addition to the calibrated
denoising function</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>best_denoise_function</strong><span class="classifier">function</span></dt><dd><p>The optimal J-invariant version of <code class="xref py py-obj docutils literal notranslate"><span class="pre">denoise_function</span></code>.</p>
</dd>
<dt>If <code class="xref py py-obj docutils literal notranslate"><span class="pre">extra_output</span></code> is True, the following tuple is also returned:</dt><dd></dd>
<dt><strong>(parameters_tested, losses)</strong><span class="classifier">tuple (list of dict, list of int)</span></dt><dd><p>List of parameters tested for <code class="xref py py-obj docutils literal notranslate"><span class="pre">denoise_function</span></code>, as a dictionary of
kwargs
Self-supervised loss for each set of parameters in <code class="xref py py-obj docutils literal notranslate"><span class="pre">parameters_tested</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The calibration procedure uses a self-supervised mean-square-error loss
to evaluate the performance of J-invariant versions of <code class="xref py py-obj docutils literal notranslate"><span class="pre">denoise_function</span></code>.
The minimizer of the self-supervised loss is also the minimizer of the
ground-truth loss (i.e., the true MSE error) [1]. The returned function
can be used on the original noisy image, or other images with similar
characteristics.</p>
<dl class="simple">
<dt>Increasing the stride increases the performance of <code class="xref py py-obj docutils literal notranslate"><span class="pre">best_denoise_function</span></code></dt><dd><p>at the expense of increasing its runtime. It has no effect on the runtime
of the calibration.</p>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r2b636381f652-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>J. Batson &amp; L. Royer. Noise2Self: Blind Denoising by Self-Supervision,
International Conference on Machine Learning, p. 524-533 (2019).</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">color</span><span class="p">,</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.restoration</span> <span class="kn">import</span> <span class="n">denoise_tv_chambolle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()[:</span><span class="mi">50</span><span class="p">,</span> <span class="p">:</span><span class="mi">50</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noisy</span> <span class="o">=</span> <span class="n">img</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denoising_function</span> <span class="o">=</span> <span class="n">calibrate_denoiser</span><span class="p">(</span><span class="n">noisy</span><span class="p">,</span> <span class="n">denoise_tv_chambolle</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">denoise_parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denoised_img</span> <span class="o">=</span> <span class="n">denoising_function</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.cycle_spin">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">cycle_spin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_shifts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_workers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func_kw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/_cycle_spin.py#L50-L164"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.cycle_spin" title="Link to this definition">#</a></dt>
<dd><p>Cycle spinning (repeatedly apply func to shifted versions of x).</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>x</strong><span class="classifier">array-like</span></dt><dd><p>Data for input to <code class="docutils literal notranslate"><span class="pre">func</span></code>.</p>
</dd>
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>A function to apply to circularly shifted versions of <code class="docutils literal notranslate"><span class="pre">x</span></code>.  Should
take <code class="docutils literal notranslate"><span class="pre">x</span></code> as its first argument. Any additional arguments can be
supplied via <code class="docutils literal notranslate"><span class="pre">func_kw</span></code>.</p>
</dd>
<dt><strong>max_shifts</strong><span class="classifier">int or tuple</span></dt><dd><p>If an integer, shifts in <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">max_shifts+1)</span></code> will be used along
each axis of <code class="docutils literal notranslate"><span class="pre">x</span></code>. If a tuple, <code class="docutils literal notranslate"><span class="pre">range(0,</span> <span class="pre">max_shifts[i]+1)</span></code> will be
along axis i.</p>
</dd>
<dt><strong>shift_steps</strong><span class="classifier">int or tuple, optional</span></dt><dd><p>The step size for the shifts applied along axis, i, are::
<code class="docutils literal notranslate"><span class="pre">range((0,</span> <span class="pre">max_shifts[i]+1,</span> <span class="pre">shift_steps[i]))</span></code>. If an integer is
provided, the same step size is used for all axes.</p>
</dd>
<dt><strong>num_workers</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of parallel threads to use during cycle spinning. If set to
<code class="docutils literal notranslate"><span class="pre">None</span></code>, the full set of available cores are used.</p>
</dd>
<dt><strong>func_kw</strong><span class="classifier">dict, optional</span></dt><dd><p>Additional keyword arguments to supply to <code class="docutils literal notranslate"><span class="pre">func</span></code>.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>avg_y</strong><span class="classifier">np.ndarray</span></dt><dd><p>The output of <code class="docutils literal notranslate"><span class="pre">func(x,</span> <span class="pre">**func_kw)</span></code> averaged over all combinations of
the specified axis shifts.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Cycle spinning was proposed as a way to approach shift-invariance via
performing several circular shifts of a shift-variant transform <a class="reference internal" href="#r67eed921dbd3-1" id="id2">[1]</a>.</p>
<p>For a n-level discrete wavelet transforms, one may wish to perform all
shifts up to <code class="docutils literal notranslate"><span class="pre">max_shifts</span> <span class="pre">=</span> <span class="pre">2**n</span> <span class="pre">-</span> <span class="pre">1</span></code>. In practice, much of the benefit
can often be realized with only a small number of shifts per axis.</p>
<p>For transforms such as the blockwise discrete cosine transform, one may
wish to evaluate shifts up to the block size used by the transform.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r67eed921dbd3-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>R.R. Coifman and D.L. Donoho.  “Translation-Invariant De-Noising”.
Wavelets and Statistics, Lecture Notes in Statistics, vol.103.
Springer, New York, 1995, pp.125-150.
<a class="reference external" href="https://doi.org/10.1007/978-1-4612-2544-7_9">DOI:10.1007/978-1-4612-2544-7_9</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">skimage.data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">img_as_float</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.restoration</span> <span class="kn">import</span> <span class="n">denoise_tv_chambolle</span><span class="p">,</span> <span class="n">cycle_spin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">img_as_float</span><span class="p">(</span><span class="n">skimage</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">img</span> <span class="o">+</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denoised</span> <span class="o">=</span> <span class="n">cycle_spin</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">denoise_tv_chambolle</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">max_shifts</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.denoise_bilateral">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">denoise_bilateral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">win_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_spatial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/_denoise.py#L94-L278"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.denoise_bilateral" title="Link to this definition">#</a></dt>
<dd><p>Denoise image using bilateral filter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray, shape (M, N[, 3])</span></dt><dd><p>Input image, 2D grayscale or RGB.</p>
</dd>
<dt><strong>win_size</strong><span class="classifier">int</span></dt><dd><p>Window size for filtering.
If win_size is not specified, it is calculated as
<code class="docutils literal notranslate"><span class="pre">max(5,</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">ceil(3</span> <span class="pre">*</span> <span class="pre">sigma_spatial)</span> <span class="pre">+</span> <span class="pre">1)</span></code>.</p>
</dd>
<dt><strong>sigma_color</strong><span class="classifier">float</span></dt><dd><p>Standard deviation for grayvalue/color distance (radiometric
similarity). A larger value results in averaging of pixels with larger
radiometric differences. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the standard deviation of
<code class="docutils literal notranslate"><span class="pre">image</span></code> will be used.</p>
</dd>
<dt><strong>sigma_spatial</strong><span class="classifier">float</span></dt><dd><p>Standard deviation for range distance. A larger value results in
averaging of pixels with larger spatial differences.</p>
</dd>
<dt><strong>bins</strong><span class="classifier">int</span></dt><dd><p>Number of discrete values for Gaussian weights of color filtering.
A larger value results in improved accuracy.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}</span></dt><dd><p>How to handle values outside the image borders. See
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v2.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a> for detail.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">int or float</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the image is assumed to be grayscale (single-channel).
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>denoised</strong><span class="classifier">ndarray</span></dt><dd><p>Denoised image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is an edge-preserving, denoising filter. It averages pixels based on
their spatial closeness and radiometric similarity <a class="reference internal" href="#rb832e60bc162-1" id="id4">[1]</a>.</p>
<p>Spatial closeness is measured by the Gaussian function of the Euclidean
distance between two pixels and a certain standard deviation
(<code class="xref py py-obj docutils literal notranslate"><span class="pre">sigma_spatial</span></code>).</p>
<p>Radiometric similarity is measured by the Gaussian function of the
Euclidean distance between two color values and a certain standard
deviation (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sigma_color</span></code>).</p>
<p>Note that, if the image is of any <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></a> dtype, <code class="docutils literal notranslate"><span class="pre">image</span></code> will be
converted using the <code class="xref py py-obj docutils literal notranslate"><span class="pre">img_as_float</span></code> function and thus the standard
deviation (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sigma_color</span></code>) will be in range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>.</p>
<p>For more information on scikit-image’s data type conversions and how
images are rescaled in these conversions,
see: <a class="reference external" href="https://scikit-image.org/docs/stable/user_guide/data_types.html">https://scikit-image.org/docs/stable/user_guide/data_types.html</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rb832e60bc162-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">1</a><span class="fn-bracket">]</span></span>
<p>C. Tomasi and R. Manduchi. “Bilateral Filtering for Gray and Color
Images.” IEEE International Conference on Computer Vision (1998)
839-846. <a class="reference external" href="https://doi.org/10.1109/ICCV.1998.710815">DOI:10.1109/ICCV.1998.710815</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">img_as_float</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">astro</span> <span class="o">=</span> <span class="n">img_as_float</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">astro</span> <span class="o">=</span> <span class="n">astro</span><span class="p">[</span><span class="mi">220</span><span class="p">:</span><span class="mi">300</span><span class="p">,</span> <span class="mi">220</span><span class="p">:</span><span class="mi">320</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noisy</span> <span class="o">=</span> <span class="n">astro</span> <span class="o">+</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="n">astro</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">astro</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noisy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">noisy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denoised</span> <span class="o">=</span> <span class="n">denoise_bilateral</span><span class="p">(</span><span class="n">noisy</span><span class="p">,</span> <span class="n">sigma_color</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">sigma_spatial</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
<span class="gp">... </span>                             <span class="n">channel_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.denoise_invariant">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">denoise_invariant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">denoise_function</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">masks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">denoiser_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/j_invariant.py#L90-L175"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.denoise_invariant" title="Link to this definition">#</a></dt>
<dd><p>Apply a J-invariant version of a denoising function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray (M[, N[, …]][, C]) of ints, uints or floats</span></dt><dd><p>Input data to be denoised. <code class="xref py py-obj docutils literal notranslate"><span class="pre">image</span></code> can be of any numeric type,
but it is cast into a ndarray of floats (using <code class="xref py py-obj docutils literal notranslate"><span class="pre">img_as_float</span></code>) for the
computation of the denoised image.</p>
</dd>
<dt><strong>denoise_function</strong><span class="classifier">function</span></dt><dd><p>Original denoising function.</p>
</dd>
<dt><strong>stride</strong><span class="classifier">int, optional</span></dt><dd><p>Stride used in masking procedure that converts <code class="xref py py-obj docutils literal notranslate"><span class="pre">denoise_function</span></code>
to J-invariance.</p>
</dd>
<dt><strong>masks</strong><span class="classifier">list of ndarray, optional</span></dt><dd><p>Set of masks to use for computing J-invariant output. If <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a>,
a full set of masks covering the image will be used.</p>
</dd>
<dt><strong>denoiser_kwargs:</strong></dt><dd><p>Keyword arguments passed to <code class="xref py py-obj docutils literal notranslate"><span class="pre">denoise_function</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>Denoised image, of same shape as <code class="xref py py-obj docutils literal notranslate"><span class="pre">image</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A denoising function is J-invariant if the prediction it makes for each
pixel does not depend on the value of that pixel in the original image.
The prediction for each pixel may instead use all the relevant information
contained in the rest of the image, which is typically quite significant.
Any function can be converted into a J-invariant one using a simple masking
procedure, as described in [1].</p>
<p>The pixel-wise error of a J-invariant denoiser is uncorrelated to the noise,
so long as the noise in each pixel is independent. Consequently, the average
difference between the denoised image and the oisy image, the
<em>self-supervised loss</em>, is the same as the difference between the denoised
image and the original clean image, the <em>ground-truth loss</em> (up to a
constant).</p>
<p>This means that the best J-invariant denoiser for a given image can be found
using the noisy data alone, by selecting the denoiser minimizing the self-
supervised loss.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="ra84990e3e758-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>J. Batson &amp; L. Royer. Noise2Self: Blind Denoising by Self-Supervision,
International Conference on Machine Learning, p. 524-533 (2019).</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">skimage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.restoration</span> <span class="kn">import</span> <span class="n">denoise_invariant</span><span class="p">,</span> <span class="n">denoise_tv_chambolle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">img_as_float</span><span class="p">(</span><span class="n">skimage</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">chelsea</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noisy</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">random_noise</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="mf">0.2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denoised</span> <span class="o">=</span> <span class="n">denoise_invariant</span><span class="p">(</span><span class="n">noisy</span><span class="p">,</span> <span class="n">denoise_function</span><span class="o">=</span><span class="n">denoise_tv_chambolle</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.denoise_nl_means">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">denoise_nl_means</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/non_local_means.py#L14-L187"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.denoise_nl_means" title="Link to this definition">#</a></dt>
<dd><p>Perform non-local means denoising on 2D-4D grayscale or RGB images.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">2D or 3D ndarray</span></dt><dd><p>Input image to be denoised, which can be 2D or 3D, and grayscale
or RGB (for 2D images only, see <code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> parameter). There can
be any number of channels (does not strictly have to be RGB).</p>
</dd>
<dt><strong>patch_size</strong><span class="classifier">int, optional</span></dt><dd><p>Size of patches used for denoising.</p>
</dd>
<dt><strong>patch_distance</strong><span class="classifier">int, optional</span></dt><dd><p>Maximal distance in pixels where to search patches used for denoising.</p>
</dd>
<dt><strong>h</strong><span class="classifier">float, optional</span></dt><dd><p>Cut-off distance (in gray levels). The higher h, the more permissive
one is in accepting patches. A higher h results in a smoother image,
at the expense of blurring features. For a Gaussian noise of standard
deviation sigma, a rule of thumb is to choose the value of h to be
sigma of slightly less.</p>
</dd>
<dt><strong>fast_mode</strong><span class="classifier">bool, optional</span></dt><dd><p>If True (default value), a fast version of the non-local means
algorithm is used. If False, the original version of non-local means is
used. See the Notes section for more details about the algorithms.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>The standard deviation of the (Gaussian) noise.  If provided, a more
robust computation of patch weights is computed that takes the expected
noise variance into account (see Notes below).</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <code class="xref py py-obj docutils literal notranslate"><span class="pre">img_as_float</span></code>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">ndarray</span></dt><dd><p>Denoised image, of same shape as <code class="xref py py-obj docutils literal notranslate"><span class="pre">image</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The non-local means algorithm is well suited for denoising images with
specific textures. The principle of the algorithm is to average the value
of a given pixel with values of other pixels in a limited neighborhood,
provided that the <em>patches</em> centered on the other pixels are similar enough
to the patch centered on the pixel of interest.</p>
<p>In the original version of the algorithm <a class="reference internal" href="#rc9b3919da938-1" id="id7">[1]</a>, corresponding to
<code class="docutils literal notranslate"><span class="pre">fast=False</span></code>, the computational complexity is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">image</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">patch_size</span> <span class="o">**</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">*</span> <span class="n">patch_distance</span> <span class="o">**</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span>
</pre></div>
</div>
<p>Hence, changing the size of patches or their maximal distance has a
strong effect on computing times, especially for 3-D images.</p>
<p>However, the default behavior corresponds to <code class="docutils literal notranslate"><span class="pre">fast_mode=True</span></code>, for which
another version of non-local means <a class="reference internal" href="#rc9b3919da938-2" id="id8">[2]</a> is used, corresponding to a
complexity of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">image</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">patch_distance</span> <span class="o">**</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span>
</pre></div>
</div>
<p>The computing time depends only weakly on the patch size, thanks to
the computation of the integral of patches distances for a given
shift, that reduces the number of operations <a class="reference internal" href="#rc9b3919da938-1" id="id9">[1]</a>. Therefore, this
algorithm executes faster than the classic algorithm
(<code class="docutils literal notranslate"><span class="pre">fast_mode=False</span></code>), at the expense of using twice as much memory.
This implementation has been proven to be more efficient compared to
other alternatives, see e.g. <a class="reference internal" href="#rc9b3919da938-3" id="id10">[3]</a>.</p>
<p>Compared to the classic algorithm, all pixels of a patch contribute
to the distance to another patch with the same weight, no matter
their distance to the center of the patch. This coarser computation
of the distance can result in a slightly poorer denoising
performance. Moreover, for small images (images with a linear size
that is only a few times the patch size), the classic algorithm can
be faster due to boundary effects.</p>
<p>The image is padded using the <code class="xref py py-obj docutils literal notranslate"><span class="pre">reflect</span></code> mode of <code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.util.pad</span></code>
before denoising.</p>
<p>If the noise standard deviation, <code class="xref py py-obj docutils literal notranslate"><span class="pre">sigma</span></code>, is provided a more robust
computation of patch weights is used.  Subtracting the known noise variance
from the computed patch distances improves the estimates of patch
similarity, giving a moderate improvement to denoising performance <a class="reference internal" href="#rc9b3919da938-4" id="id11">[4]</a>.
It was also mentioned as an option for the fast variant of the algorithm in
<a class="reference internal" href="#rc9b3919da938-3" id="id12">[3]</a>.</p>
<p>When <code class="xref py py-obj docutils literal notranslate"><span class="pre">sigma</span></code> is provided, a smaller <code class="xref py py-obj docutils literal notranslate"><span class="pre">h</span></code> should typically be used to
avoid oversmoothing.  The optimal value for <code class="xref py py-obj docutils literal notranslate"><span class="pre">h</span></code> depends on the image
content and noise level, but a reasonable starting point is
<code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">0.8</span> <span class="pre">*</span> <span class="pre">sigma</span></code> when <code class="xref py py-obj docutils literal notranslate"><span class="pre">fast_mode</span></code> is <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code></a>, or <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">0.6</span> <span class="pre">*</span> <span class="pre">sigma</span></code> when
<code class="xref py py-obj docutils literal notranslate"><span class="pre">fast_mode</span></code> is <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code></a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rc9b3919da938-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id7">1</a>,<a role="doc-backlink" href="#id9">2</a>)</span>
<p>A. Buades, B. Coll, &amp; J-M. Morel. A non-local algorithm for image
denoising. In CVPR 2005, Vol. 2, pp. 60-65, IEEE.
<a class="reference external" href="https://doi.org/10.1109/CVPR.2005.38">DOI:10.1109/CVPR.2005.38</a></p>
</div>
<div class="citation" id="rc9b3919da938-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">2</a><span class="fn-bracket">]</span></span>
<p>J. Darbon, A. Cunha, T.F. Chan, S. Osher, and G.J. Jensen, Fast
nonlocal filtering applied to electron cryomicroscopy, in 5th IEEE
International Symposium on Biomedical Imaging: From Nano to Macro,
2008, pp. 1331-1334.
<a class="reference external" href="https://doi.org/10.1109/ISBI.2008.4541250">DOI:10.1109/ISBI.2008.4541250</a></p>
</div>
<div class="citation" id="rc9b3919da938-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id10">1</a>,<a role="doc-backlink" href="#id12">2</a>)</span>
<p>Jacques Froment. Parameter-Free Fast Pixelwise Non-Local Means
Denoising. Image Processing On Line, 2014, vol. 4, pp. 300-326.
<a class="reference external" href="https://doi.org/10.5201/ipol.2014.120">DOI:10.5201/ipol.2014.120</a></p>
</div>
<div class="citation" id="rc9b3919da938-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">4</a><span class="fn-bracket">]</span></span>
<p>A. Buades, B. Coll, &amp; J-M. Morel. Non-Local Means Denoising.
Image Processing On Line, 2011, vol. 1, pp. 208-212.
<a class="reference external" href="https://doi.org/10.5201/ipol.2011.bcm_nlm">DOI:10.5201/ipol.2011.bcm_nlm</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+=</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denoised_a</span> <span class="o">=</span> <span class="n">denoise_nl_means</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.denoise_tv_bregman">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">denoise_tv_bregman</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isotropic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/_denoise.py#L281-L399"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.denoise_tv_bregman" title="Link to this definition">#</a></dt>
<dd><p>Perform total variation denoising using split-Bregman optimization.</p>
<p>Given <span class="math notranslate nohighlight">\(f\)</span>, a noisy image (input data),
total variation denoising (also known as total variation regularization)
aims to find an image <span class="math notranslate nohighlight">\(u\)</span> with less total variation than <span class="math notranslate nohighlight">\(f\)</span>,
under the constraint that <span class="math notranslate nohighlight">\(u\)</span> remain similar to <span class="math notranslate nohighlight">\(f\)</span>.
This can be expressed by the Rudin–Osher–Fatemi (ROF) minimization
problem:</p>
<div class="math notranslate nohighlight">
\[\min_{u} \sum_{i=0}^{N-1} \left( \left| \nabla{u_i} \right| + \frac{\lambda}{2}(f_i - u_i)^2 \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda\)</span> is a positive parameter.
The first term of this cost function is the total variation;
the second term represents data fidelity. As <span class="math notranslate nohighlight">\(\lambda \to 0\)</span>,
the total variation term dominates, forcing the solution to have smaller
total variation, at the expense of looking less like the input data.</p>
<p>This code is an implementation of the split Bregman algorithm of Goldstein
and Osher to solve the ROF problem (<a class="reference internal" href="#rc0e3588f2bc3-1" id="id17">[1]</a>, <a class="reference internal" href="#rc0e3588f2bc3-2" id="id18">[2]</a>, <a class="reference internal" href="#rc0e3588f2bc3-3" id="id19">[3]</a>).</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image to be denoised (converted using <a class="reference internal" href="skimage.util.html#skimage.util.img_as_float" title="skimage.util.img_as_float"><code class="xref py py-func docutils literal notranslate"><span class="pre">img_as_float()</span></code></a>).</p>
</dd>
<dt><strong>weight</strong><span class="classifier">float, optional</span></dt><dd><p>Denoising weight. It is equal to <span class="math notranslate nohighlight">\(\frac{\lambda}{2}\)</span>. Therefore,
the smaller the <code class="xref py py-obj docutils literal notranslate"><span class="pre">weight</span></code>, the more denoising (at
the expense of less similarity to <code class="xref py py-obj docutils literal notranslate"><span class="pre">image</span></code>).</p>
</dd>
<dt><strong>eps</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance <span class="math notranslate nohighlight">\(\varepsilon &gt; 0\)</span> for the stop criterion:
The algorithm stops when <span class="math notranslate nohighlight">\(\|u_n - u_{n-1}\|_2 &lt; \varepsilon\)</span>.</p>
</dd>
<dt><strong>max_num_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Maximal number of iterations used for the optimization.</p>
</dd>
<dt><strong>isotropic</strong><span class="classifier">boolean, optional</span></dt><dd><p>Switch between isotropic and anisotropic TV denoising.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the image is assumed to be grayscale (single-channel).
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>u</strong><span class="classifier">ndarray</span></dt><dd><p>Denoised image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.restoration.denoise_tv_chambolle" title="skimage.restoration.denoise_tv_chambolle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">denoise_tv_chambolle</span></code></a></dt><dd><p>Perform total variation denoising in nD.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Ensure that <code class="xref py py-obj docutils literal notranslate"><span class="pre">channel_axis</span></code> parameter is set appropriately for color
images.</p>
<p>The principle of total variation denoising is explained in <a class="reference internal" href="#rc0e3588f2bc3-4" id="id20">[4]</a>.
It is about minimizing the total variation of an image,
which can be roughly described as
the integral of the norm of the image gradient. Total variation
denoising tends to produce cartoon-like images, that is,
piecewise-constant images.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rc0e3588f2bc3-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">1</a><span class="fn-bracket">]</span></span>
<p>Tom Goldstein and Stanley Osher, “The Split Bregman Method For L1
Regularized Problems”,
<a class="reference external" href="https://ww3.math.ucla.edu/camreport/cam08-29.pdf">https://ww3.math.ucla.edu/camreport/cam08-29.pdf</a></p>
</div>
<div class="citation" id="rc0e3588f2bc3-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">2</a><span class="fn-bracket">]</span></span>
<p>Pascal Getreuer, “Rudin–Osher–Fatemi Total Variation Denoising
using Split Bregman” in Image Processing On Line on 2012–05–19,
<a class="reference external" href="https://www.ipol.im/pub/art/2012/g-tvd/article_lr.pdf">https://www.ipol.im/pub/art/2012/g-tvd/article_lr.pdf</a></p>
</div>
<div class="citation" id="rc0e3588f2bc3-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id19">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://web.math.ucsb.edu/~cgarcia/UGProjects/BregmanAlgorithms_JacquelineBush.pdf">https://web.math.ucsb.edu/~cgarcia/UGProjects/BregmanAlgorithms_JacquelineBush.pdf</a></p>
</div>
<div class="citation" id="rc0e3588f2bc3-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id20">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Total_variation_denoising">https://en.wikipedia.org/wiki/Total_variation_denoising</a></p>
</div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.denoise_tv_chambolle">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">denoise_tv_chambolle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0002</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/_denoise.py#L489-L605"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.denoise_tv_chambolle" title="Link to this definition">#</a></dt>
<dd><p>Perform total variation denoising in nD.</p>
<p>Given <span class="math notranslate nohighlight">\(f\)</span>, a noisy image (input data),
total variation denoising (also known as total variation regularization)
aims to find an image <span class="math notranslate nohighlight">\(u\)</span> with less total variation than <span class="math notranslate nohighlight">\(f\)</span>,
under the constraint that <span class="math notranslate nohighlight">\(u\)</span> remain similar to <span class="math notranslate nohighlight">\(f\)</span>.
This can be expressed by the Rudin–Osher–Fatemi (ROF) minimization
problem:</p>
<div class="math notranslate nohighlight">
\[\min_{u} \sum_{i=0}^{N-1} \left( \left| \nabla{u_i} \right| + \frac{\lambda}{2}(f_i - u_i)^2 \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda\)</span> is a positive parameter.
The first term of this cost function is the total variation;
the second term represents data fidelity. As <span class="math notranslate nohighlight">\(\lambda \to 0\)</span>,
the total variation term dominates, forcing the solution to have smaller
total variation, at the expense of looking less like the input data.</p>
<p>This code is an implementation of the algorithm proposed by Chambolle
in <a class="reference internal" href="#r3f46bb237e10-1" id="id25">[1]</a> to solve the ROF problem.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image to be denoised. If its dtype is not float, it gets
converted with <a class="reference internal" href="skimage.util.html#skimage.util.img_as_float" title="skimage.util.img_as_float"><code class="xref py py-func docutils literal notranslate"><span class="pre">img_as_float()</span></code></a>.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">float, optional</span></dt><dd><p>Denoising weight. It is equal to <span class="math notranslate nohighlight">\(\frac{1}{\lambda}\)</span>. Therefore,
the greater the <code class="xref py py-obj docutils literal notranslate"><span class="pre">weight</span></code>, the more denoising (at the expense of
fidelity to <code class="xref py py-obj docutils literal notranslate"><span class="pre">image</span></code>).</p>
</dd>
<dt><strong>eps</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance <span class="math notranslate nohighlight">\(\varepsilon &gt; 0\)</span> for the stop criterion (compares to
absolute value of relative difference of the cost function <span class="math notranslate nohighlight">\(E\)</span>):
The algorithm stops when <span class="math notranslate nohighlight">\(|E_{n-1} - E_n| &lt; \varepsilon * E_0\)</span>.</p>
</dd>
<dt><strong>max_num_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Maximal number of iterations used for the optimization.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the image is assumed to be grayscale (single-channel).
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>u</strong><span class="classifier">ndarray</span></dt><dd><p>Denoised image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.restoration.denoise_tv_bregman" title="skimage.restoration.denoise_tv_bregman"><code class="xref py py-obj docutils literal notranslate"><span class="pre">denoise_tv_bregman</span></code></a></dt><dd><p>Perform total variation denoising using split-Bregman optimization.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Make sure to set the <code class="xref py py-obj docutils literal notranslate"><span class="pre">channel_axis</span></code> parameter appropriately for color
images.</p>
<p>The principle of total variation denoising is explained in <a class="reference internal" href="#r3f46bb237e10-2" id="id26">[2]</a>.
It is about minimizing the total variation of an image,
which can be roughly described as
the integral of the norm of the image gradient. Total variation
denoising tends to produce cartoon-like images, that is,
piecewise-constant images.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r3f46bb237e10-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id25">1</a><span class="fn-bracket">]</span></span>
<p>A. Chambolle, An algorithm for total variation minimization and
applications, Journal of Mathematical Imaging and Vision,
Springer, 2004, 20, 89-97.</p>
</div>
<div class="citation" id="r3f46bb237e10-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id26">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Total_variation_denoising">https://en.wikipedia.org/wiki/Total_variation_denoising</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<p>2D example on astronaut image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">color</span><span class="p">,</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())[:</span><span class="mi">50</span><span class="p">,</span> <span class="p">:</span><span class="mi">50</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denoised_img</span> <span class="o">=</span> <span class="n">denoise_tv_chambolle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p>3D example on synthetic data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">22</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">20</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="mi">17</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">+=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">denoise_tv_chambolle</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.denoise_wavelet">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">denoise_wavelet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'db1'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'soft'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelet_levels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convert2ycbcr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BayesShrink'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/_denoise.py#L849-L1046"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.denoise_wavelet" title="Link to this definition">#</a></dt>
<dd><p>Perform wavelet denoising on an image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray (M[, N[, …P]][, C]) of ints, uints or floats</span></dt><dd><p>Input data to be denoised. <code class="xref py py-obj docutils literal notranslate"><span class="pre">image</span></code> can be of any numeric type,
but it is cast into an ndarray of floats for the computation
of the denoised image.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float or list, optional</span></dt><dd><p>The noise standard deviation used when computing the wavelet detail
coefficient threshold(s). When None (default), the noise standard
deviation is estimated via the method in <a class="reference internal" href="#r3b8ec6d23a4e-2" id="id29">[2]</a>.</p>
</dd>
<dt><strong>wavelet</strong><span class="classifier">string, optional</span></dt><dd><p>The type of wavelet to perform and can be any of the options
<code class="docutils literal notranslate"><span class="pre">pywt.wavelist</span></code> outputs. The default is <code class="xref py py-obj docutils literal notranslate"><span class="pre">'db1'</span></code>. For example,
<code class="docutils literal notranslate"><span class="pre">wavelet</span></code> can be any of <code class="docutils literal notranslate"><span class="pre">{'db2',</span> <span class="pre">'haar',</span> <span class="pre">'sym9'}</span></code> and many more.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘soft’, ‘hard’}, optional</span></dt><dd><p>An optional argument to choose the type of denoising performed. It
noted that choosing soft thresholding given additive noise finds the
best approximation of the original image.</p>
</dd>
<dt><strong>wavelet_levels</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of wavelet decomposition levels to use.  The default is
three less than the maximum number of possible decomposition levels.</p>
</dd>
<dt><strong>convert2ycbcr</strong><span class="classifier">bool, optional</span></dt><dd><p>If True and channel_axis is set, do the wavelet denoising in the YCbCr
colorspace instead of the RGB color space. This typically results in
better performance for RGB images.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘BayesShrink’, ‘VisuShrink’}, optional</span></dt><dd><p>Thresholding method to be used. The currently supported methods are
“BayesShrink” <a class="reference internal" href="#r3b8ec6d23a4e-1" id="id30">[1]</a> and “VisuShrink” <a class="reference internal" href="#r3b8ec6d23a4e-2" id="id31">[2]</a>. Defaults to “BayesShrink”.</p>
</dd>
<dt><strong>rescale_sigma</strong><span class="classifier">bool, optional</span></dt><dd><p>If False, no rescaling of the user-provided <code class="docutils literal notranslate"><span class="pre">sigma</span></code> will be
performed. The default of <code class="docutils literal notranslate"><span class="pre">True</span></code> rescales sigma appropriately if the
image is rescaled internally.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.16: </span><code class="docutils literal notranslate"><span class="pre">rescale_sigma</span></code> was introduced in 0.16</p>
</div>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the image is assumed to be grayscale (single-channel).
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Denoised image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The wavelet domain is a sparse representation of the image, and can be
thought of similarly to the frequency domain of the Fourier transform.
Sparse representations have most values zero or near-zero and truly random
noise is (usually) represented by many small values in the wavelet domain.
Setting all values below some threshold to 0 reduces the noise in the
image, but larger thresholds also decrease the detail present in the image.</p>
<p>If the input is 3D, this function performs wavelet denoising on each color
plane separately.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.16: </span>For floating point inputs, the original input range is maintained and
there is no clipping applied to the output. Other input types will be
converted to a floating point value in the range [-1, 1] or [0, 1]
depending on the input image range. Unless <code class="docutils literal notranslate"><span class="pre">rescale_sigma</span> <span class="pre">=</span> <span class="pre">False</span></code>,
any internal rescaling applied to the <code class="docutils literal notranslate"><span class="pre">image</span></code> will also be applied
to <code class="docutils literal notranslate"><span class="pre">sigma</span></code> to maintain the same relative amplitude.</p>
</div>
<p>Many wavelet coefficient thresholding approaches have been proposed. By
default, <code class="docutils literal notranslate"><span class="pre">denoise_wavelet</span></code> applies BayesShrink, which is an adaptive
thresholding method that computes separate thresholds for each wavelet
sub-band as described in <a class="reference internal" href="#r3b8ec6d23a4e-1" id="id32">[1]</a>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">==</span> <span class="pre">&quot;VisuShrink&quot;</span></code>, a single “universal threshold” is applied to
all wavelet detail coefficients as described in <a class="reference internal" href="#r3b8ec6d23a4e-2" id="id33">[2]</a>. This threshold
is designed to remove all Gaussian noise at a given <code class="docutils literal notranslate"><span class="pre">sigma</span></code> with high
probability, but tends to produce images that appear overly smooth.</p>
<p>Although any of the wavelets from <code class="docutils literal notranslate"><span class="pre">PyWavelets</span></code> can be selected, the
thresholding methods assume an orthogonal wavelet transform and may not
choose the threshold appropriately for biorthogonal wavelets. Orthogonal
wavelets are desirable because white noise in the input remains white noise
in the subbands. Biorthogonal wavelets lead to colored noise in the
subbands. Additionally, the orthogonal wavelets in PyWavelets are
orthonormal so that noise variance in the subbands remains identical to the
noise variance of the input. Example orthogonal wavelets are the Daubechies
(e.g. ‘db2’) or symmlet (e.g. ‘sym2’) families.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r3b8ec6d23a4e-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id30">1</a>,<a role="doc-backlink" href="#id32">2</a>)</span>
<p>Chang, S. Grace, Bin Yu, and Martin Vetterli. “Adaptive wavelet
thresholding for image denoising and compression.” Image Processing,
IEEE Transactions on 9.9 (2000): 1532-1546.
<a class="reference external" href="https://doi.org/10.1109/83.862633">DOI:10.1109/83.862633</a></p>
</div>
<div class="citation" id="r3b8ec6d23a4e-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id29">1</a>,<a role="doc-backlink" href="#id31">2</a>,<a role="doc-backlink" href="#id33">3</a>)</span>
<p>D. L. Donoho and I. M. Johnstone. “Ideal spatial adaptation
by wavelet shrinkage.” Biometrika 81.3 (1994): 425-455.
<a class="reference external" href="https://doi.org/10.1093/biomet/81.3.425">DOI:10.1093/biomet/81.3.425</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">color</span><span class="p">,</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">img_as_float</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denoised_img</span> <span class="o">=</span> <span class="n">denoise_wavelet</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">rescale_sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.ellipsoid_kernel">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">ellipsoid_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/_rolling_ball.py#L167-L201"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.ellipsoid_kernel" title="Link to this definition">#</a></dt>
<dd><p>Create an ellipoid kernel for restoration.rolling_ball.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">array-like</span></dt><dd><p>Length of the principal axis of the ellipsoid (excluding
the intensity axis). The kernel needs to have the same
dimensionality as the image it will be applied to.</p>
</dd>
<dt><strong>intensity</strong><span class="classifier">int</span></dt><dd><p>Length of the intensity axis of the ellipsoid.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>kernel</strong><span class="classifier">ndarray</span></dt><dd><p>The kernel containing the surface intensity of the top half
of the ellipsoid.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.restoration.rolling_ball" title="skimage.restoration.rolling_ball"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rolling_ball</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.estimate_sigma">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">estimate_sigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average_sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/_denoise.py#L1049-L1128"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.estimate_sigma" title="Link to this definition">#</a></dt>
<dd><p>Robust wavelet-based estimator of the (Gaussian) noise standard deviation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image for which to estimate the noise standard deviation.</p>
</dd>
<dt><strong>average_sigmas</strong><span class="classifier">bool, optional</span></dt><dd><p>If true, average the channel estimates of <code class="xref py py-obj docutils literal notranslate"><span class="pre">sigma</span></code>.  Otherwise return
a list of sigmas corresponding to each channel.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the image is assumed to be grayscale (single-channel).
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sigma</strong><span class="classifier">float or list</span></dt><dd><p>Estimated noise standard deviation(s).  If <code class="xref py py-obj docutils literal notranslate"><span class="pre">multichannel</span></code> is True and
<code class="xref py py-obj docutils literal notranslate"><span class="pre">average_sigmas</span></code> is False, a separate noise estimate for each channel
is returned.  Otherwise, the average of the individual channel
estimates is returned.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function assumes the noise follows a Gaussian distribution. The
estimation algorithm is based on the median absolute deviation of the
wavelet detail coefficients as described in section 4.2 of <a class="reference internal" href="#rbc448ac95825-1" id="id36">[1]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rbc448ac95825-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id36">1</a><span class="fn-bracket">]</span></span>
<p>D. L. Donoho and I. M. Johnstone. “Ideal spatial adaptation
by wavelet shrinkage.” Biometrika 81.3 (1994): 425-455.
<a class="reference external" href="https://doi.org/10.1093/biomet/81.3.425">DOI:10.1093/biomet/81.3.425</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">skimage.data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">img_as_float</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">img_as_float</span><span class="p">(</span><span class="n">skimage</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">img</span> <span class="o">+</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma_hat</span> <span class="o">=</span> <span class="n">estimate_sigma</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">channel_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.inpaint_biharmonic">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">inpaint_biharmonic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_into_regions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/inpaint.py#L197-L340"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.inpaint_biharmonic" title="Link to this definition">#</a></dt>
<dd><p>Inpaint masked points in image with biharmonic equations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">(M[, N[, …, P]][, C]) ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">(M[, N[, …, P]]) ndarray</span></dt><dd><p>Array of pixels to be inpainted. Have to be the same shape as one
of the ‘image’ channels. Unknown pixels have to be represented with 1,
known pixels - with 0.</p>
</dd>
<dt><strong>split_into_regions</strong><span class="classifier">boolean, optional</span></dt><dd><p>If True, inpainting is performed on a region-by-region basis. This is
likely to be slower, but will have reduced memory requirements.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be a grayscale (single channel) image.
Otherwise, this parameter indicates which axis of the array corresponds
to channels.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19: </span><code class="docutils literal notranslate"><span class="pre">channel_axis</span></code> was added in 0.19.</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(M[, N[, …, P]][, C]) ndarray</span></dt><dd><p>Input image with masked pixels inpainted.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r2b3da8fbc807-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>S.B.Damelin and N.S.Hoang. “On Surface Completion and Image
Inpainting by Biharmonic Functions: Numerical Aspects”,
International Journal of Mathematics and Mathematical Sciences,
Vol. 2018, Article ID 3950312
<a class="reference external" href="https://doi.org/10.1155/2018/3950312">DOI:10.1155/2018/3950312</a></p>
</div>
<div class="citation" id="r2b3da8fbc807-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>C. K. Chui and H. N. Mhaskar, MRA Contextual-Recovery Extension of
Smooth Functions on Manifolds, Appl. and Comp. Harmonic Anal.,
28 (2010), 104-113,
<a class="reference external" href="https://doi.org/10.1016/j.acha.2009.04.004">DOI:10.1016/j.acha.2009.04.004</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">inpaint_biharmonic</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.richardson_lucy">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">richardson_lucy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/deconvolution.py#L361-L421"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.richardson_lucy" title="Link to this definition">#</a></dt>
<dd><p>Richardson-Lucy deconvolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input degraded image (can be n-dimensional).</p>
</dd>
<dt><strong>psf</strong><span class="classifier">ndarray</span></dt><dd><p>The point spread function.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Number of iterations. This parameter plays the role of
regularisation.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">boolean, optional</span></dt><dd><p>True by default. If true, pixel value of the result above 1 or
under -1 are thresholded for skimage pipeline compatibility.</p>
</dd>
<dt><strong>filter_epsilon: float, optional</strong></dt><dd><p>Value below which intermediate results become 0 to avoid division
by small numbers.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>im_deconv</strong><span class="classifier">ndarray</span></dt><dd><p>The deconvolved image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rbba3d9c89116-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Richardson%E2%80%93Lucy_deconvolution">https://en.wikipedia.org/wiki/Richardson%E2%80%93Lucy_deconvolution</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">img_as_float</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">restoration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">img_as_float</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">convolve2d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="mi">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">convolve2d</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">camera</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">camera</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">deconvolved</span> <span class="o">=</span> <span class="n">restoration</span><span class="o">.</span><span class="n">richardson_lucy</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.rolling_ball">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">rolling_ball</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nansafe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_threads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/_rolling_ball.py#L7-L127"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.rolling_ball" title="Link to this definition">#</a></dt>
<dd><p>Estimate background intensity by rolling/translating a kernel.</p>
<p>This rolling ball algorithm estimates background intensity for a
ndimage in case of uneven exposure. It is a generalization of the
frequently used rolling ball algorithm <a class="reference internal" href="#r62497d9283b1-1" id="id41">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The image to be filtered.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">int, optional</span></dt><dd><p>Radius of a ball-shaped kernel to be rolled/translated in the image.
Used if <code class="docutils literal notranslate"><span class="pre">kernel</span> <span class="pre">=</span> <span class="pre">None</span></code>.</p>
</dd>
<dt><strong>kernel</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The kernel to be rolled/translated in the image. It must have the
same number of dimensions as <code class="docutils literal notranslate"><span class="pre">image</span></code>. Kernel is filled with the
intensity of the kernel at that position.</p>
</dd>
<dt><strong>nansafe: bool, optional</strong></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default) assumes that none of the values in <code class="docutils literal notranslate"><span class="pre">image</span></code>
are <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>, and uses a faster implementation.</p>
</dd>
<dt><strong>num_threads: int, optional</strong></dt><dd><p>The maximum number of threads to use. If <code class="docutils literal notranslate"><span class="pre">None</span></code> use the OpenMP
default value; typically equal to the maximum number of virtual cores.
Note: This is an upper limit to the number of threads. The exact number
is determined by the system’s OpenMP library.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>background</strong><span class="classifier">ndarray</span></dt><dd><p>The estimated background of the image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For the pixel that has its background intensity estimated (without loss
of generality at <code class="docutils literal notranslate"><span class="pre">center</span></code>) the rolling ball method centers <code class="docutils literal notranslate"><span class="pre">kernel</span></code>
under it and raises the kernel until the surface touches the image umbra
at some <code class="docutils literal notranslate"><span class="pre">pos=(y,x)</span></code>. The background intensity is then estimated
using the image intensity at that position (<code class="docutils literal notranslate"><span class="pre">image[pos]</span></code>) plus the
difference of <code class="docutils literal notranslate"><span class="pre">kernel[center]</span> <span class="pre">-</span> <span class="pre">kernel[pos]</span></code>.</p>
<p>This algorithm assumes that dark pixels correspond to the background. If
you have a bright background, invert the image before passing it to the
function, e.g., using <code class="xref py py-obj docutils literal notranslate"><span class="pre">utils.invert</span></code>. See the gallery example for details.</p>
<p>This algorithm is sensitive to noise (in particular salt-and-pepper
noise). If this is a problem in your image, you can apply mild
gaussian smoothing before passing the image to this function.</p>
<p>This algorithm’s complexity is polynomial in the radius, with degree equal
to the image dimensionality (a 2D image is N^2, a 3D image is N^3, etc.),
so it can take a long time as the radius grows beyond 30 or so (<a class="reference internal" href="#r62497d9283b1-2" id="id42">[2]</a>, <a class="reference internal" href="#r62497d9283b1-3" id="id43">[3]</a>).
It is an exact N-dimensional calculation; if all you need is an
approximation, faster options to consider are top-hat filtering <a class="reference internal" href="#r62497d9283b1-4" id="id44">[4]</a> or
downscaling-then-upscaling to reduce the size of the input processed.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r62497d9283b1-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id41">1</a><span class="fn-bracket">]</span></span>
<p>Sternberg, Stanley R. “Biomedical image processing.” Computer 1
(1983): 22-34. <a class="reference external" href="https://doi.org/10.1109/MC.1983.1654163">DOI:10.1109/MC.1983.1654163</a></p>
</div>
<div class="citation" id="r62497d9283b1-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id42">2</a><span class="fn-bracket">]</span></span>
<p><a class="github reference external" href="https://github.com/scikit-image/scikit-image/issues/5193">scikit-image/scikit-image#5193</a></p>
</div>
<div class="citation" id="r62497d9283b1-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id43">3</a><span class="fn-bracket">]</span></span>
<p><a class="github reference external" href="https://github.com/scikit-image/scikit-image/issues/7423">scikit-image/scikit-image#7423</a></p>
</div>
<div class="citation" id="r62497d9283b1-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id44">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://forum.image.sc/t/59267/7">https://forum.image.sc/t/59267/7</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.restoration</span> <span class="kn">import</span> <span class="n">rolling_ball</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background</span> <span class="o">=</span> <span class="n">rolling_ball</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_image</span> <span class="o">=</span> <span class="n">image</span> <span class="o">-</span> <span class="n">background</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.restoration</span> <span class="kn">import</span> <span class="n">rolling_ball</span><span class="p">,</span> <span class="n">ellipsoid_kernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">ellipsoid_kernel</span><span class="p">((</span><span class="mi">101</span><span class="p">,</span> <span class="mi">101</span><span class="p">),</span> <span class="mi">75</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background</span> <span class="o">=</span> <span class="n">rolling_ball</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">(),</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_image</span> <span class="o">=</span> <span class="n">image</span> <span class="o">-</span> <span class="n">background</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.unsupervised_wiener">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">unsupervised_wiener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">user_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_real</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/deconvolution.py#L142-L358"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.unsupervised_wiener" title="Link to this definition">#</a></dt>
<dd><p>Unsupervised Wiener-Hunt deconvolution.</p>
<p>Return the deconvolution with a Wiener-Hunt approach, where the
hyperparameters are automatically estimated. The algorithm is a
stochastic iterative process (Gibbs sampler) described in the
reference below. See also <code class="docutils literal notranslate"><span class="pre">wiener</span></code> function.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>The input degraded image.</p>
</dd>
<dt><strong>psf</strong><span class="classifier">ndarray</span></dt><dd><p>The impulse response (input image’s space) or the transfer
function (Fourier space). Both are accepted. The transfer
function is automatically recognized as being complex
(<code class="docutils literal notranslate"><span class="pre">np.iscomplexobj(psf)</span></code>).</p>
</dd>
<dt><strong>reg</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The regularisation operator. The Laplacian by default. It can
be an impulse response or a transfer function, as for the psf.</p>
</dd>
<dt><strong>user_params</strong><span class="classifier">dict, optional</span></dt><dd><p>Dictionary of parameters for the Gibbs sampler. See below.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">boolean, optional</span></dt><dd><p>True by default. If true, pixel values of the result above 1 or
under -1 are thresholded for skimage pipeline compatibility.</p>
</dd>
<dt><strong>rng</strong><span class="classifier">{<a class="reference external" href="https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.Generator" title="(in NumPy v2.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.Generator</span></code></a>, int}, optional</span></dt><dd><p>Pseudo-random number generator.
By default, a PCG64 generator is used (see <a class="reference external" href="https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.default_rng" title="(in NumPy v2.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.random.default_rng()</span></code></a>).
If <code class="xref py py-obj docutils literal notranslate"><span class="pre">rng</span></code> is an int, it is used to seed the generator.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 0.19.</span></p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x_postmean</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>The deconvolved image (the posterior mean).</p>
</dd>
<dt><strong>chains</strong><span class="classifier">dict</span></dt><dd><p>The keys <code class="docutils literal notranslate"><span class="pre">noise</span></code> and <code class="docutils literal notranslate"><span class="pre">prior</span></code> contain the chain list of
noise and prior precision respectively.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>The keys of ``user_params`` are:</strong></dt><dd></dd>
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>The stopping criterion: the norm of the difference between to
successive approximated solution (empirical mean of object
samples, see Notes section). 1e-4 by default.</p>
</dd>
<dt><strong>burnin</strong><span class="classifier">int</span></dt><dd><p>The number of sample to ignore to start computation of the
mean. 15 by default.</p>
</dd>
<dt><strong>min_num_iter</strong><span class="classifier">int</span></dt><dd><p>The minimum number of iterations. 30 by default.</p>
</dd>
<dt><strong>max_num_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of iterations if <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is not
satisfied. 200 by default.</p>
</dd>
<dt><strong>callback</strong><span class="classifier">callable (None by default)</span></dt><dd><p>A user provided callable to which is passed, if the function
exists, the current image sample for whatever purpose. The user
can store the sample, or compute other moments than the
mean. It has no influence on the algorithm execution and is
only for inspection.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The estimated image is design as the posterior mean of a
probability law (from a Bayesian analysis). The mean is defined as
a sum over all the possible images weighted by their respective
probability. Given the size of the problem, the exact sum is not
tractable. This algorithm use of MCMC to draw image under the
posterior law. The practical idea is to only draw highly probable
images since they have the biggest contribution to the mean. At the
opposite, the less probable images are drawn less often since
their contribution is low. Finally, the empirical mean of these
samples give us an estimation of the mean, and an exact
computation with an infinite sample set.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rc01bcdcadf9b-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>François Orieux, Jean-François Giovannelli, and Thomas
Rodet, “Bayesian estimation of regularization and point
spread function parameters for Wiener-Hunt deconvolution”,
J. Opt. Soc. Am. A 27, 1593-1607 (2010)</p>
<p><a class="reference external" href="https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593">https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593</a></p>
<p><a class="reference external" href="https://hal.archives-ouvertes.fr/hal-00674508">https://hal.archives-ouvertes.fr/hal-00674508</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">color</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">restoration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">convolve2d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="mi">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">convolve2d</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">deconvolved_img</span> <span class="o">=</span> <span class="n">restoration</span><span class="o">.</span><span class="n">unsupervised_wiener</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">psf</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.unwrap_phase">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">unwrap_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/unwrap.py#L10-L116"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.unwrap_phase" title="Link to this definition">#</a></dt>
<dd><p>Recover the original from a wrapped phase image.</p>
<p>From an image wrapped to lie in the interval [-pi, pi), recover the
original, unwrapped image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">(M[, N[, P]]) ndarray or masked array of floats</span></dt><dd><p>The values should be in the range [-pi, pi). If a masked array is
provided, the masked entries will not be changed, and their values
will not be used to guide the unwrapping of neighboring, unmasked
values. Masked 1D arrays are not allowed, and will raise a
<a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
</dd>
<dt><strong>wrap_around</strong><span class="classifier">bool or sequence of bool, optional</span></dt><dd><p>When an element of the sequence is  <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.12)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code></a>, the unwrapping process
will regard the edges along the corresponding axis of the image to be
connected and use this connectivity to guide the phase unwrapping
process. If only a single boolean is given, it will apply to all axes.
Wrap around is not supported for 1D arrays.</p>
</dd>
<dt><strong>rng</strong><span class="classifier">{<a class="reference external" href="https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.Generator" title="(in NumPy v2.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.Generator</span></code></a>, int}, optional</span></dt><dd><p>Pseudo-random number generator.
By default, a PCG64 generator is used (see <a class="reference external" href="https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.default_rng" title="(in NumPy v2.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.random.default_rng()</span></code></a>).
If <code class="xref py py-obj docutils literal notranslate"><span class="pre">rng</span></code> is an int, it is used to seed the generator.</p>
<p>Unwrapping relies on a random initialization. This sets the
PRNG to use to achieve deterministic behavior.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>image_unwrapped</strong><span class="classifier">array_like, double</span></dt><dd><p>Unwrapped image of the same shape as the input. If the input <code class="xref py py-obj docutils literal notranslate"><span class="pre">image</span></code>
was a masked array, the mask will be preserved.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If called with a masked 1D array or called with a 1D array and
<code class="docutils literal notranslate"><span class="pre">wrap_around=True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r160444e59583-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Miguel Arevallilo Herraez, David R. Burton, Michael J. Lalor,
and Munther A. Gdeisat, “Fast two-dimensional phase-unwrapping
algorithm based on sorting by reliability following a noncontinuous
path”, Journal Applied Optics, Vol. 41, No. 35 (2002) 7437,</p>
</div>
<div class="citation" id="r160444e59583-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Abdul-Rahman, H., Gdeisat, M., Burton, D., &amp; Lalor, M., “Fast
three-dimensional phase-unwrapping algorithm based on sorting by
reliability following a non-continuous path. In W. Osten,
C. Gorecki, &amp; E. L. Novak (Eds.), Optical Metrology (2005) 32–40,
International Society for Optics and Photonics.</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c0</span><span class="p">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">128</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">128</span><span class="n">j</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">c0</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c1</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_wrapped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">image</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_unwrapped</span> <span class="o">=</span> <span class="n">unwrap_phase</span><span class="p">(</span><span class="n">image_wrapped</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">image_unwrapped</span> <span class="o">-</span> <span class="n">image</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span>   <span class="c1"># A constant offset is normal</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.restoration.wiener">
<span class="sig-prename descclassname"><span class="pre">skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">wiener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">balance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_real</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/main/skimage/restoration/deconvolution.py#L10-L139"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.restoration.wiener" title="Link to this definition">#</a></dt>
<dd><p>Wiener-Hunt deconvolution</p>
<p>Return the deconvolution with a Wiener-Hunt approach (i.e. with
Fourier diagonalisation).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input degraded image (can be n-dimensional).</p>
</dd>
<dt><strong>psf</strong><span class="classifier">ndarray</span></dt><dd><p>Point Spread Function. This is assumed to be the impulse
response (input image space) if the data-type is real, or the
transfer function (Fourier space) if the data-type is
complex. There is no constraints on the shape of the impulse
response. The transfer function must be of shape
<code class="xref py py-obj docutils literal notranslate"><span class="pre">(N1,</span> <span class="pre">N2,</span> <span class="pre">...,</span> <span class="pre">ND)</span></code> if <code class="xref py py-obj docutils literal notranslate"><span class="pre">is_real</span> <span class="pre">is</span> <span class="pre">True</span></code>,
<code class="xref py py-obj docutils literal notranslate"><span class="pre">(N1,</span> <span class="pre">N2,</span> <span class="pre">...,</span> <span class="pre">ND</span> <span class="pre">//</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">1)</span></code> otherwise (see <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.fft.rfftn</span></code>).</p>
</dd>
<dt><strong>balance</strong><span class="classifier">float</span></dt><dd><p>The regularisation parameter value that tunes the balance
between the data adequacy that improve frequency restoration
and the prior adequacy that reduce frequency restoration (to
avoid noise artifacts).</p>
</dd>
<dt><strong>reg</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The regularisation operator. The Laplacian by default. It can
be an impulse response or a transfer function, as for the
psf. Shape constraint is the same as for the <code class="xref py py-obj docutils literal notranslate"><span class="pre">psf</span></code> parameter.</p>
</dd>
<dt><strong>is_real</strong><span class="classifier">boolean, optional</span></dt><dd><p>True by default. Specify if <code class="docutils literal notranslate"><span class="pre">psf</span></code> and <code class="docutils literal notranslate"><span class="pre">reg</span></code> are provided
with hermitian hypothesis, that is only half of the frequency
plane is provided (due to the redundancy of Fourier transform
of real signal). It’s apply only if <code class="docutils literal notranslate"><span class="pre">psf</span></code> and/or <code class="docutils literal notranslate"><span class="pre">reg</span></code> are
provided as transfer function.  For the hermitian property see
<code class="docutils literal notranslate"><span class="pre">uft</span></code> module or <code class="docutils literal notranslate"><span class="pre">np.fft.rfftn</span></code>.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">boolean, optional</span></dt><dd><p>True by default. If True, pixel values of the result above 1 or
under -1 are thresholded for skimage pipeline compatibility.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>im_deconv</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>The deconvolved image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function applies the Wiener filter to a noisy and degraded
image by an impulse response (or PSF). If the data model is</p>
<div class="math notranslate nohighlight">
\[y = Hx + n\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is noise, <span class="math notranslate nohighlight">\(H\)</span> the PSF and <span class="math notranslate nohighlight">\(x\)</span> the
unknown original image, the Wiener filter is</p>
<div class="math notranslate nohighlight">
\[\hat x = F^\dagger \left( |\Lambda_H|^2 + \lambda |\Lambda_D|^2 \right)^{-1}
\Lambda_H^\dagger F y\]</div>
<p>where <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(F^\dagger\)</span> are the Fourier and inverse
Fourier transforms respectively, <span class="math notranslate nohighlight">\(\Lambda_H\)</span> the transfer
function (or the Fourier transform of the PSF, see [Hunt] below)
and <span class="math notranslate nohighlight">\(\Lambda_D\)</span> the filter to penalize the restored image
frequencies (Laplacian by default, that is penalization of high
frequency). The parameter <span class="math notranslate nohighlight">\(\lambda\)</span> tunes the balance
between the data (that tends to increase high frequency, even
those coming from noise), and the regularization.</p>
<p>These methods are then specific to a prior model. Consequently,
the application or the true image nature must correspond to the
prior model. By default, the prior model (Laplacian) introduce
image smoothness or pixel correlation. It can also be interpreted
as high-frequency penalization to compensate the instability of
the solution with respect to the data (sometimes called noise
amplification or “explosive” solution).</p>
<p>Finally, the use of Fourier space implies a circulant property of
<span class="math notranslate nohighlight">\(H\)</span>, see <a class="reference internal" href="#r78add0113d5e-2" id="id52">[2]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r78add0113d5e-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>François Orieux, Jean-François Giovannelli, and Thomas
Rodet, “Bayesian estimation of regularization and point
spread function parameters for Wiener-Hunt deconvolution”,
J. Opt. Soc. Am. A 27, 1593-1607 (2010)</p>
<p><a class="reference external" href="https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593">https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593</a></p>
<p><a class="reference external" href="https://hal.archives-ouvertes.fr/hal-00674508">https://hal.archives-ouvertes.fr/hal-00674508</a></p>
</div>
<div class="citation" id="r78add0113d5e-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id52">2</a><span class="fn-bracket">]</span></span>
<p>B. R. Hunt “A matrix theory proof of the discrete
convolution theorem”, IEEE Trans. on Audio and
Electroacoustics, vol. au-19, no. 4, pp. 285-288, dec. 1971</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">color</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">restoration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">convolve2d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="mi">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">convolve2d</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">deconvolved_img</span> <span class="o">=</span> <span class="n">restoration</span><span class="o">.</span><span class="n">wiener</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>


                </article>
              
              
              
              
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.ball_kernel"><code class="docutils literal notranslate"><span class="pre">ball_kernel()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.calibrate_denoiser"><code class="docutils literal notranslate"><span class="pre">calibrate_denoiser()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.cycle_spin"><code class="docutils literal notranslate"><span class="pre">cycle_spin()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.denoise_bilateral"><code class="docutils literal notranslate"><span class="pre">denoise_bilateral()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.denoise_invariant"><code class="docutils literal notranslate"><span class="pre">denoise_invariant()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.denoise_nl_means"><code class="docutils literal notranslate"><span class="pre">denoise_nl_means()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.denoise_tv_bregman"><code class="docutils literal notranslate"><span class="pre">denoise_tv_bregman()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.denoise_tv_chambolle"><code class="docutils literal notranslate"><span class="pre">denoise_tv_chambolle()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.denoise_wavelet"><code class="docutils literal notranslate"><span class="pre">denoise_wavelet()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.ellipsoid_kernel"><code class="docutils literal notranslate"><span class="pre">ellipsoid_kernel()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.estimate_sigma"><code class="docutils literal notranslate"><span class="pre">estimate_sigma()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.inpaint_biharmonic"><code class="docutils literal notranslate"><span class="pre">inpaint_biharmonic()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.richardson_lucy"><code class="docutils literal notranslate"><span class="pre">richardson_lucy()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.rolling_ball"><code class="docutils literal notranslate"><span class="pre">rolling_ball()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.unsupervised_wiener"><code class="docutils literal notranslate"><span class="pre">unsupervised_wiener()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.unwrap_phase"><code class="docutils literal notranslate"><span class="pre">unwrap_phase()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.restoration.wiener"><code class="docutils literal notranslate"><span class="pre">wiener()</span></code></a></li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">

  <div class="tocsection sourcelink">
    <a href="../_sources/api/skimage.restoration.rst.txt">
      <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2013-2024, the scikit-image team.
      <br/>
    
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.0.2.
    <br/>
  </p>
</div>
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.4.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>