


<!DOCTYPE html>
<html lang="en">
<head>
        <title>Module: filters &mdash; skimage v0.11.3 docs</title>
    
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../_static/css/custom.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
    
    <script src="http://code.jquery.com/jquery-latest.js"></script>
    <script src="../_static/js/bootstrap.min.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.11.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <link rel="top" title="skimage v0.11.3 docs" href="../index.html" />
        <link rel="up" title="API Reference" href="api.html" />
        <link rel="next" title="Module: filters.rank" href="skimage.filters.rank.html" />
        <link rel="prev" title="Module: feature" href="skimage.feature.html" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="shortcut icon" href="../_static/favicon.ico">
</head>
<body class="container">
    <a href="http://scikit-image.org" class="logo"><img src="../_static/img/logo.png" alt=""></a>
    <div class="clearfix"></div>
    <div class="navbar">
        <div class="navbar-inner">
            <ul class="nav">
                <li><a href="/">Home</a></li>
<li><a href="/docs/stable/install.html">Download</a></li>
<li><a href="/docs/dev/auto_examples">Gallery</a></li>
<li><a href="/docs/dev">Documentation</a></li>
<li><a href="https://github.com/scikit-image/scikit-image">
    <img src="../_static/GitHub-Mark-32px.png"
        style="height: 15px; width: 15px;
               display: inline; float: none;
               padding-bottom: 3px;">
    Source</a>
</li>
            </ul>
            <form class="navbar-form pull-right" action="../search.html" method="get">
                <input type="text" class="search span3" name="q" placeholder="Search documentation ...">
                <input type="hidden" name="check_keywords" value="yes" >
                <input type="hidden" name="area" value="default" >
            </form>
        </div>
    </div>
    <div class="row">
        <div class="span9">
            
  <div class="section" id="module-skimage.filters">
<span id="module-filters"></span><h1>Module: <tt class="xref py py-mod docutils literal"><span class="pre">filters</span></tt><a class="headerlink" href="#module-skimage.filters" title="Permalink to this headline">¶</a></h1>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.canny" title="skimage.filters.canny"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.canny</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.feature.canny</span></tt> instead.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.denoise_bilateral" title="skimage.filters.denoise_bilateral"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.denoise_bilateral</span></tt></a>(image[,&nbsp;...])</td>
<td><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.restoration.denoise_bilateral</span></tt> instead.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.denoise_tv_bregman" title="skimage.filters.denoise_tv_bregman"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.denoise_tv_bregman</span></tt></a>(image,&nbsp;weight)</td>
<td><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.restoration.denoise_tv_bregman</span></tt> instead.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.denoise_tv_chambolle" title="skimage.filters.denoise_tv_chambolle"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.denoise_tv_chambolle</span></tt></a>(im[,&nbsp;...])</td>
<td><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.restoration.denoise_tv_chambolle</span></tt> instead.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.gabor_filter" title="skimage.filters.gabor_filter"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.gabor_filter</span></tt></a>(image,&nbsp;frequency)</td>
<td>Return real and imaginary responses to Gabor filter.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.gabor_kernel" title="skimage.filters.gabor_kernel"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.gabor_kernel</span></tt></a>(frequency[,&nbsp;...])</td>
<td>Return complex 2D Gabor filter kernel.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.gaussian_filter" title="skimage.filters.gaussian_filter"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.gaussian_filter</span></tt></a>(image,&nbsp;sigma)</td>
<td>Multi-dimensional Gaussian filter</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.hprewitt" title="skimage.filters.hprewitt"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.hprewitt</span></tt></a>(image[,&nbsp;mask])</td>
<td><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.prewitt_h</span></tt> instead.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.hscharr" title="skimage.filters.hscharr"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.hscharr</span></tt></a>(image[,&nbsp;mask])</td>
<td><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.scharr_h</span></tt> instead.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.hsobel" title="skimage.filters.hsobel"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.hsobel</span></tt></a>(image[,&nbsp;mask])</td>
<td><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.sobel_h</span></tt> instead.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.inverse" title="skimage.filters.inverse"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.inverse</span></tt></a>(data[,&nbsp;...])</td>
<td>Apply the filter in reverse to the given data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.median" title="skimage.filters.median"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.median</span></tt></a>(image,&nbsp;selem[,&nbsp;out,&nbsp;...])</td>
<td>Return local median of an image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.prewitt" title="skimage.filters.prewitt"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.prewitt</span></tt></a>(image[,&nbsp;mask])</td>
<td>Find the edge magnitude using the Prewitt transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.prewitt_h" title="skimage.filters.prewitt_h"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.prewitt_h</span></tt></a>(image[,&nbsp;mask])</td>
<td>Find the horizontal edges of an image using the Prewitt transform.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.prewitt_v" title="skimage.filters.prewitt_v"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.prewitt_v</span></tt></a>(image[,&nbsp;mask])</td>
<td>Find the vertical edges of an image using the Prewitt transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.rank_order" title="skimage.filters.rank_order"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.rank_order</span></tt></a>(image)</td>
<td>Return an image of the same shape where each pixel is the index of the pixel value in the ascending order of the unique values of <cite>image</cite>, aka the rank-order value.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.roberts" title="skimage.filters.roberts"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.roberts</span></tt></a>(image[,&nbsp;mask])</td>
<td>Find the edge magnitude using Roberts&#8217; cross operator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.roberts_neg_diag" title="skimage.filters.roberts_neg_diag"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.roberts_neg_diag</span></tt></a>(image[,&nbsp;mask])</td>
<td>Find the cross edges of an image using the Roberts&#8217; Cross operator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.roberts_negative_diagonal" title="skimage.filters.roberts_negative_diagonal"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.roberts_negative_diagonal</span></tt></a>(image)</td>
<td><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.roberts_neg_diag</span></tt> instead.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.roberts_pos_diag" title="skimage.filters.roberts_pos_diag"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.roberts_pos_diag</span></tt></a>(image[,&nbsp;mask])</td>
<td>Find the cross edges of an image using Roberts&#8217; cross operator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.roberts_positive_diagonal" title="skimage.filters.roberts_positive_diagonal"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.roberts_positive_diagonal</span></tt></a>(image)</td>
<td><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.roberts_pos_diag</span></tt> instead.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.scharr" title="skimage.filters.scharr"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.scharr</span></tt></a>(image[,&nbsp;mask])</td>
<td>Find the edge magnitude using the Scharr transform.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.scharr_h" title="skimage.filters.scharr_h"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.scharr_h</span></tt></a>(image[,&nbsp;mask])</td>
<td>Find the horizontal edges of an image using the Scharr transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.scharr_v" title="skimage.filters.scharr_v"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.scharr_v</span></tt></a>(image[,&nbsp;mask])</td>
<td>Find the vertical edges of an image using the Scharr transform.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.sobel" title="skimage.filters.sobel"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.sobel</span></tt></a>(image[,&nbsp;mask])</td>
<td>Find the edge magnitude using the Sobel transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.sobel_h" title="skimage.filters.sobel_h"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.sobel_h</span></tt></a>(image[,&nbsp;mask])</td>
<td>Find the horizontal edges of an image using the Sobel transform.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.sobel_v" title="skimage.filters.sobel_v"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.sobel_v</span></tt></a>(image[,&nbsp;mask])</td>
<td>Find the vertical edges of an image using the Sobel transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.threshold_adaptive" title="skimage.filters.threshold_adaptive"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.threshold_adaptive</span></tt></a>(image,&nbsp;...)</td>
<td>Applies an adaptive threshold to an array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.threshold_isodata" title="skimage.filters.threshold_isodata"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.threshold_isodata</span></tt></a>(image[,&nbsp;...])</td>
<td>Return threshold value(s) based on ISODATA method.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.threshold_li" title="skimage.filters.threshold_li"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.threshold_li</span></tt></a>(image)</td>
<td>Return threshold value based on adaptation of Li&#8217;s Minimum Cross Entropy method.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.threshold_otsu" title="skimage.filters.threshold_otsu"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.threshold_otsu</span></tt></a>(image[,&nbsp;nbins])</td>
<td>Return threshold value based on Otsu&#8217;s method.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.threshold_yen" title="skimage.filters.threshold_yen"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.threshold_yen</span></tt></a>(image[,&nbsp;nbins])</td>
<td>Return threshold value based on Yen&#8217;s method.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.vprewitt" title="skimage.filters.vprewitt"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.vprewitt</span></tt></a>(image[,&nbsp;mask])</td>
<td><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.prewitt_v</span></tt> instead.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.vscharr" title="skimage.filters.vscharr"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.vscharr</span></tt></a>(image[,&nbsp;mask])</td>
<td><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.scharr_v</span></tt> instead.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.vsobel" title="skimage.filters.vsobel"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.vsobel</span></tt></a>(image[,&nbsp;mask])</td>
<td><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.sobel_v</span></tt> instead.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.wiener" title="skimage.filters.wiener"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.wiener</span></tt></a>(data[,&nbsp;...])</td>
<td>Minimum Mean Square Error (Wiener) inverse filter.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.filters.LPIFilter2D" title="skimage.filters.LPIFilter2D"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.LPIFilter2D</span></tt></a>(...)</td>
<td>Linear Position-Invariant Filter (2-dimensional)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.filters.deprecated" title="skimage.filters.deprecated"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.filters.deprecated</span></tt></a>([alt_func,&nbsp;behavior])</td>
<td>Decorator to mark deprecated functions with warning.</td>
</tr>
</tbody>
</table>
<div class="section" id="canny">
<h2>canny<a class="headerlink" href="#canny" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.canny">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">canny</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#skimage.filters.canny" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.feature.canny</span></tt> instead.</p>
</dd></dl>

</div>
<div class="section" id="denoise-bilateral">
<h2>denoise_bilateral<a class="headerlink" href="#denoise-bilateral" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.denoise_bilateral">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">denoise_bilateral</tt><big>(</big><em>image</em>, <em>win_size=5</em>, <em>sigma_range=None</em>, <em>sigma_spatial=1</em>, <em>bins=10000</em>, <em>mode='constant'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.filters.denoise_bilateral" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.restoration.denoise_bilateral</span></tt> instead.</p>
<p>Denoise image using bilateral filter.</p>
<p>This is an edge-preserving and noise reducing denoising filter. It averages
pixels based on their spatial closeness and radiometric similarity.</p>
<p>Spatial closeness is measured by the gaussian function of the euclidian
distance between two pixels and a certain standard deviation
(<cite>sigma_spatial</cite>).</p>
<p>Radiometric similarity is measured by the gaussian function of the euclidian
distance between two color values and a certain standard deviation
(<cite>sigma_range</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>win_size</strong> : int</p>
<blockquote>
<div><p>Window size for filtering.</p>
</div></blockquote>
<p><strong>sigma_range</strong> : float</p>
<blockquote>
<div><p>Standard deviation for grayvalue/color distance (radiometric
similarity). A larger value results in averaging of pixels with larger
radiometric differences. Note, that the image will be converted using
the <cite>img_as_float</cite> function and thus the standard deviation is in
respect to the range <cite>[0, 1]</cite>.</p>
</div></blockquote>
<p><strong>sigma_spatial</strong> : float</p>
<blockquote>
<div><p>Standard deviation for range distance. A larger value results in
averaging of pixels with larger spatial differences.</p>
</div></blockquote>
<p><strong>bins</strong> : int</p>
<blockquote>
<div><p>Number of discrete values for gaussian weights of color filtering.
A larger value results in improved accuracy.</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><p>How to handle values outside the image borders. See
<cite>scipy.ndimage.map_coordinates</cite> for detail.</p>
</div></blockquote>
<p><strong>cval</strong> : string</p>
<blockquote>
<div><p>Used in conjunction with mode &#8216;constant&#8217;, the value outside
the image boundaries.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>denoised</strong> : ndarray</p>
<blockquote class="last">
<div><p>Denoised image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r186" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[R186]</a></td><td><a class="reference external" href="http://users.soe.ucsc.edu/~manduchi/Papers/ICCV98.pdf">http://users.soe.ucsc.edu/~manduchi/Papers/ICCV98.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="denoise-tv-bregman">
<h2>denoise_tv_bregman<a class="headerlink" href="#denoise-tv-bregman" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.denoise_tv_bregman">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">denoise_tv_bregman</tt><big>(</big><em>image</em>, <em>weight</em>, <em>max_iter=100</em>, <em>eps=0.001</em>, <em>isotropic=True</em><big>)</big><a class="headerlink" href="#skimage.filters.denoise_tv_bregman" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.restoration.denoise_tv_bregman</span></tt> instead.</p>
<p>Perform total-variation denoising using split-Bregman optimization.</p>
<p>Total-variation denoising (also know as total-variation regularization)
tries to find an image with less total-variation under the constraint
of being similar to the input image, which is controlled by the
regularization parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input data to be denoised (converted using img_as_float`).</p>
</div></blockquote>
<p><strong>weight</strong> : float</p>
<blockquote>
<div><p>Denoising weight. The smaller the <cite>weight</cite>, the more denoising (at
the expense of less similarity to the <cite>input</cite>). The regularization
parameter <cite>lambda</cite> is chosen as <cite>2 * weight</cite>.</p>
</div></blockquote>
<p><strong>eps</strong> : float, optional</p>
<blockquote>
<div><p>Relative difference of the value of the cost function that determines
the stop criterion. The algorithm stops when:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SUM</span><span class="p">((</span><span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>max_iter</strong> : int, optional</p>
<blockquote>
<div><p>Maximal number of iterations used for the optimization.</p>
</div></blockquote>
<p><strong>isotropic</strong> : boolean, optional</p>
<blockquote>
<div><p>Switch between isotropic and anisotropic TV denoising.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>u</strong> : ndarray</p>
<blockquote class="last">
<div><p>Denoised image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r187" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[R187]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Total_variation_denoising">http://en.wikipedia.org/wiki/Total_variation_denoising</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r188" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[R188]</a></td><td>Tom Goldstein and Stanley Osher, &#8220;The Split Bregman Method For L1
Regularized Problems&#8221;,
<a class="reference external" href="ftp://ftp.math.ucla.edu/pub/camreport/cam08-29.pdf">ftp://ftp.math.ucla.edu/pub/camreport/cam08-29.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r189" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[R189]</a></td><td>Pascal Getreuer, &#8220;Rudin–Osher–Fatemi Total Variation Denoising
using Split Bregman&#8221; in Image Processing On Line on 2012–05–19,
<a class="reference external" href="http://www.ipol.im/pub/art/2012/g-tvd/article_lr.pdf">http://www.ipol.im/pub/art/2012/g-tvd/article_lr.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r190" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[R190]</a></td><td><a class="reference external" href="http://www.math.ucsb.edu/~cgarcia/UGProjects/BregmanAlgorithms_JacquelineBush.pdf">http://www.math.ucsb.edu/~cgarcia/UGProjects/BregmanAlgorithms_JacquelineBush.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="denoise-tv-chambolle">
<h2>denoise_tv_chambolle<a class="headerlink" href="#denoise-tv-chambolle" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.denoise_tv_chambolle">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">denoise_tv_chambolle</tt><big>(</big><em>im</em>, <em>weight=50</em>, <em>eps=0.0002</em>, <em>n_iter_max=200</em>, <em>multichannel=False</em><big>)</big><a class="headerlink" href="#skimage.filters.denoise_tv_chambolle" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.restoration.denoise_tv_chambolle</span></tt> instead.</p>
<p>Perform total-variation denoising on 2D and 3D images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>im</strong> : ndarray (2d or 3d) of ints, uints or floats</p>
<blockquote>
<div><p>Input data to be denoised. <cite>im</cite> can be of any numeric type,
but it is cast into an ndarray of floats for the computation
of the denoised image.</p>
</div></blockquote>
<p><strong>weight</strong> : float, optional</p>
<blockquote>
<div><p>Denoising weight. The greater <cite>weight</cite>, the more denoising (at
the expense of fidelity to <cite>input</cite>).</p>
</div></blockquote>
<p><strong>eps</strong> : float, optional</p>
<blockquote>
<div><p>Relative difference of the value of the cost function that
determines the stop criterion. The algorithm stops when:</p>
<blockquote>
<div><p>(E_(n-1) - E_n) &lt; eps * E_0</p>
</div></blockquote>
</div></blockquote>
<p><strong>n_iter_max</strong> : int, optional</p>
<blockquote>
<div><p>Maximal number of iterations used for the optimization.</p>
</div></blockquote>
<p><strong>multichannel</strong> : bool, optional</p>
<blockquote>
<div><p>Apply total-variation denoising separately for each channel. This
option should be true for color images, otherwise the denoising is
also applied in the 3rd dimension.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray</p>
<blockquote class="last">
<div><p>Denoised image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Make sure to set the multichannel parameter appropriately for color images.</p>
<p>The principle of total variation denoising is explained in
<a class="reference external" href="http://en.wikipedia.org/wiki/Total_variation_denoising">http://en.wikipedia.org/wiki/Total_variation_denoising</a></p>
<p>The principle of total variation denoising is to minimize the
total variation of the image, which can be roughly described as
the integral of the norm of the image gradient. Total variation
denoising tends to produce &#8220;cartoon-like&#8221; images, that is,
piecewise-constant images.</p>
<p>This code is an implementation of the algorithm of Rudin, Fatemi and Osher
that was proposed by Chambolle in <a class="reference internal" href="#r191" id="id6">[R191]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r191" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R191]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> A. Chambolle, An algorithm for total variation minimization and
applications, Journal of Mathematical Imaging and Vision,
Springer, 2004, 20, 89-97.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>2D example on astronaut image:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">color</span><span class="p">,</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())[:</span><span class="mi">50</span><span class="p">,</span> <span class="p">:</span><span class="mi">50</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denoised_img</span> <span class="o">=</span> <span class="n">denoise_tv_chambolle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p>3D example on synthetic data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">22</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">20</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="mi">17</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">+=</span> <span class="mf">0.2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">denoise_tv_chambolle</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="gabor-filter">
<h2>gabor_filter<a class="headerlink" href="#gabor-filter" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.gabor_filter">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">gabor_filter</tt><big>(</big><em>image</em>, <em>frequency</em>, <em>theta=0</em>, <em>bandwidth=1</em>, <em>sigma_x=None</em>, <em>sigma_y=None</em>, <em>n_stds=3</em>, <em>offset=0</em>, <em>mode='reflect'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.filters.gabor_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return real and imaginary responses to Gabor filter.</p>
<p>The real and imaginary parts of the Gabor filter kernel are applied to the
image and the response is returned as a pair of arrays.</p>
<p>Gabor filter is a linear filter with a Gaussian kernel which is modulated
by a sinusoidal plane wave. Frequency and orientation representations of
the Gabor filter are similar to those of the human visual system.
Gabor filter banks are commonly used in computer vision and image
processing. They are especially suitable for edge detection and texture
classification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>frequency</strong> : float</p>
<blockquote>
<div><p>Spatial frequency of the harmonic function. Specified in pixels.</p>
</div></blockquote>
<p><strong>theta</strong> : float, optional</p>
<blockquote>
<div><p>Orientation in radians. If 0, the harmonic is in the x-direction.</p>
</div></blockquote>
<p><strong>bandwidth</strong> : float, optional</p>
<blockquote>
<div><p>The bandwidth captured by the filter. For fixed bandwidth, <cite>sigma_x</cite>
and <cite>sigma_y</cite> will decrease with increasing frequency. This value is
ignored if <cite>sigma_x</cite> and <cite>sigma_y</cite> are set by the user.</p>
</div></blockquote>
<p><strong>sigma_x, sigma_y</strong> : float, optional</p>
<blockquote>
<div><p>Standard deviation in x- and y-directions. These directions apply to
the kernel <em>before</em> rotation. If <cite>theta = pi/2</cite>, then the kernel is
rotated 90 degrees so that <cite>sigma_x</cite> controls the <em>vertical</em> direction.</p>
</div></blockquote>
<p><strong>n_stds</strong> : scalar, optional</p>
<blockquote>
<div><p>The linear size of the kernel is n_stds (3 by default) standard
deviations.</p>
</div></blockquote>
<p><strong>offset</strong> : float, optional</p>
<blockquote>
<div><p>Phase offset of harmonic function in radians.</p>
</div></blockquote>
<p><strong>mode</strong> : string, optional</p>
<blockquote>
<div><p>Mode used to convolve image with a kernel, passed to <cite>ndimage.convolve</cite></p>
</div></blockquote>
<p><strong>cval</strong> : scalar, optional</p>
<blockquote>
<div><p>Value to fill past edges of input if <cite>mode</cite> of convolution is
&#8216;constant&#8217;. The parameter is passed to <cite>ndimage.convolve</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>real, imag</strong> : arrays</p>
<blockquote class="last">
<div><p>Filtered images using the real and imaginary parts of the Gabor filter
kernel. Images are of the same dimensions as the input one.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r192" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[R192]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Gabor_filter">http://en.wikipedia.org/wiki/Gabor_filter</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r193" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[R193]</a></td><td><a class="reference external" href="http://mplab.ucsd.edu/tutorials/gabor.pdf">http://mplab.ucsd.edu/tutorials/gabor.pdf</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.filter</span> <span class="kn">import</span> <span class="n">gabor_filter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>  
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># detecting edges in a coin image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filt_real</span><span class="p">,</span> <span class="n">filt_imag</span> <span class="o">=</span> <span class="n">gabor_filter</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>            
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">filt_real</span><span class="p">)</span>    
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>               
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># less sensitivity to finer details with the lower frequency kernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filt_real</span><span class="p">,</span> <span class="n">filt_imag</span> <span class="o">=</span> <span class="n">gabor_filter</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>            
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">filt_real</span><span class="p">)</span>    
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>               
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="gabor-kernel">
<h2>gabor_kernel<a class="headerlink" href="#gabor-kernel" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.gabor_kernel">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">gabor_kernel</tt><big>(</big><em>frequency</em>, <em>theta=0</em>, <em>bandwidth=1</em>, <em>sigma_x=None</em>, <em>sigma_y=None</em>, <em>n_stds=3</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#skimage.filters.gabor_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return complex 2D Gabor filter kernel.</p>
<p>Gabor kernel is a Gaussian kernel modulated by a complex harmonic function.
Harmonic function consists of an imaginary sine function and a real
cosine function. Spatial frequency is inversely proportional to the
wavelength of the harmonic and to the standard deviation of a Gaussian
kernel. The bandwidth is also inversely proportional to the standard
deviation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>frequency</strong> : float</p>
<blockquote>
<div><p>Spatial frequency of the harmonic function. Specified in pixels.</p>
</div></blockquote>
<p><strong>theta</strong> : float, optional</p>
<blockquote>
<div><p>Orientation in radians. If 0, the harmonic is in the x-direction.</p>
</div></blockquote>
<p><strong>bandwidth</strong> : float, optional</p>
<blockquote>
<div><p>The bandwidth captured by the filter. For fixed bandwidth, <cite>sigma_x</cite>
and <cite>sigma_y</cite> will decrease with increasing frequency. This value is
ignored if <cite>sigma_x</cite> and <cite>sigma_y</cite> are set by the user.</p>
</div></blockquote>
<p><strong>sigma_x, sigma_y</strong> : float, optional</p>
<blockquote>
<div><p>Standard deviation in x- and y-directions. These directions apply to
the kernel <em>before</em> rotation. If <cite>theta = pi/2</cite>, then the kernel is
rotated 90 degrees so that <cite>sigma_x</cite> controls the <em>vertical</em> direction.</p>
</div></blockquote>
<p><strong>n_stds</strong> : scalar, optional</p>
<blockquote>
<div><p>The linear size of the kernel is n_stds (3 by default) standard
deviations</p>
</div></blockquote>
<p><strong>offset</strong> : float, optional</p>
<blockquote>
<div><p>Phase offset of harmonic function in radians.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>g</strong> : complex array</p>
<blockquote class="last">
<div><p>Complex filter kernel.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r194" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[R194]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Gabor_filter">http://en.wikipedia.org/wiki/Gabor_filter</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r195" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[R195]</a></td><td><a class="reference external" href="http://mplab.ucsd.edu/tutorials/gabor.pdf">http://mplab.ucsd.edu/tutorials/gabor.pdf</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.filter</span> <span class="kn">import</span> <span class="n">gabor_kernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>  
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">gabor_kernel</span><span class="p">(</span><span class="n">frequency</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>        
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">gk</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>           
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># more ripples (equivalent to increasing the size of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Gaussian spread)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">gabor_kernel</span><span class="p">(</span><span class="n">frequency</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>        
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">gk</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>           
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="gaussian-filter">
<h2>gaussian_filter<a class="headerlink" href="#gaussian-filter" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.gaussian_filter">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">gaussian_filter</tt><big>(</big><em>image</em>, <em>sigma</em>, <em>output=None</em>, <em>mode='nearest'</em>, <em>cval=0</em>, <em>multichannel=None</em><big>)</big><a class="headerlink" href="#skimage.filters.gaussian_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Multi-dimensional Gaussian filter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : array-like</p>
<blockquote>
<div><p>input image (grayscale or color) to filter.</p>
</div></blockquote>
<p><strong>sigma</strong> : scalar or sequence of scalars</p>
<blockquote>
<div><p>standard deviation for Gaussian kernel. The standard
deviations of the Gaussian filter are given for each axis as a
sequence, or as a single number, in which case it is equal for
all axes.</p>
</div></blockquote>
<p><strong>output</strong> : array, optional</p>
<blockquote>
<div><p>The <tt class="docutils literal"><span class="pre">output</span></tt> parameter passes an array in which to store the
filter output.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;reflect&#8217;, &#8216;constant&#8217;, &#8216;nearest&#8217;, &#8216;mirror&#8217;, &#8216;wrap&#8217;}, optional</p>
<blockquote>
<div><p>The <cite>mode</cite> parameter determines how the array borders are
handled, where <cite>cval</cite> is the value when mode is equal to
&#8216;constant&#8217;. Default is &#8216;nearest&#8217;.</p>
</div></blockquote>
<p><strong>cval</strong> : scalar, optional</p>
<blockquote>
<div><p>Value to fill past edges of input if <cite>mode</cite> is &#8216;constant&#8217;. Default
is 0.0</p>
</div></blockquote>
<p><strong>multichannel</strong> : bool, optional (default: None)</p>
<blockquote>
<div><p>Whether the last axis of the image is to be interpreted as multiple
channels. If True, each channel is filtered separately (channels are
not mixed together). Only 3 channels are supported. If <cite>None</cite>,
the function will attempt to guess this, and raise a warning if
ambiguous, when the array has shape (M, N, 3).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>filtered_image</strong> : ndarray</p>
<blockquote class="last">
<div><p>the filtered array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function is a wrapper around <tt class="xref py py-func docutils literal"><span class="pre">scipy.ndimage.gaussian_filter()</span></tt>.</p>
<p>Integer arrays are converted to float.</p>
<p>The multi-dimensional filter is implemented as a sequence of
one-dimensional convolution filters. The intermediate arrays are
stored in the same data type as the output. Therefore, for output
types with a limited precision, the results may be imprecise
because intermediate results may be stored with insufficient
precision.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>  <span class="c"># mild smoothing</span>
<span class="go">array([[ 0.00163116,  0.03712502,  0.00163116],</span>
<span class="go">       [ 0.03712502,  0.84496158,  0.03712502],</span>
<span class="go">       [ 0.00163116,  0.03712502,  0.00163116]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># more smooting</span>
<span class="go">array([[ 0.05855018,  0.09653293,  0.05855018],</span>
<span class="go">       [ 0.09653293,  0.15915589,  0.09653293],</span>
<span class="go">       [ 0.05855018,  0.09653293,  0.05855018]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Several modes are possible for handling boundaries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;reflect&#39;</span><span class="p">)</span>
<span class="go">array([[ 0.08767308,  0.12075024,  0.08767308],</span>
<span class="go">       [ 0.12075024,  0.16630671,  0.12075024],</span>
<span class="go">       [ 0.08767308,  0.12075024,  0.08767308]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># For RGB images, each is filtered separately</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">astronaut</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">astronaut</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_img</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">multichannel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="hprewitt">
<h2>hprewitt<a class="headerlink" href="#hprewitt" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.hprewitt">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">hprewitt</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.hprewitt" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.prewitt_h</span></tt> instead.</p>
<p>Find the horizontal edges of an image using the Prewitt transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The absolute Prewitt edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel and return the absolute value of the
result at each point:</p>
<div class="highlight-python"><div class="highlight"><pre> 1   1   1
 0   0   0
-1  -1  -1
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="hscharr">
<h2>hscharr<a class="headerlink" href="#hscharr" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.hscharr">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">hscharr</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.hscharr" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.scharr_h</span></tt> instead.</p>
<p>Find the horizontal edges of an image using the Scharr transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The absolute Scharr edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel and return the absolute value of the
result at each point:</p>
<div class="highlight-python"><div class="highlight"><pre> 3   10   3
 0    0   0
-3  -10  -3
</pre></div>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r196" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[R196]</a></td><td>D. Kroon, 2009, Short Paper University Twente, Numerical
Optimization of Kernel Based Image Derivatives.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="hsobel">
<h2>hsobel<a class="headerlink" href="#hsobel" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.hsobel">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">hsobel</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.hsobel" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.sobel_h</span></tt> instead.</p>
<p>Find the horizontal edges of an image using the Sobel transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The absolute Sobel edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel and return the absolute value of the
result at each point:</p>
<div class="highlight-python"><div class="highlight"><pre> 1   2   1
 0   0   0
-1  -2  -1
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="inverse">
<h2>inverse<a class="headerlink" href="#inverse" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.inverse">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">inverse</tt><big>(</big><em>data</em>, <em>impulse_response=None</em>, <em>filter_params={}</em>, <em>max_gain=2</em>, <em>predefined_filter=None</em><big>)</big><a class="headerlink" href="#skimage.filters.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the filter in reverse to the given data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : (M,N) ndarray</p>
<blockquote>
<div><p>Input data.</p>
</div></blockquote>
<p><strong>impulse_response</strong> : callable <cite>f(r, c, **filter_params)</cite></p>
<blockquote>
<div><p>Impulse response of the filter.  See LPIFilter2D.__init__.</p>
</div></blockquote>
<p><strong>filter_params</strong> : dict</p>
<blockquote>
<div><p>Additional keyword parameters to the impulse_response function.</p>
</div></blockquote>
<p><strong>max_gain</strong> : float</p>
<blockquote>
<div><p>Limit the filter gain.  Often, the filter contains zeros, which would
cause the inverse filter to have infinite gain.  High gain causes
amplification of artefacts, so a conservative limit is recommended.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first"><strong>predefined_filter</strong> : LPIFilter2D</p>
<blockquote class="last">
<div><p>If you need to apply the same filter multiple times over different
images, construct the LPIFilter2D and specify it here.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="median">
<h2>median<a class="headerlink" href="#median" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.median">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">median</tt><big>(</big><em>image</em>, <em>selem</em>, <em>out=None</em>, <em>mask=None</em>, <em>shift_x=False</em>, <em>shift_y=False</em><big>)</big><a class="headerlink" href="#skimage.filters.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Return local median of an image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array (uint8, uint16)</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>selem</strong> : 2-D array</p>
<blockquote>
<div><p>The neighborhood expressed as a 2-D array of 1&#8217;s and 0&#8217;s.</p>
</div></blockquote>
<p><strong>out</strong> : 2-D array (same dtype as input)</p>
<blockquote>
<div><p>If None, a new array is allocated.</p>
</div></blockquote>
<p><strong>mask</strong> : ndarray</p>
<blockquote>
<div><p>Mask array that defines (&gt;0) area of the image included in the local
neighborhood. If None, the complete image is used (default).</p>
</div></blockquote>
<p><strong>shift_x, shift_y</strong> : int</p>
<blockquote>
<div><p>Offset added to the structuring element center point. Shift is bounded
to the structuring element sizes (center must be inside the given
structuring element).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : 2-D array (same dtype as input image)</p>
<blockquote class="last">
<div><p>Output image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.filters.rank</span> <span class="kn">import</span> <span class="n">median</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">med</span> <span class="o">=</span> <span class="n">median</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">disk</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="prewitt">
<h2>prewitt<a class="headerlink" href="#prewitt" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.prewitt">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">prewitt</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.prewitt" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the edge magnitude using the Prewitt transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The Prewitt edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#skimage.filters.sobel" title="skimage.filters.sobel"><tt class="xref py py-obj docutils literal"><span class="pre">sobel</span></tt></a>, <a class="reference internal" href="#skimage.filters.scharr" title="skimage.filters.scharr"><tt class="xref py py-obj docutils literal"><span class="pre">scharr</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>Return the square root of the sum of squares of the horizontal
and vertical Prewitt transforms. The edge magnitude depends slightly
on edge directions, since the approximation of the gradient operator by
the Prewitt operator is not completely rotation invariant. For a better
rotation invariance, the Scharr operator should be used. The Sobel operator
has a better rotation invariance than the Prewitt operator, but a worse
rotation invariance than the Scharr operator.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">prewitt</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="prewitt-h">
<h2>prewitt_h<a class="headerlink" href="#prewitt-h" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.prewitt_h">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">prewitt_h</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.prewitt_h" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the horizontal edges of an image using the Prewitt transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The Prewitt edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-python"><div class="highlight"><pre> 1   1   1
 0   0   0
-1  -1  -1
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="prewitt-v">
<h2>prewitt_v<a class="headerlink" href="#prewitt-v" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.prewitt_v">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">prewitt_v</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.prewitt_v" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the vertical edges of an image using the Prewitt transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The Prewitt edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-python"><div class="highlight"><pre>1   0  -1
1   0  -1
1   0  -1
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="rank-order">
<h2>rank_order<a class="headerlink" href="#rank-order" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.rank_order">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">rank_order</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#skimage.filters.rank_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an image of the same shape where each pixel is the
index of the pixel value in the ascending order of the unique
values of <cite>image</cite>, aka the rank-order value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image: ndarray</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">labels: ndarray of type np.uint32, of shape image.shape</p>
<blockquote>
<div><p>New array where each pixel has the rank-order value of the
corresponding pixel in <cite>image</cite>. Pixel values are between 0 and
n - 1, where n is the number of distinct unique values in
<cite>image</cite>.</p>
</div></blockquote>
<p>original_values: 1-D ndarray</p>
<blockquote class="last">
<div><p>Unique original values of <cite>image</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 4, 5],</span>
<span class="go">       [4, 4, 1],</span>
<span class="go">       [5, 1, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rank_order</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(array([[0, 1, 2],</span>
<span class="go">       [1, 1, 0],</span>
<span class="go">       [2, 0, 0]], dtype=uint32), array([1, 4, 5]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rank_order</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">(array([0, 1, 2, 1], dtype=uint32), array([-1. ,  2.5,  3.1]))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="roberts">
<h2>roberts<a class="headerlink" href="#roberts" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.roberts">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">roberts</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.roberts" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the edge magnitude using Roberts&#8217; cross operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The Roberts&#8217; Cross edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#skimage.filters.sobel" title="skimage.filters.sobel"><tt class="xref py py-obj docutils literal"><span class="pre">sobel</span></tt></a>, <a class="reference internal" href="#skimage.filters.scharr" title="skimage.filters.scharr"><tt class="xref py py-obj docutils literal"><span class="pre">scharr</span></tt></a>, <a class="reference internal" href="#skimage.filters.prewitt" title="skimage.filters.prewitt"><tt class="xref py py-obj docutils literal"><span class="pre">prewitt</span></tt></a>, <tt class="xref py py-obj docutils literal"><span class="pre">feature.canny</span></tt></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">roberts</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="roberts-neg-diag">
<h2>roberts_neg_diag<a class="headerlink" href="#roberts-neg-diag" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.roberts_neg_diag">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">roberts_neg_diag</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.roberts_neg_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the cross edges of an image using the Roberts&#8217; Cross operator.</p>
<p>The kernel is applied to the input image to produce separate measurements
of the gradient component one orientation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The Robert&#8217;s edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-python"><div class="highlight"><pre> 0   1
-1   0
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="roberts-negative-diagonal">
<h2>roberts_negative_diagonal<a class="headerlink" href="#roberts-negative-diagonal" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.roberts_negative_diagonal">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">roberts_negative_diagonal</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.roberts_negative_diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.roberts_neg_diag</span></tt> instead.</p>
<p>Find the cross edges of an image using the Roberts&#8217; Cross operator.</p>
<p>The kernel is applied to the input image to produce separate measurements
of the gradient component one orientation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The absolute Robert&#8217;s edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel and return the absolute value of the
result at each point:</p>
<div class="highlight-python"><div class="highlight"><pre> 0   1
-1   0
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="roberts-pos-diag">
<h2>roberts_pos_diag<a class="headerlink" href="#roberts-pos-diag" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.roberts_pos_diag">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">roberts_pos_diag</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.roberts_pos_diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the cross edges of an image using Roberts&#8217; cross operator.</p>
<p>The kernel is applied to the input image to produce separate measurements
of the gradient component one orientation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The Robert&#8217;s edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-python"><div class="highlight"><pre>1   0
0  -1
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="roberts-positive-diagonal">
<h2>roberts_positive_diagonal<a class="headerlink" href="#roberts-positive-diagonal" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.roberts_positive_diagonal">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">roberts_positive_diagonal</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.roberts_positive_diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.roberts_pos_diag</span></tt> instead.</p>
<p>Find the cross edges of an image using Roberts&#8217; cross operator.</p>
<p>The kernel is applied to the input image to produce separate measurements
of the gradient component one orientation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The absolute Robert&#8217;s edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel and return the absolute value of the
result at each point:</p>
<div class="highlight-python"><div class="highlight"><pre>1   0
0  -1
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="scharr">
<h2>scharr<a class="headerlink" href="#scharr" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.scharr">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">scharr</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.scharr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the edge magnitude using the Scharr transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The Scharr edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#skimage.filters.sobel" title="skimage.filters.sobel"><tt class="xref py py-obj docutils literal"><span class="pre">sobel</span></tt></a>, <a class="reference internal" href="#skimage.filters.prewitt" title="skimage.filters.prewitt"><tt class="xref py py-obj docutils literal"><span class="pre">prewitt</span></tt></a>, <a class="reference internal" href="#skimage.filters.canny" title="skimage.filters.canny"><tt class="xref py py-obj docutils literal"><span class="pre">canny</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>Take the square root of the sum of the squares of the horizontal and
vertical Scharrs to get a magnitude that is somewhat insensitive to
direction. The Scharr operator has a better rotation invariance than
other edge filters such as the Sobel or the Prewitt operators.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r197" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[R197]</a></td><td>D. Kroon, 2009, Short Paper University Twente, Numerical
Optimization of Kernel Based Image Derivatives.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r198" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[R198]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators">http://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">scharr</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="scharr-h">
<h2>scharr_h<a class="headerlink" href="#scharr-h" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.scharr_h">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">scharr_h</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.scharr_h" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the horizontal edges of an image using the Scharr transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The Scharr edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-python"><div class="highlight"><pre> 3   10   3
 0    0   0
-3  -10  -3
</pre></div>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r199" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[R199]</a></td><td>D. Kroon, 2009, Short Paper University Twente, Numerical
Optimization of Kernel Based Image Derivatives.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="scharr-v">
<h2>scharr_v<a class="headerlink" href="#scharr-v" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.scharr_v">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">scharr_v</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.scharr_v" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the vertical edges of an image using the Scharr transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The Scharr edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-python"><div class="highlight"><pre> 3   0   -3
10   0  -10
 3   0   -3
</pre></div>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r200" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[R200]</a></td><td>D. Kroon, 2009, Short Paper University Twente, Numerical
Optimization of Kernel Based Image Derivatives.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sobel">
<h2>sobel<a class="headerlink" href="#sobel" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.sobel">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">sobel</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.sobel" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the edge magnitude using the Sobel transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The Sobel edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#skimage.filters.scharr" title="skimage.filters.scharr"><tt class="xref py py-obj docutils literal"><span class="pre">scharr</span></tt></a>, <a class="reference internal" href="#skimage.filters.prewitt" title="skimage.filters.prewitt"><tt class="xref py py-obj docutils literal"><span class="pre">prewitt</span></tt></a>, <a class="reference internal" href="#skimage.filters.roberts" title="skimage.filters.roberts"><tt class="xref py py-obj docutils literal"><span class="pre">roberts</span></tt></a>, <tt class="xref py py-obj docutils literal"><span class="pre">feature.canny</span></tt></p>
</div>
<p class="rubric">Notes</p>
<p>Take the square root of the sum of the squares of the horizontal and
vertical Sobels to get a magnitude that&#8217;s somewhat insensitive to
direction.</p>
<p>The 3x3 convolution kernel used in the horizontal and vertical Sobels is
an approximation of the gradient of the image (with some slight blurring
since 9 pixels are used to compute the gradient at a given pixel). As an
approximation of the gradient, the Sobel operator is not completely
rotation-invariant. The Scharr operator should be used for a better
rotation invariance.</p>
<p>Note that <tt class="docutils literal"><span class="pre">scipy.ndimage.sobel</span></tt> returns a directional Sobel which
has to be further processed to perform edge detection.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">sobel</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="sobel-h">
<h2>sobel_h<a class="headerlink" href="#sobel-h" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.sobel_h">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">sobel_h</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.sobel_h" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the horizontal edges of an image using the Sobel transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The Sobel edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-python"><div class="highlight"><pre> 1   2   1
 0   0   0
-1  -2  -1
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="sobel-v">
<h2>sobel_v<a class="headerlink" href="#sobel-v" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.sobel_v">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">sobel_v</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.sobel_v" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the vertical edges of an image using the Sobel transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The Sobel edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-python"><div class="highlight"><pre>1   0  -1
2   0  -2
1   0  -1
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="threshold-adaptive">
<h2>threshold_adaptive<a class="headerlink" href="#threshold-adaptive" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.threshold_adaptive">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">threshold_adaptive</tt><big>(</big><em>image</em>, <em>block_size</em>, <em>method='gaussian'</em>, <em>offset=0</em>, <em>mode='reflect'</em>, <em>param=None</em><big>)</big><a class="headerlink" href="#skimage.filters.threshold_adaptive" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies an adaptive threshold to an array.</p>
<p>Also known as local or dynamic thresholding where the threshold value is
the weighted mean for the local neighborhood of a pixel subtracted by a
constant. Alternatively the threshold can be determined dynamically by a a
given function using the &#8216;generic&#8217; method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : (N, M) ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>block_size</strong> : int</p>
<blockquote>
<div><p>Uneven size of pixel neighborhood which is used to calculate the
threshold value (e.g. 3, 5, 7, ..., 21, ...).</p>
</div></blockquote>
<p><strong>method</strong> : {&#8216;generic&#8217;, &#8216;gaussian&#8217;, &#8216;mean&#8217;, &#8216;median&#8217;}, optional</p>
<blockquote>
<div><p>Method used to determine adaptive threshold for local neighbourhood in
weighted mean image.</p>
<ul class="simple">
<li>&#8216;generic&#8217;: use custom function (see <cite>param</cite> parameter)</li>
<li>&#8216;gaussian&#8217;: apply gaussian filter (see <cite>param</cite> parameter for custom                      sigma value)</li>
<li>&#8216;mean&#8217;: apply arithmetic mean filter</li>
<li>&#8216;median&#8217;: apply median rank filter</li>
</ul>
<p>By default the &#8216;gaussian&#8217; method is used.</p>
</div></blockquote>
<p><strong>offset</strong> : float, optional</p>
<blockquote>
<div><p>Constant subtracted from weighted mean of neighborhood to calculate
the local threshold value. Default offset is 0.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;reflect&#8217;, &#8216;constant&#8217;, &#8216;nearest&#8217;, &#8216;mirror&#8217;, &#8216;wrap&#8217;}, optional</p>
<blockquote>
<div><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &#8216;constant&#8217;.
Default is &#8216;reflect&#8217;.</p>
</div></blockquote>
<p><strong>param</strong> : {int, function}, optional</p>
<blockquote>
<div><p>Either specify sigma for &#8216;gaussian&#8217; method or function object for
&#8216;generic&#8217; method. This functions takes the flat array of local
neighbourhood as a single argument and returns the calculated
threshold for the centre pixel.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>threshold</strong> : (N, M) ndarray</p>
<blockquote class="last">
<div><p>Thresholded binary image</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r201" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[R201]</a></td><td><a class="reference external" href="http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#adaptivethreshold">http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#adaptivethreshold</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="p">()[:</span><span class="mi">50</span><span class="p">,</span> <span class="p">:</span><span class="mi">50</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_image1</span> <span class="o">=</span> <span class="n">threshold_adaptive</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="s">&#39;mean&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">arr</span><span class="p">:</span> <span class="n">arr</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_image2</span> <span class="o">=</span> <span class="n">threshold_adaptive</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="s">&#39;generic&#39;</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="n">func</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="threshold-isodata">
<h2>threshold_isodata<a class="headerlink" href="#threshold-isodata" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.threshold_isodata">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">threshold_isodata</tt><big>(</big><em>image</em>, <em>nbins=256</em>, <em>return_all=False</em><big>)</big><a class="headerlink" href="#skimage.filters.threshold_isodata" title="Permalink to this definition">¶</a></dt>
<dd><p>Return threshold value(s) based on ISODATA method.</p>
<p>Histogram-based threshold, known as Ridler-Calvard method or inter-means.
Threshold values returned satisfy the following equality:</p>
<dl class="docutils">
<dt><cite>threshold = (image[image &lt;= threshold].mean() +</cite></dt>
<dd><cite>image[image &gt; threshold].mean()) / 2.0</cite></dd>
</dl>
<p>That is, returned thresholds are intensities that separate the image into
two groups of pixels, where the threshold intensity is midway between the
mean intensities of these groups.</p>
<p>For integer images, the above equality holds to within one; for floating-
point images, the equality holds to within the histogram bin-width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>nbins</strong> : int, optional</p>
<blockquote>
<div><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</div></blockquote>
<p><strong>return_all: bool, optional</strong></p>
<blockquote>
<div><p>If False (default), return only the lowest threshold that satisfies
the above equality. If True, return all valid thresholds.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>threshold</strong> : float or int or array</p>
<blockquote class="last">
<div><p>Threshold value(s).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r202" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[R202]</a></td><td>Ridler, TW &amp; Calvard, S (1978), &#8220;Picture thresholding using an
iterative selection method&#8221;</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r203" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[R203]</a></td><td>IEEE Transactions on Systems, Man and Cybernetics 8: 630-632,
<a class="reference external" href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4310039">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4310039</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r204" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[R204]</a></td><td>Sezgin M. and Sankur B. (2004) &#8220;Survey over Image Thresholding
Techniques and Quantitative Performance Evaluation&#8221; Journal of
Electronic Imaging, 13(1): 146-165,
<a class="reference external" href="http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf">http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r205" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[R205]</a></td><td>ImageJ AutoThresholder code,
<a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">coins</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_isodata</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="threshold-li">
<h2>threshold_li<a class="headerlink" href="#threshold-li" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.threshold_li">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">threshold_li</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#skimage.filters.threshold_li" title="Permalink to this definition">¶</a></dt>
<dd><p>Return threshold value based on adaptation of Li&#8217;s Minimum Cross Entropy method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>threshold</strong> : float</p>
<blockquote class="last">
<div><p>Upper threshold value. All pixels intensities more than
this value are assumed to be foreground.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r206" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[R206]</a></td><td>Li C.H. and Lee C.K. (1993) &#8220;Minimum Cross Entropy Thresholding&#8221;
Pattern Recognition, 26(4): 617-625</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r207" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[R207]</a></td><td>Li C.H. and Tam P.K.S. (1998) &#8220;An Iterative Algorithm for Minimum
Cross Entropy Thresholding&#8221; Pattern Recognition Letters, 18(8): 771-776</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r208" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id24">[R208]</a></td><td>Sezgin M. and Sankur B. (2004) &#8220;Survey over Image Thresholding
Techniques and Quantitative Performance Evaluation&#8221; Journal of
Electronic Imaging, 13(1): 146-165
<a class="reference external" href="http://citeseer.ist.psu.edu/sezgin04survey.html">http://citeseer.ist.psu.edu/sezgin04survey.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r209" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[R209]</a></td><td>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_li</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="threshold-otsu">
<h2>threshold_otsu<a class="headerlink" href="#threshold-otsu" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.threshold_otsu">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">threshold_otsu</tt><big>(</big><em>image</em>, <em>nbins=256</em><big>)</big><a class="headerlink" href="#skimage.filters.threshold_otsu" title="Permalink to this definition">¶</a></dt>
<dd><p>Return threshold value based on Otsu&#8217;s method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>nbins</strong> : int, optional</p>
<blockquote>
<div><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>threshold</strong> : float</p>
<blockquote class="last">
<div><p>Upper threshold value. All pixels intensities that less or equal of
this value assumed as foreground.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r210" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id26">[R210]</a></td><td>Wikipedia, <a class="reference external" href="http://en.wikipedia.org/wiki/Otsu's_Method">http://en.wikipedia.org/wiki/Otsu&#8217;s_Method</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_otsu</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&lt;=</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="threshold-yen">
<h2>threshold_yen<a class="headerlink" href="#threshold-yen" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.threshold_yen">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">threshold_yen</tt><big>(</big><em>image</em>, <em>nbins=256</em><big>)</big><a class="headerlink" href="#skimage.filters.threshold_yen" title="Permalink to this definition">¶</a></dt>
<dd><p>Return threshold value based on Yen&#8217;s method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>nbins</strong> : int, optional</p>
<blockquote>
<div><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>threshold</strong> : float</p>
<blockquote class="last">
<div><p>Upper threshold value. All pixels intensities that less or equal of
this value assumed as foreground.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r211" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id27">[R211]</a></td><td>Yen J.C., Chang F.J., and Chang S. (1995) &#8220;A New Criterion
for Automatic Multilevel Thresholding&#8221; IEEE Trans. on Image
Processing, 4(3): 370-378</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r212" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id28">[R212]</a></td><td>Sezgin M. and Sankur B. (2004) &#8220;Survey over Image Thresholding
Techniques and Quantitative Performance Evaluation&#8221; Journal of
Electronic Imaging, 13(1): 146-165,
<a class="reference external" href="http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf">http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r213" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id29">[R213]</a></td><td>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_yen</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&lt;=</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="vprewitt">
<h2>vprewitt<a class="headerlink" href="#vprewitt" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.vprewitt">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">vprewitt</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.vprewitt" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.prewitt_v</span></tt> instead.</p>
<p>Find the vertical edges of an image using the Prewitt transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process.</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The absolute Prewitt edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel and return the absolute value of the
result at each point:</p>
<div class="highlight-python"><div class="highlight"><pre>1   0  -1
1   0  -1
1   0  -1
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="vscharr">
<h2>vscharr<a class="headerlink" href="#vscharr" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.vscharr">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">vscharr</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.vscharr" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.scharr_v</span></tt> instead.</p>
<p>Find the vertical edges of an image using the Scharr transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The absolute Scharr edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel and return the absolute value of the
result at each point:</p>
<div class="highlight-python"><div class="highlight"><pre> 3   0   -3
10   0  -10
 3   0   -3
</pre></div>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r214" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id30">[R214]</a></td><td>D. Kroon, 2009, Short Paper University Twente, Numerical
Optimization of Kernel Based Image Derivatives.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="vsobel">
<h2>vsobel<a class="headerlink" href="#vsobel" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.vsobel">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">vsobel</tt><big>(</big><em>image</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#skimage.filters.vsobel" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <tt class="docutils literal"><span class="pre">skimage.filters.sobel_v</span></tt> instead.</p>
<p>Find the vertical edges of an image using the Sobel transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Image to process</p>
</div></blockquote>
<p><strong>mask</strong> : 2-D array, optional</p>
<blockquote>
<div><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : 2-D array</p>
<blockquote class="last">
<div><p>The absolute Sobel edge map.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>We use the following kernel and return the absolute value of the
result at each point:</p>
<div class="highlight-python"><div class="highlight"><pre>1   0  -1
2   0  -2
1   0  -1
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="wiener">
<h2>wiener<a class="headerlink" href="#wiener" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.filters.wiener">
<tt class="descclassname">skimage.filters.</tt><tt class="descname">wiener</tt><big>(</big><em>data</em>, <em>impulse_response=None</em>, <em>filter_params={}</em>, <em>K=0.25</em>, <em>predefined_filter=None</em><big>)</big><a class="headerlink" href="#skimage.filters.wiener" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimum Mean Square Error (Wiener) inverse filter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : (M,N) ndarray</p>
<blockquote>
<div><p>Input data.</p>
</div></blockquote>
<p><strong>K</strong> : float or (M,N) ndarray</p>
<blockquote>
<div><p>Ratio between power spectrum of noise and undegraded
image.</p>
</div></blockquote>
<p><strong>impulse_response</strong> : callable <cite>f(r, c, **filter_params)</cite></p>
<blockquote>
<div><p>Impulse response of the filter.  See LPIFilter2D.__init__.</p>
</div></blockquote>
<p><strong>filter_params</strong> : dict</p>
<blockquote>
<div><p>Additional keyword parameters to the impulse_response function.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first"><strong>predefined_filter</strong> : LPIFilter2D</p>
<blockquote class="last">
<div><p>If you need to apply the same filter multiple times over different
images, construct the LPIFilter2D and specify it here.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="lpifilter2d">
<h2><a class="reference internal" href="#skimage.filters.LPIFilter2D" title="skimage.filters.LPIFilter2D"><tt class="xref py py-class docutils literal"><span class="pre">LPIFilter2D</span></tt></a><a class="headerlink" href="#lpifilter2d" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.filters.LPIFilter2D">
<em class="property">class </em><tt class="descclassname">skimage.filters.</tt><tt class="descname">LPIFilter2D</tt><big>(</big><em>impulse_response</em>, <em>**filter_params</em><big>)</big><a class="headerlink" href="#skimage.filters.LPIFilter2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Linear Position-Invariant Filter (2-dimensional)</p>
<dl class="method">
<dt id="skimage.filters.LPIFilter2D.__init__">
<tt class="descname">__init__</tt><big>(</big><em>impulse_response</em>, <em>**filter_params</em><big>)</big><a class="headerlink" href="#skimage.filters.LPIFilter2D.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>impulse_response</strong> : callable <cite>f(r, c, **filter_params)</cite></p>
<blockquote class="last">
<div><p>Function that yields the impulse response.  <cite>r</cite> and <cite>c</cite> are
1-dimensional vectors that represent row and column positions, in
other words coordinates are (r[0],c[0]),(r[0],c[1]) etc.
<cite>**filter_params</cite> are passed through.</p>
<p>In other words, <cite>impulse_response</cite> would be called like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">impulse_response</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">**</span><span class="n">filter_params</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filter_params</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;kw1&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;kw2&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;kw3&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">impulse_response</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">**</span><span class="n">filter_params</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Gaussian filter: Use a 1-D gaussian in each direction without
normalization coefficients.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">filt_func</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="n">sigma</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">filter</span> <span class="o">=</span> <span class="n">LPIFilter2D</span><span class="p">(</span><span class="n">filt_func</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="deprecated">
<h2><a class="reference internal" href="#skimage.filters.deprecated" title="skimage.filters.deprecated"><tt class="xref py py-class docutils literal"><span class="pre">deprecated</span></tt></a><a class="headerlink" href="#deprecated" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.filters.deprecated">
<em class="property">class </em><tt class="descclassname">skimage.filters.</tt><tt class="descname">deprecated</tt><big>(</big><em>alt_func=None</em>, <em>behavior='warn'</em><big>)</big><a class="headerlink" href="#skimage.filters.deprecated" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Decorator to mark deprecated functions with warning.</p>
<p>Adapted from &lt;<a class="reference external" href="http://wiki.python.org/moin/PythonDecoratorLibrary">http://wiki.python.org/moin/PythonDecoratorLibrary</a>&gt;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>alt_func</strong> : str</p>
<blockquote>
<div><p>If given, tell user what function to use instead.</p>
</div></blockquote>
<p><strong>behavior</strong> : {&#8216;warn&#8217;, &#8216;raise&#8217;}</p>
<blockquote class="last">
<div><p>Behavior during call to deprecated function: &#8216;warn&#8217; = warn user that
function is deprecated; &#8216;raise&#8217; = raise error.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.filters.deprecated.__init__">
<tt class="descname">__init__</tt><big>(</big><em>alt_func=None</em>, <em>behavior='warn'</em><big>)</big><a class="headerlink" href="#skimage.filters.deprecated.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>


        </div>
        <div class="span3"><h4 class="sidebar-box-heading">Navigation</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <li><a href="../index.html">Documentation Home</a></li>
    </ul>
</div>
    <h4 class="sidebar-box-heading">Previous topic</h4>
    <div class="well sidebar-box">
        <ul class="nav nav-list">
            <li><a href="skimage.feature.html" title="previous chapter">Module: <tt class="docutils literal"><span class="pre">feature</span></tt></a></li>
        </ul>
    </div>
    <h4 class="sidebar-box-heading">Next topic</h4>
    <div class="well sidebar-box">
        <ul class="nav nav-list">
            <li><a href="skimage.filters.rank.html" title="next chapter">Module: <tt class="docutils literal"><span class="pre">filters.rank</span></tt></a></li>
        </ul>
    </div>
        <h4 class="sidebar-box-heading">Contents</h4>
        <div class="well sidebar-box toc">
            <ul class="nav nav-list">
<li><a class="reference internal" href="#">Module: <tt class="docutils literal"><span class="pre">filters</span></tt></a><ul class="nav nav-list">
<li><a class="reference internal" href="#canny">canny</a></li>
<li><a class="reference internal" href="#denoise-bilateral">denoise_bilateral</a></li>
<li><a class="reference internal" href="#denoise-tv-bregman">denoise_tv_bregman</a></li>
<li><a class="reference internal" href="#denoise-tv-chambolle">denoise_tv_chambolle</a></li>
<li><a class="reference internal" href="#gabor-filter">gabor_filter</a></li>
<li><a class="reference internal" href="#gabor-kernel">gabor_kernel</a></li>
<li><a class="reference internal" href="#gaussian-filter">gaussian_filter</a></li>
<li><a class="reference internal" href="#hprewitt">hprewitt</a></li>
<li><a class="reference internal" href="#hscharr">hscharr</a></li>
<li><a class="reference internal" href="#hsobel">hsobel</a></li>
<li><a class="reference internal" href="#inverse">inverse</a></li>
<li><a class="reference internal" href="#median">median</a></li>
<li><a class="reference internal" href="#prewitt">prewitt</a></li>
<li><a class="reference internal" href="#prewitt-h">prewitt_h</a></li>
<li><a class="reference internal" href="#prewitt-v">prewitt_v</a></li>
<li><a class="reference internal" href="#rank-order">rank_order</a></li>
<li><a class="reference internal" href="#roberts">roberts</a></li>
<li><a class="reference internal" href="#roberts-neg-diag">roberts_neg_diag</a></li>
<li><a class="reference internal" href="#roberts-negative-diagonal">roberts_negative_diagonal</a></li>
<li><a class="reference internal" href="#roberts-pos-diag">roberts_pos_diag</a></li>
<li><a class="reference internal" href="#roberts-positive-diagonal">roberts_positive_diagonal</a></li>
<li><a class="reference internal" href="#scharr">scharr</a></li>
<li><a class="reference internal" href="#scharr-h">scharr_h</a></li>
<li><a class="reference internal" href="#scharr-v">scharr_v</a></li>
<li><a class="reference internal" href="#sobel">sobel</a></li>
<li><a class="reference internal" href="#sobel-h">sobel_h</a></li>
<li><a class="reference internal" href="#sobel-v">sobel_v</a></li>
<li><a class="reference internal" href="#threshold-adaptive">threshold_adaptive</a></li>
<li><a class="reference internal" href="#threshold-isodata">threshold_isodata</a></li>
<li><a class="reference internal" href="#threshold-li">threshold_li</a></li>
<li><a class="reference internal" href="#threshold-otsu">threshold_otsu</a></li>
<li><a class="reference internal" href="#threshold-yen">threshold_yen</a></li>
<li><a class="reference internal" href="#vprewitt">vprewitt</a></li>
<li><a class="reference internal" href="#vscharr">vscharr</a></li>
<li><a class="reference internal" href="#vsobel">vsobel</a></li>
<li><a class="reference internal" href="#wiener">wiener</a></li>
<li><a class="reference internal" href="#lpifilter2d"><tt class="docutils literal"><span class="pre">LPIFilter2D</span></tt></a></li>
<li><a class="reference internal" href="#deprecated"><tt class="docutils literal"><span class="pre">deprecated</span></tt></a></li>
</ul>
</li>
</ul>

        </div>

<h4 class="sidebar-box-heading">Versions</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <script src="../../dev/_static/docversions.js"></script>
        <script type="text/javascript">
            insert_version_links();
        </script>
    </ul>
</div>
        </div>
    </div>
    <div class="well footer">
        <small>
            &copy; Copyright the scikit-image development team.
            Created using <a href="http://getbootstrap.com/">Bootstrap</a> and <a href="http://sphinx-doc.org/">Sphinx</a>.
        </small>
    </div>
</body>
</html>