
<!DOCTYPE html>
<html lang="en">
<head>
        <title>Module: transform &mdash; skimage v0.18.0 docs</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../_static/css/custom.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
        <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
        <link rel="stylesheet" href="../_static/gallery-binder.css" type="text/css" />
        <link rel="stylesheet" href="../_static/gallery-dataframe.css" type="text/css" />
    
    <script src="https://code.jquery.com/jquery-latest.js"></script>
    <script src="../_static/js/bootstrap.min.js"></script>
    <script src="../_static/js/togglebutton.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.18.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
        <link rel="index" title="Index" href="../genindex.html" />
        <link rel="search" title="Search" href="../search.html" />
        <link rel="top" title="skimage v0.18.0 docs" href="../index.html" />
        <link rel="up" title="API Reference for skimage 0.18.0" href="api.html" />
        <link rel="next" title="Module: util" href="skimage.util.html" />
        <link rel="prev" title="Module: segmentation" href="skimage.segmentation.html" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="shortcut icon" href="../_static/favicon.ico">
    <!-- Plausible analytics -->
    <script async defer data-domain="scikit-image.org" src="https://plausible.io/js/plausible.outbound-links.js"></script>
</head>
<body class="container">
    <a href="https://scikit-image.org" class="logo"><img src="../_static/img/logo.png" alt=""></a>
    <div class="clearfix"></div>
    <div class="navbar">
        <div class="navbar-inner">
            <ul class="nav">
                <li><a href="/docs/stable/install.html">Installation</a></li>
<li><a href="../auto_examples/index.html">Gallery</a></li>
<li><a href="../index.html">Documentation</a></li>
<li><a href="/community_guidelines.html">Community</a></li>

<li><a href="https://github.com/scikit-image/scikit-image">
    <img src="../_static/GitHub-Mark-32px.png"
        style="height: 15px; width: 15px;
               display: inline; float: none;
               padding-bottom: 3px;">
    Source</a>
</li>
            </ul>
        </div>
    </div>
    <div class="row">
        <div class="span3"><div style="padding-bottom: 3em">
  <form class="navbar-form pull-right" action="../search.html" method="get">
    <input type="text" class="search span3" name="q" placeholder="Search documentation ...">
    <input type="hidden" name="check_keywords" value="yes" >
    <input type="hidden" name="area" value="default" >
  </form>
</div><!-- 
        <h4 class="sidebar-box-heading">Contents</h4>
        <div class="well sidebar-box toc">
            <ul class="nav nav-list">
<li><a class="reference internal" href="#">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">transform</span></code></a><ul class="nav nav-list">
<li><a class="reference internal" href="#downscale-local-mean">downscale_local_mean</a></li>
<li><a class="reference internal" href="#estimate-transform">estimate_transform</a></li>
<li><a class="reference internal" href="#frt2">frt2</a></li>
<li><a class="reference internal" href="#hough-circle">hough_circle</a></li>
<li><a class="reference internal" href="#hough-circle-peaks">hough_circle_peaks</a></li>
<li><a class="reference internal" href="#hough-ellipse">hough_ellipse</a></li>
<li><a class="reference internal" href="#hough-line">hough_line</a></li>
<li><a class="reference internal" href="#hough-line-peaks">hough_line_peaks</a></li>
<li><a class="reference internal" href="#ifrt2">ifrt2</a></li>
<li><a class="reference internal" href="#integral-image">integral_image</a></li>
<li><a class="reference internal" href="#integrate">integrate</a></li>
<li><a class="reference internal" href="#iradon">iradon</a></li>
<li><a class="reference internal" href="#iradon-sart">iradon_sart</a></li>
<li><a class="reference internal" href="#matrix-transform">matrix_transform</a></li>
<li><a class="reference internal" href="#order-angles-golden-ratio">order_angles_golden_ratio</a></li>
<li><a class="reference internal" href="#probabilistic-hough-line">probabilistic_hough_line</a></li>
<li><a class="reference internal" href="#pyramid-expand">pyramid_expand</a></li>
<li><a class="reference internal" href="#pyramid-gaussian">pyramid_gaussian</a></li>
<li><a class="reference internal" href="#pyramid-laplacian">pyramid_laplacian</a></li>
<li><a class="reference internal" href="#pyramid-reduce">pyramid_reduce</a></li>
<li><a class="reference internal" href="#radon">radon</a></li>
<li><a class="reference internal" href="#rescale">rescale</a></li>
<li><a class="reference internal" href="#resize">resize</a></li>
<li><a class="reference internal" href="#rotate">rotate</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-rotate">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.rotate</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#swirl">swirl</a></li>
<li><a class="reference internal" href="#warp">warp</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-warp">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#warp-coords">warp_coords</a></li>
<li><a class="reference internal" href="#warp-polar">warp_polar</a></li>
<li><a class="reference internal" href="#affinetransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a></li>
<li><a class="reference internal" href="#essentialmatrixtransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">EssentialMatrixTransform</span></code></a></li>
<li><a class="reference internal" href="#euclideantransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">EuclideanTransform</span></code></a></li>
<li><a class="reference internal" href="#fundamentalmatrixtransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">FundamentalMatrixTransform</span></code></a></li>
<li><a class="reference internal" href="#piecewiseaffinetransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseAffineTransform</span></code></a></li>
<li><a class="reference internal" href="#polynomialtransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolynomialTransform</span></code></a></li>
<li><a class="reference internal" href="#projectivetransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a></li>
<li><a class="reference internal" href="#similaritytransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimilarityTransform</span></code></a></li>
</ul>
</li>
</ul>

        </div>


 --><div class="well">
    <strong>Docs for 0.18.0<br></strong>

    <a id="other">All versions</a>

    <ul id="versionList" style="display: none;">
        <script src="../../dev/_static/docversions.js"></script>
        <script type="text/javascript">
            insert_version_links();
        </script>
    </ul>

 </div>

<script type="text/javascript">
	$("#other").click(function() {
		$("#versionList").toggle();
	});
</script>
        </div>
        <div class="span9" class="body" role="main">
            
  <div class="section" id="module-skimage.transform">
<span id="module-transform"></span><h1>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">transform</span></code><a class="headerlink" href="#module-skimage.transform" title="Permalink to this headline">¶</a></h1>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.downscale_local_mean</span></code></a>(…)</p></td>
<td><p>Down-sample N-dimensional image by local averaging.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.estimate_transform" title="skimage.transform.estimate_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.estimate_transform</span></code></a>(ttype, …)</p></td>
<td><p>Estimate 2D geometric transformation parameters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.frt2</span></code></a>(a)</p></td>
<td><p>Compute the 2-dimensional finite radon transform (FRT) for an n x n integer array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.hough_circle" title="skimage.transform.hough_circle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_circle</span></code></a>(image, radius)</p></td>
<td><p>Perform a circular Hough transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.hough_circle_peaks" title="skimage.transform.hough_circle_peaks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_circle_peaks</span></code></a>(…[, …])</p></td>
<td><p>Return peaks in a circle Hough transform.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.hough_ellipse" title="skimage.transform.hough_ellipse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_ellipse</span></code></a>(image[, …])</p></td>
<td><p>Perform an elliptical Hough transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_line</span></code></a>(image[, theta])</p></td>
<td><p>Perform a straight line Hough transform.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.hough_line_peaks" title="skimage.transform.hough_line_peaks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_line_peaks</span></code></a>(hspace, …)</p></td>
<td><p>Return peaks in a straight line Hough transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.ifrt2</span></code></a>(a)</p></td>
<td><p>Compute the 2-dimensional inverse finite radon transform (iFRT) for an (n+1) x n integer array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.integral_image" title="skimage.transform.integral_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.integral_image</span></code></a>(image)</p></td>
<td><p>Integral image / summed area table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.integrate" title="skimage.transform.integrate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.integrate</span></code></a>(ii, start, end)</p></td>
<td><p>Use an integral image to integrate over a given window.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.iradon" title="skimage.transform.iradon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.iradon</span></code></a>(radon_image[, …])</p></td>
<td><p>Inverse radon transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.iradon_sart" title="skimage.transform.iradon_sart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.iradon_sart</span></code></a>(radon_image[, …])</p></td>
<td><p>Inverse radon transform.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.matrix_transform" title="skimage.transform.matrix_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.matrix_transform</span></code></a>(coords, …)</p></td>
<td><p>Apply 2D matrix transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.order_angles_golden_ratio" title="skimage.transform.order_angles_golden_ratio"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.order_angles_golden_ratio</span></code></a>(theta)</p></td>
<td><p>Order angles to reduce the amount of correlated information in subsequent projections.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.probabilistic_hough_line" title="skimage.transform.probabilistic_hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.probabilistic_hough_line</span></code></a>(image)</p></td>
<td><p>Return lines from a progressive probabilistic line Hough transform.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.pyramid_expand" title="skimage.transform.pyramid_expand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_expand</span></code></a>(image[, …])</p></td>
<td><p>Upsample and then smooth image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.pyramid_gaussian" title="skimage.transform.pyramid_gaussian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_gaussian</span></code></a>(image[, …])</p></td>
<td><p>Yield images of the Gaussian pyramid formed by the input image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.pyramid_laplacian" title="skimage.transform.pyramid_laplacian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_laplacian</span></code></a>(image[, …])</p></td>
<td><p>Yield images of the laplacian pyramid formed by the input image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.pyramid_reduce" title="skimage.transform.pyramid_reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_reduce</span></code></a>(image[, …])</p></td>
<td><p>Smooth and then downsample image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.radon" title="skimage.transform.radon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.radon</span></code></a>(image[, theta, …])</p></td>
<td><p>Calculates the radon transform of an image given specified projection angles.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.rescale" title="skimage.transform.rescale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.rescale</span></code></a>(image, scale[, …])</p></td>
<td><p>Scale image by a certain factor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.resize" title="skimage.transform.resize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.resize</span></code></a>(image, output_shape)</p></td>
<td><p>Resize image to match a certain size.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.rotate" title="skimage.transform.rotate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.rotate</span></code></a>(image, angle[, …])</p></td>
<td><p>Rotate image by a certain angle around its center.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.swirl" title="skimage.transform.swirl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.swirl</span></code></a>(image[, center, …])</p></td>
<td><p>Perform a swirl transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a>(image, inverse_map[, …])</p></td>
<td><p>Warp an image according to a given coordinate transformation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.warp_coords" title="skimage.transform.warp_coords"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp_coords</span></code></a>(coord_map, shape)</p></td>
<td><p>Build the source coordinates for the output of a 2-D image warp.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.warp_polar" title="skimage.transform.warp_polar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp_polar</span></code></a>(image[, …])</p></td>
<td><p>Remap image to polar or log-polar coordinates space.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.AffineTransform</span></code></a>([matrix, …])</p></td>
<td><p>2D affine transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.EssentialMatrixTransform" title="skimage.transform.EssentialMatrixTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.EssentialMatrixTransform</span></code></a>([…])</p></td>
<td><p>Essential matrix transformation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.EuclideanTransform" title="skimage.transform.EuclideanTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.EuclideanTransform</span></code></a>([…])</p></td>
<td><p>2D Euclidean transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.FundamentalMatrixTransform" title="skimage.transform.FundamentalMatrixTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.FundamentalMatrixTransform</span></code></a>([…])</p></td>
<td><p>Fundamental matrix transformation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.PiecewiseAffineTransform" title="skimage.transform.PiecewiseAffineTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.PiecewiseAffineTransform</span></code></a>()</p></td>
<td><p>2D piecewise affine transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.PolynomialTransform" title="skimage.transform.PolynomialTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.PolynomialTransform</span></code></a>([params])</p></td>
<td><p>2D polynomial transformation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.ProjectiveTransform</span></code></a>([matrix])</p></td>
<td><p>Projective transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.SimilarityTransform</span></code></a>([…])</p></td>
<td><p>2D similarity transformation.</p></td>
</tr>
</tbody>
</table>
<div class="section" id="downscale-local-mean">
<h2>downscale_local_mean<a class="headerlink" href="#downscale-local-mean" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.downscale_local_mean">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">downscale_local_mean</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">factors</em>, <em class="sig-param">cval=0</em>, <em class="sig-param">clip=True</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L407-L451"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.downscale_local_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Down-sample N-dimensional image by local averaging.</p>
<p>The image is padded with <em class="xref py py-obj">cval</em> if it is not perfectly divisible by the
integer factors.</p>
<p>In contrast to interpolation in <a class="reference internal" href="#skimage.transform.resize" title="skimage.transform.resize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.resize</span></code></a> and
<a class="reference internal" href="#skimage.transform.rescale" title="skimage.transform.rescale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.rescale</span></code></a> this function calculates the local mean of
elements in each block of size <em class="xref py py-obj">factors</em> in the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>N-dimensional input image.</p>
</dd>
<dt><strong>factors</strong><span class="classifier">array_like</span></dt><dd><p>Array containing down-sampling integer factor along each axis.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Constant padding value if image is not perfectly divisible by the
integer factors.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Unused, but kept here for API consistency with the other transforms
in this module. (The local mean will never fall outside the range
of values in the input image, assuming the provided <em class="xref py py-obj">cval</em> also
falls within that range.)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Down-sampled image with same number of dimensions as input image.
For integer inputs, the output dtype will be <code class="docutils literal notranslate"><span class="pre">float64</span></code>.
See <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.mean.html#numpy.mean" title="(in NumPy v1.19)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.mean()</span></code></a> for details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3,  4],</span>
<span class="go">       [ 5,  6,  7,  8,  9],</span>
<span class="go">       [10, 11, 12, 13, 14]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">downscale_local_mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([[3.5, 4. ],</span>
<span class="go">       [5.5, 4.5]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="estimate-transform">
<h2>estimate_transform<a class="headerlink" href="#estimate-transform" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.estimate_transform">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">estimate_transform</code><span class="sig-paren">(</span><em class="sig-param">ttype</em>, <em class="sig-param">src</em>, <em class="sig-param">dst</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1342-L1413"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.estimate_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate 2D geometric transformation parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ttype</strong><span class="classifier">{‘euclidean’, similarity’, ‘affine’, ‘piecewise-affine’,              ‘projective’, ‘polynomial’}</span></dt><dd><p>Type of transform.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">array or int</span></dt><dd><p>Function parameters (src, dst, n, angle):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>NAME / TTYPE        FUNCTION PARAMETERS
&#39;euclidean&#39;         `src, `dst`
&#39;similarity&#39;        `src, `dst`
&#39;affine&#39;            `src, `dst`
&#39;piecewise-affine&#39;  `src, `dst`
&#39;projective&#39;        `src, `dst`
&#39;polynomial&#39;        `src, `dst`, `order` (polynomial order,
                                          default order is 2)
</pre></div>
</div>
<p>Also see examples below.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>tform</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeometricTransform</span></code></span></dt><dd><p>Transform object containing the transformation parameters and providing
access to forward and inverse transformation functions.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">transform</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimate transformation parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">estimate_transform</span><span class="p">(</span><span class="s1">&#39;similarity&#39;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">tform</span><span class="p">(</span><span class="n">src</span><span class="p">)),</span> <span class="n">src</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># warp image using the estimated transformation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">inverse_map</span><span class="o">=</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span> 
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># create transformation with explicit parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform2</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># unite transformations, applied in order from left to right</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform3</span> <span class="o">=</span> <span class="n">tform</span> <span class="o">+</span> <span class="n">tform2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">tform3</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">tform2</span><span class="p">(</span><span class="n">tform</span><span class="p">(</span><span class="n">src</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="frt2">
<h2>frt2<a class="headerlink" href="#frt2" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.frt2">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">frt2</code><span class="sig-paren">(</span><em class="sig-param">a</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/finite_radon_transform.py#L12-L68"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.frt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 2-dimensional finite radon transform (FRT) for an n x n
integer array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>A 2-D square n x n integer array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>FRT</strong><span class="classifier">2-D ndarray</span></dt><dd><p>Finite Radon Transform array of (n+1) x n integer coefficients.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifrt2</span></code></a></dt><dd><p>The two-dimensional inverse FRT.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The FRT has a unique inverse if and only if n is prime. [FRT]
The idea for this algorithm is due to Vlad Negnevitski.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rdb433381c1a5-frt"><span class="brackets">FRT</span></dt>
<dd><p>A. Kingston and I. Svalbe, “Projective transforms on periodic
discrete image arrays,” in P. Hawkes (Ed), Advances in Imaging
and Electron Physics, 139 (2006)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Generate a test image:
Use a prime number for the array dimensions</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SIZE</span> <span class="o">=</span> <span class="mi">59</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Finite Radon Transform:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">frt2</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="hough-circle">
<h2>hough_circle<a class="headerlink" href="#hough-circle" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough_circle">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">hough_circle</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">radius</em>, <em class="sig-param">normalize=True</em>, <em class="sig-param">full_output=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/hough_transform.py#L72-L113"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.hough_circle" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a circular Hough transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">scalar or sequence of scalars</span></dt><dd><p>Radii at which to compute the Hough transform.
Floats are converted to integers.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">boolean, optional (default True)</span></dt><dd><p>Normalize the accumulator with the number
of pixels used to draw the radius.</p>
</dd>
<dt><strong>full_output</strong><span class="classifier">boolean, optional (default False)</span></dt><dd><p>Extend the output size by twice the largest
radius in order to detect centers outside the
input picture.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>H</strong><span class="classifier">3D ndarray (radius index, (M + 2R, N + 2R) ndarray)</span></dt><dd><p>Hough transform accumulator for each radius.
R designates the larger radius if full_output is True.
Otherwise, R = 0.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough_circle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">circle_perimeter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">circle_perimeter</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">try_radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">hough_circle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">try_radii</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ridx</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">res</span><span class="p">),</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">try_radii</span><span class="p">[</span><span class="n">ridx</span><span class="p">]</span>
<span class="go">(25, 35, 23)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="hough-circle-peaks">
<h2>hough_circle_peaks<a class="headerlink" href="#hough-circle-peaks" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough_circle_peaks">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">hough_circle_peaks</code><span class="sig-paren">(</span><em class="sig-param">hspaces</em>, <em class="sig-param">radii</em>, <em class="sig-param">min_xdistance=1</em>, <em class="sig-param">min_ydistance=1</em>, <em class="sig-param">threshold=None</em>, <em class="sig-param">num_peaks=inf</em>, <em class="sig-param">total_num_peaks=inf</em>, <em class="sig-param">normalize=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/hough_transform.py#L271-L377"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.hough_circle_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return peaks in a circle Hough transform.</p>
<p>Identifies most prominent circles separated by certain distances in given
Hough spaces. Non-maximum suppression with different sizes is applied
separately in the first and second dimension of the Hough space to
identify peaks. For circles with different radius but close in distance,
only the one with highest peak is kept.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hspaces</strong><span class="classifier">(N, M) array</span></dt><dd><p>Hough spaces returned by the <a class="reference internal" href="#skimage.transform.hough_circle" title="skimage.transform.hough_circle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hough_circle</span></code></a> function.</p>
</dd>
<dt><strong>radii</strong><span class="classifier">(M,) array</span></dt><dd><p>Radii corresponding to Hough spaces.</p>
</dd>
<dt><strong>min_xdistance</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum distance separating centers in the x dimension.</p>
</dd>
<dt><strong>min_ydistance</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum distance separating centers in the y dimension.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Minimum intensity of peaks in each Hough space.
Default is <em class="xref py py-obj">0.5 * max(hspace)</em>.</p>
</dd>
<dt><strong>num_peaks</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of peaks in each Hough space. When the
number of peaks exceeds <em class="xref py py-obj">num_peaks</em>, only <em class="xref py py-obj">num_peaks</em>
coordinates based on peak intensity are considered for the
corresponding radius.</p>
</dd>
<dt><strong>total_num_peaks</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of peaks. When the number of peaks exceeds <em class="xref py py-obj">num_peaks</em>,
return <em class="xref py py-obj">num_peaks</em> coordinates based on peak intensity.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, normalize the accumulator by the radius to sort the prominent
peaks.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>accum, cx, cy, rad</strong><span class="classifier">tuple of array</span></dt><dd><p>Peak values in Hough space, x and y center coordinates and radii.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Circles with bigger radius have higher peaks in Hough space. If larger
circles are preferred over smaller ones, <em class="xref py py-obj">normalize</em> should be False.
Otherwise, circles will be returned in the order of decreasing voting
number.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">transform</span><span class="p">,</span> <span class="n">draw</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">120</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">radius</span><span class="p">,</span> <span class="n">x_0</span><span class="p">,</span> <span class="n">y_0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">draw</span><span class="o">.</span><span class="n">circle_perimeter</span><span class="p">(</span><span class="n">y_0</span><span class="p">,</span> <span class="n">x_0</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hspaces</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">hough_circle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">accum</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">rad</span> <span class="o">=</span> <span class="n">hough_circle_peaks</span><span class="p">(</span><span class="n">hspaces</span><span class="p">,</span> <span class="p">[</span><span class="n">radius</span><span class="p">,])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="hough-ellipse">
<h2>hough_ellipse<a class="headerlink" href="#hough-ellipse" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough_ellipse">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">hough_ellipse</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">threshold=4</em>, <em class="sig-param">accuracy=1</em>, <em class="sig-param">min_size=4</em>, <em class="sig-param">max_size=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/hough_transform.py#L116-L165"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.hough_ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an elliptical Hough transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">int, optional</span></dt><dd><p>Accumulator threshold value.</p>
</dd>
<dt><strong>accuracy</strong><span class="classifier">double, optional</span></dt><dd><p>Bin size on the minor axis used in the accumulator.</p>
</dd>
<dt><strong>min_size</strong><span class="classifier">int, optional</span></dt><dd><p>Minimal major axis length.</p>
</dd>
<dt><strong>max_size</strong><span class="classifier">int, optional</span></dt><dd><p>Maximal minor axis length.
If None, the value is set to the half of the smaller
image dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">ndarray with fields [(accumulator, yc, xc, a, b, orientation)].</span></dt><dd><p>Where <code class="docutils literal notranslate"><span class="pre">(yc,</span> <span class="pre">xc)</span></code> is the center, <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code> the major and minor
axes, respectively. The <em class="xref py py-obj">orientation</em> value follows
<a class="reference internal" href="skimage.draw.html#skimage.draw.ellipse_perimeter" title="skimage.draw.ellipse_perimeter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.draw.ellipse_perimeter</span></code></a> convention.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The accuracy must be chosen to produce a peak in the accumulator
distribution. In other words, a flat accumulator distribution with low
values may be caused by a too low bin size.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rf2ef66e2ec1f-1"><span class="brackets">1</span></dt>
<dd><p>Xie, Yonghong, and Qiang Ji. “A new efficient ellipse detection
method.” Pattern Recognition, 2002. Proceedings. 16th International
Conference on. Vol. 2. IEEE, 2002</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough_ellipse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">ellipse_perimeter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">ellipse_perimeter</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">cc</span><span class="p">,</span> <span class="n">rr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">hough_ellipse</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[(10, 10.0, 10.0, 8.0, 6.0, 0.0)]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="hough-line">
<h2>hough_line<a class="headerlink" href="#hough-line" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough_line">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">hough_line</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">theta=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/hough_transform.py#L168-L223"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.hough_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a straight line Hough transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">1D ndarray of double, optional</span></dt><dd><p>Angles at which to compute the transform, in radians.
Defaults to a vector of 180 angles evenly spaced from -pi/2 to pi/2.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>hspace</strong><span class="classifier">2-D ndarray of uint64</span></dt><dd><p>Hough transform accumulator.</p>
</dd>
<dt><strong>angles</strong><span class="classifier">ndarray</span></dt><dd><p>Angles at which the transform is computed, in radians.</p>
</dd>
<dt><strong>distances</strong><span class="classifier">ndarray</span></dt><dd><p>Distance values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The origin is the top left corner of the original image.
X and Y axis are horizontal and vertical edges respectively.
The distance is the minimal algebraic distance from the origin
to the detected line.
The angle accuracy can be improved by decreasing the step size in
the <em class="xref py py-obj">theta</em> array.</p>
<p class="rubric">Examples</p>
<p>Generate a test image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[:,</span> <span class="mi">65</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">45</span><span class="p">,</span> <span class="mi">35</span><span class="p">:</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">90</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.95</span>
</pre></div>
</div>
<p>Apply the Hough transform:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">hough_line</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough_line</span>
<span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">line</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">img</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span><span class="p">[:,</span> <span class="mi">65</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">45</span><span class="p">,</span> <span class="mi">35</span><span class="p">:</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">line</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">img</span><span class="p">[</span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.95</span>

<span class="n">out</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">hough_line</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

<span class="n">fix</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Input image&#39;</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span>
    <span class="n">out</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">bone</span><span class="p">,</span>
    <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Hough transform&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Angle (degree)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Distance (pixel)&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../plots/hough_tf.py">Source code</a>, <a class="reference external" href="../plots/hough_tf.png">png</a>, <a class="reference external" href="../plots/hough_tf.pdf">pdf</a>)</p>
<div class="figure align-default">
<img alt="../_images/hough_tf.png" src="../_images/hough_tf.png" />
</div>
</dd></dl>

</div>
<div class="section" id="hough-line-peaks">
<h2>hough_line_peaks<a class="headerlink" href="#hough-line-peaks" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough_line_peaks">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">hough_line_peaks</code><span class="sig-paren">(</span><em class="sig-param">hspace</em>, <em class="sig-param">angles</em>, <em class="sig-param">dists</em>, <em class="sig-param">min_distance=9</em>, <em class="sig-param">min_angle=10</em>, <em class="sig-param">threshold=None</em>, <em class="sig-param">num_peaks=inf</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/hough_transform.py#L9-L69"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.hough_line_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return peaks in a straight line Hough transform.</p>
<p>Identifies most prominent lines separated by a certain angle and distance
in a Hough transform. Non-maximum suppression with different sizes is
applied separately in the first (distances) and second (angles) dimension
of the Hough space to identify peaks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hspace</strong><span class="classifier">(N, M) array</span></dt><dd><p>Hough space returned by the <a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hough_line</span></code></a> function.</p>
</dd>
<dt><strong>angles</strong><span class="classifier">(M,) array</span></dt><dd><p>Angles returned by the <a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hough_line</span></code></a> function. Assumed to be continuous.
(<em class="xref py py-obj">angles[-1] - angles[0] == PI</em>).</p>
</dd>
<dt><strong>dists</strong><span class="classifier">(N, ) array</span></dt><dd><p>Distances returned by the <a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hough_line</span></code></a> function.</p>
</dd>
<dt><strong>min_distance</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum distance separating lines (maximum filter size for first
dimension of hough space).</p>
</dd>
<dt><strong>min_angle</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum angle separating lines (maximum filter size for second
dimension of hough space).</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Minimum intensity of peaks. Default is <em class="xref py py-obj">0.5 * max(hspace)</em>.</p>
</dd>
<dt><strong>num_peaks</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of peaks. When the number of peaks exceeds <em class="xref py py-obj">num_peaks</em>,
return <em class="xref py py-obj">num_peaks</em> coordinates based on peak intensity.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>accum, angles, dists</strong><span class="classifier">tuple of array</span></dt><dd><p>Peak values in Hough space, angles and distances.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough_line</span><span class="p">,</span> <span class="n">hough_line_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">line</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">line</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">line</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">cc</span><span class="p">,</span> <span class="n">rr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hspace</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dists</span> <span class="o">=</span> <span class="n">hough_line</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hspace</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dists</span> <span class="o">=</span> <span class="n">hough_line_peaks</span><span class="p">(</span><span class="n">hspace</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="ifrt2">
<h2>ifrt2<a class="headerlink" href="#ifrt2" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.ifrt2">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">ifrt2</code><span class="sig-paren">(</span><em class="sig-param">a</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/finite_radon_transform.py#L71-L134"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.ifrt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 2-dimensional inverse finite radon transform (iFRT) for
an (n+1) x n integer array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">array_like</span></dt><dd><p>A 2-D (n+1) row x n column integer array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>iFRT</strong><span class="classifier">2-D n x n ndarray</span></dt><dd><p>Inverse Finite Radon Transform array of n x n integer coefficients.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frt2</span></code></a></dt><dd><p>The two-dimensional FRT</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The FRT has a unique inverse if and only if n is prime.
See <a class="reference internal" href="#r3b76f892cb20-1" id="id3">[1]</a> for an overview.
The idea for this algorithm is due to Vlad Negnevitski.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r3b76f892cb20-1"><span class="brackets"><a class="fn-backref" href="#id3">1</a></span></dt>
<dd><p>A. Kingston and I. Svalbe, “Projective transforms on periodic
discrete image arrays,” in P. Hawkes (Ed), Advances in Imaging
and Electron Physics, 139 (2006)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SIZE</span> <span class="o">=</span> <span class="mi">59</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Finite Radon Transform:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">frt2</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Inverse Finite Radon Transform to recover the input</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fi</span> <span class="o">=</span> <span class="n">ifrt2</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Check that it’s identical to the original</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">img</span><span class="o">-</span><span class="n">fi</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="integral-image">
<h2>integral_image<a class="headerlink" href="#integral-image" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.integral_image">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">integral_image</code><span class="sig-paren">(</span><em class="sig-param">image</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/integral.py#L4-L33"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.integral_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Integral image / summed area table.</p>
<p>The integral image contains the sum of all elements above and to the
left of it, i.e.:</p>
<div class="math notranslate nohighlight">
\[S[m, n] = \sum_{i \leq m} \sum_{j \leq n} X[i, j]\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">ndarray</span></dt><dd><p>Integral image/summed area table of same shape as input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd91ebd979f08-1"><span class="brackets">1</span></dt>
<dd><p>F.C. Crow, “Summed-area tables for texture mapping,”
ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="integrate">
<h2>integrate<a class="headerlink" href="#integrate" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.integrate">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">integrate</code><span class="sig-paren">(</span><em class="sig-param">ii</em>, <em class="sig-param">start</em>, <em class="sig-param">end</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/integral.py#L36-L128"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Use an integral image to integrate over a given window.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ii</strong><span class="classifier">ndarray</span></dt><dd><p>Integral image.</p>
</dd>
<dt><strong>start</strong><span class="classifier">List of tuples, each tuple of length equal to dimension of <em class="xref py py-obj">ii</em></span></dt><dd><p>Coordinates of top left corner of window(s).
Each tuple in the list contains the starting row, col, … index
i.e <em class="xref py py-obj">[(row_win1, col_win1, …), (row_win2, col_win2,…), …]</em>.</p>
</dd>
<dt><strong>end</strong><span class="classifier">List of tuples, each tuple of length equal to dimension of <em class="xref py py-obj">ii</em></span></dt><dd><p>Coordinates of bottom right corner of window(s).
Each tuple in the list containing the end row, col, … index i.e
<em class="xref py py-obj">[(row_win1, col_win1, …), (row_win2, col_win2, …), …]</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">scalar or ndarray</span></dt><dd><p>Integral (sum) over the given window(s).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii</span> <span class="o">=</span> <span class="n">integral_image</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># sum from (1, 0) to (1, 2)</span>
<span class="go">array([3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>  <span class="c1"># sum from (3, 3) to (4, 5)</span>
<span class="go">array([6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># sum from (1, 0) to (1, 2) and from (3, 3) to (4, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>
<span class="go">array([3., 6.])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="iradon">
<h2>iradon<a class="headerlink" href="#iradon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.iradon">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">iradon</code><span class="sig-paren">(</span><em class="sig-param">radon_image</em>, <em class="sig-param">theta=None</em>, <em class="sig-param">output_size=None</em>, <em class="sig-param">filter_name='ramp'</em>, <em class="sig-param">interpolation='linear'</em>, <em class="sig-param">circle=True</em>, <em class="sig-param">preserve_range=True</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/radon_transform.py#L184-L314"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.iradon" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse radon transform.</p>
<p>Reconstruct an image from the radon transform, using the filtered
back projection algorithm.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radon_image</strong><span class="classifier">array</span></dt><dd><p>Image containing radon transform (sinogram). Each column of
the image corresponds to a projection along a different
angle. The tomography rotation axis should lie at the pixel
index <code class="docutils literal notranslate"><span class="pre">radon_image.shape[0]</span> <span class="pre">//</span> <span class="pre">2</span></code> along the 0th dimension of
<code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array_like, optional</span></dt><dd><p>Reconstruction angles (in degrees). Default: m angles evenly spaced
between 0 and 180 (if the shape of <em class="xref py py-obj">radon_image</em> is (N, M)).</p>
</dd>
<dt><strong>output_size</strong><span class="classifier">int, optional</span></dt><dd><p>Number of rows and columns in the reconstruction.</p>
</dd>
<dt><strong>filter_name</strong><span class="classifier">str, optional</span></dt><dd><p>Filter used in frequency domain filtering. Ramp filter used by default.
Filters available: ramp, shepp-logan, cosine, hamming, hann.
Assign None to use no filter.</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">str, optional</span></dt><dd><p>Interpolation method used in reconstruction. Methods available:
‘linear’, ‘nearest’, and ‘cubic’ (‘cubic’ is slow).</p>
</dd>
<dt><strong>circle</strong><span class="classifier">boolean, optional</span></dt><dd><p>Assume the reconstructed image is zero outside the inscribed circle.
Also changes the default output_size to match the behaviour of
<code class="docutils literal notranslate"><span class="pre">radon</span></code> called with <code class="docutils literal notranslate"><span class="pre">circle=True</span></code>.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reconstructed</strong><span class="classifier">ndarray</span></dt><dd><p>Reconstructed image. The rotation axis will be located in the pixel
with indices
<code class="docutils literal notranslate"><span class="pre">(reconstructed.shape[0]</span> <span class="pre">//</span> <span class="pre">2,</span> <span class="pre">reconstructed.shape[1]</span> <span class="pre">//</span> <span class="pre">2)</span></code>.</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.19: </span>In <code class="docutils literal notranslate"><span class="pre">iradon</span></code>, <code class="docutils literal notranslate"><span class="pre">filter</span></code> argument is deprecated in favor of
<code class="docutils literal notranslate"><span class="pre">filter_name</span></code>.</p>
</div>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>It applies the Fourier slice theorem to reconstruct an image by
multiplying the frequency domain of the filter with the FFT of the
projection data. This algorithm is called filtered back projection.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r19c92af887b5-1"><span class="brackets">1</span></dt>
<dd><p>AC Kak, M Slaney, “Principles of Computerized Tomographic
Imaging”, IEEE Press 1988.</p>
</dd>
<dt class="label" id="r19c92af887b5-2"><span class="brackets">2</span></dt>
<dd><p>B.R. Ramesh, N. Srinivasa, K. Rajgopal, “An Algorithm for Computing
the Discrete Radon Transform With Some Applications”, Proceedings of
the Fourth IEEE Region 10 International Conference, TENCON ‘89, 1989</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="iradon-sart">
<h2>iradon_sart<a class="headerlink" href="#iradon-sart" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.iradon_sart">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">iradon_sart</code><span class="sig-paren">(</span><em class="sig-param">radon_image</em>, <em class="sig-param">theta=None</em>, <em class="sig-param">image=None</em>, <em class="sig-param">projection_shifts=None</em>, <em class="sig-param">clip=None</em>, <em class="sig-param">relaxation=0.15</em>, <em class="sig-param">dtype=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/radon_transform.py#L376-L515"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.iradon_sart" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse radon transform.</p>
<p>Reconstruct an image from the radon transform, using a single iteration of
the Simultaneous Algebraic Reconstruction Technique (SART) algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radon_image</strong><span class="classifier">2D array</span></dt><dd><p>Image containing radon transform (sinogram). Each column of
the image corresponds to a projection along a different angle. The
tomography rotation axis should lie at the pixel index
<code class="docutils literal notranslate"><span class="pre">radon_image.shape[0]</span> <span class="pre">//</span> <span class="pre">2</span></code> along the 0th dimension of
<code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">1D array, optional</span></dt><dd><p>Reconstruction angles (in degrees). Default: m angles evenly spaced
between 0 and 180 (if the shape of <em class="xref py py-obj">radon_image</em> is (N, M)).</p>
</dd>
<dt><strong>image</strong><span class="classifier">2D array, optional</span></dt><dd><p>Image containing an initial reconstruction estimate. Shape of this
array should be <code class="docutils literal notranslate"><span class="pre">(radon_image.shape[0],</span> <span class="pre">radon_image.shape[0])</span></code>. The
default is an array of zeros.</p>
</dd>
<dt><strong>projection_shifts</strong><span class="classifier">1D array, optional</span></dt><dd><p>Shift the projections contained in <code class="docutils literal notranslate"><span class="pre">radon_image</span></code> (the sinogram) by
this many pixels before reconstructing the image. The i’th value
defines the shift of the i’th column of <code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">length-2 sequence of floats, optional</span></dt><dd><p>Force all values in the reconstructed tomogram to lie in the range
<code class="docutils literal notranslate"><span class="pre">[clip[0],</span> <span class="pre">clip[1]]</span></code></p>
</dd>
<dt><strong>relaxation</strong><span class="classifier">float, optional</span></dt><dd><p>Relaxation parameter for the update step. A higher value can
improve the convergence rate, but one runs the risk of instabilities.
Values close to or higher than 1 are not recommended.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>Output data type, must be floating point. By default, if input
data type is not float, input is cast to double, otherwise
dtype is set to input data type.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reconstructed</strong><span class="classifier">ndarray</span></dt><dd><p>Reconstructed image. The rotation axis will be located in the pixel
with indices
<code class="docutils literal notranslate"><span class="pre">(reconstructed.shape[0]</span> <span class="pre">//</span> <span class="pre">2,</span> <span class="pre">reconstructed.shape[1]</span> <span class="pre">//</span> <span class="pre">2)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Algebraic Reconstruction Techniques are based on formulating the tomography
reconstruction problem as a set of linear equations. Along each ray,
the projected value is the sum of all the values of the cross section along
the ray. A typical feature of SART (and a few other variants of algebraic
techniques) is that it samples the cross section at equidistant points
along the ray, using linear interpolation between the pixel values of the
cross section. The resulting set of linear equations are then solved using
a slightly modified Kaczmarz method.</p>
<p>When using SART, a single iteration is usually sufficient to obtain a good
reconstruction. Further iterations will tend to enhance high-frequency
information, but will also often increase the noise.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5a4015ea6a92-1"><span class="brackets">1</span></dt>
<dd><p>AC Kak, M Slaney, “Principles of Computerized Tomographic
Imaging”, IEEE Press 1988.</p>
</dd>
<dt class="label" id="r5a4015ea6a92-2"><span class="brackets">2</span></dt>
<dd><p>AH Andersen, AC Kak, “Simultaneous algebraic reconstruction
technique (SART): a superior implementation of the ART algorithm”,
Ultrasonic Imaging 6 pp 81–94 (1984)</p>
</dd>
<dt class="label" id="r5a4015ea6a92-3"><span class="brackets">3</span></dt>
<dd><p>S Kaczmarz, “Angenäherte auflösung von systemen linearer
gleichungen”, Bulletin International de l’Academie Polonaise des
Sciences et des Lettres 35 pp 355–357 (1937)</p>
</dd>
<dt class="label" id="r5a4015ea6a92-4"><span class="brackets">4</span></dt>
<dd><p>Kohler, T. “A projection access scheme for iterative
reconstruction based on the golden section.” Nuclear Science
Symposium Conference Record, 2004 IEEE. Vol. 6. IEEE, 2004.</p>
</dd>
<dt class="label" id="r5a4015ea6a92-5"><span class="brackets">5</span></dt>
<dd><p>Kaczmarz’ method, Wikipedia,
<a class="reference external" href="https://en.wikipedia.org/wiki/Kaczmarz_method">https://en.wikipedia.org/wiki/Kaczmarz_method</a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="matrix-transform">
<h2>matrix_transform<a class="headerlink" href="#matrix-transform" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.matrix_transform">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">matrix_transform</code><span class="sig-paren">(</span><em class="sig-param">coords</em>, <em class="sig-param">matrix</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1416-L1432"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.matrix_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply 2D matrix transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>x, y coordinates to transform</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">(3, 3) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Transformed coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="order-angles-golden-ratio">
<h2>order_angles_golden_ratio<a class="headerlink" href="#order-angles-golden-ratio" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.order_angles_golden_ratio">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">order_angles_golden_ratio</code><span class="sig-paren">(</span><em class="sig-param">theta</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/radon_transform.py#L317-L373"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.order_angles_golden_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Order angles to reduce the amount of correlated information in
subsequent projections.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>theta</strong><span class="classifier">1D array of floats</span></dt><dd><p>Projection angles in degrees. Duplicate angles are not allowed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>indices_generator</strong><span class="classifier">generator yielding unsigned integers</span></dt><dd><p>The returned generator yields indices into <code class="docutils literal notranslate"><span class="pre">theta</span></code> such that
<code class="docutils literal notranslate"><span class="pre">theta[indices]</span></code> gives the approximate golden ratio ordering
of the projections. In total, <code class="docutils literal notranslate"><span class="pre">len(theta)</span></code> indices are yielded.
All non-negative integers &lt; <code class="docutils literal notranslate"><span class="pre">len(theta)</span></code> are yielded exactly once.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The method used here is that of the golden ratio introduced
by T. Kohler.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r88d6c0557044-1"><span class="brackets">1</span></dt>
<dd><p>Kohler, T. “A projection access scheme for iterative
reconstruction based on the golden section.” Nuclear Science
Symposium Conference Record, 2004 IEEE. Vol. 6. IEEE, 2004.</p>
</dd>
<dt class="label" id="r88d6c0557044-2"><span class="brackets">2</span></dt>
<dd><p>Winkelmann, Stefanie, et al. “An optimal radial profile order
based on the Golden Ratio for time-resolved MRI.”
Medical Imaging, IEEE Transactions on 26.1 (2007): 68-76.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="probabilistic-hough-line">
<h2>probabilistic_hough_line<a class="headerlink" href="#probabilistic-hough-line" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.probabilistic_hough_line">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">probabilistic_hough_line</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">threshold=10</em>, <em class="sig-param">line_length=50</em>, <em class="sig-param">line_gap=10</em>, <em class="sig-param">theta=None</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/hough_transform.py#L226-L268"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.probabilistic_hough_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Return lines from a progressive probabilistic line Hough transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">int, optional</span></dt><dd><p>Threshold</p>
</dd>
<dt><strong>line_length</strong><span class="classifier">int, optional</span></dt><dd><p>Minimum accepted length of detected lines.
Increase the parameter to extract longer lines.</p>
</dd>
<dt><strong>line_gap</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum gap between pixels to still form a line.
Increase the parameter to merge broken lines more aggressively.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">1D ndarray, dtype=double, optional</span></dt><dd><p>Angles at which to compute the transform, in radians.
If None, use a range from -pi/2 to pi/2.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Seed to initialize the random number generator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>lines</strong><span class="classifier">list</span></dt><dd><p>List of lines identified, lines in format ((x0, y0), (x1, y1)),
indicating line start and end.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd9a46cdb16bc-1"><span class="brackets">1</span></dt>
<dd><p>C. Galamhos, J. Matas and J. Kittler, “Progressive probabilistic
Hough transform for line detection”, in IEEE Computer Society
Conference on Computer Vision and Pattern Recognition, 1999.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="pyramid-expand">
<h2>pyramid_expand<a class="headerlink" href="#pyramid-expand" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_expand">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">pyramid_expand</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">upscale=2</em>, <em class="sig-param">sigma=None</em>, <em class="sig-param">order=1</em>, <em class="sig-param">mode='reflect'</em>, <em class="sig-param">cval=0</em>, <em class="sig-param">multichannel=False</em>, <em class="sig-param">preserve_range=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/pyramids.py#L85-L142"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.pyramid_expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Upsample and then smooth image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>upscale</strong><span class="classifier">float, optional</span></dt><dd><p>Upscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <em class="xref py py-obj">2 * upscale / 6.0</em> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of upsampling. See
<a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>Upsampled and smoothed float image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r53df52222c6d-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="pyramid-gaussian">
<h2>pyramid_gaussian<a class="headerlink" href="#pyramid-gaussian" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_gaussian">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">pyramid_gaussian</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">max_layer=-1</em>, <em class="sig-param">downscale=2</em>, <em class="sig-param">sigma=None</em>, <em class="sig-param">order=1</em>, <em class="sig-param">mode='reflect'</em>, <em class="sig-param">cval=0</em>, <em class="sig-param">multichannel=False</em>, <em class="sig-param">preserve_range=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/pyramids.py#L145-L224"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.pyramid_gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield images of the Gaussian pyramid formed by the input image.</p>
<p>Recursively applies the <a class="reference internal" href="#skimage.transform.pyramid_reduce" title="skimage.transform.pyramid_reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pyramid_reduce</span></code></a> function to the image, and yields
the downscaled images.</p>
<p>Note that the first image of the pyramid will be the original, unscaled
image. The total number of images is <em class="xref py py-obj">max_layer + 1</em>. In case all layers
are computed, the last image is either a one-pixel image or the image where
the reduction does not change its shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>max_layer</strong><span class="classifier">int, optional</span></dt><dd><p>Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</dd>
<dt><strong>downscale</strong><span class="classifier">float, optional</span></dt><dd><p>Downscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <em class="xref py py-obj">2 * downscale / 6.0</em> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of downsampling. See
<a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pyramid</strong><span class="classifier">generator</span></dt><dd><p>Generator yielding pyramid layers as float images.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4f1da659b730-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="pyramid-laplacian">
<h2>pyramid_laplacian<a class="headerlink" href="#pyramid-laplacian" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_laplacian">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">pyramid_laplacian</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">max_layer=-1</em>, <em class="sig-param">downscale=2</em>, <em class="sig-param">sigma=None</em>, <em class="sig-param">order=1</em>, <em class="sig-param">mode='reflect'</em>, <em class="sig-param">cval=0</em>, <em class="sig-param">multichannel=False</em>, <em class="sig-param">preserve_range=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/pyramids.py#L227-L317"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.pyramid_laplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield images of the laplacian pyramid formed by the input image.</p>
<p>Each layer contains the difference between the downsampled and the
downsampled, smoothed image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">layer</span> <span class="o">=</span> <span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">)</span> <span class="o">-</span> <span class="n">smooth</span><span class="p">(</span><span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that the first image of the pyramid will be the difference between the
original, unscaled image and its smoothed version. The total number of
images is <em class="xref py py-obj">max_layer + 1</em>. In case all layers are computed, the last image
is either a one-pixel image or the image where the reduction does not
change its shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>max_layer</strong><span class="classifier">int, optional</span></dt><dd><p>Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</dd>
<dt><strong>downscale</strong><span class="classifier">float, optional</span></dt><dd><p>Downscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <em class="xref py py-obj">2 * downscale / 6.0</em> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of downsampling. See
<a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pyramid</strong><span class="classifier">generator</span></dt><dd><p>Generator yielding pyramid layers as float images.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r64565393f7ed-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</dd>
<dt class="label" id="r64565393f7ed-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="http://sepwww.stanford.edu/data/media/public/sep/morgan/texturematch/paper_html/node3.html">http://sepwww.stanford.edu/data/media/public/sep/morgan/texturematch/paper_html/node3.html</a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="pyramid-reduce">
<h2>pyramid_reduce<a class="headerlink" href="#pyramid-reduce" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_reduce">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">pyramid_reduce</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">downscale=2</em>, <em class="sig-param">sigma=None</em>, <em class="sig-param">order=1</em>, <em class="sig-param">mode='reflect'</em>, <em class="sig-param">cval=0</em>, <em class="sig-param">multichannel=False</em>, <em class="sig-param">preserve_range=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/pyramids.py#L25-L82"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.pyramid_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth and then downsample image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>downscale</strong><span class="classifier">float, optional</span></dt><dd><p>Downscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <em class="xref py py-obj">2 * downscale / 6.0</em> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of downsampling. See
<a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>Smoothed and downsampled float image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4f51c9e42c4a-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="radon">
<h2>radon<a class="headerlink" href="#radon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.radon">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">radon</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">theta=None</em>, <em class="sig-param">circle=True</em>, <em class="sig-param">*</em>, <em class="sig-param">preserve_range=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/radon_transform.py#L24-L115"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.radon" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the radon transform of an image given specified
projection angles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array_like</span></dt><dd><p>Input image. The rotation axis will be located in the pixel with
indices <code class="docutils literal notranslate"><span class="pre">(image.shape[0]</span> <span class="pre">//</span> <span class="pre">2,</span> <span class="pre">image.shape[1]</span> <span class="pre">//</span> <span class="pre">2)</span></code>.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">array_like, optional</span></dt><dd><p>Projection angles (in degrees). If <em class="xref py py-obj">None</em>, the value is set to
np.arange(180).</p>
</dd>
<dt><strong>circle</strong><span class="classifier">boolean, optional</span></dt><dd><p>Assume image is zero outside the inscribed circle, making the
width of each projection (the first dimension of the sinogram)
equal to <code class="docutils literal notranslate"><span class="pre">min(image.shape)</span></code>.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>radon_image</strong><span class="classifier">ndarray</span></dt><dd><p>Radon transform (sinogram).  The tomography rotation axis will lie
at the pixel index <code class="docutils literal notranslate"><span class="pre">radon_image.shape[0]</span> <span class="pre">//</span> <span class="pre">2</span></code> along the 0th
dimension of <code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Based on code of Justin K. Romberg
(<a class="reference external" href="https://www.clear.rice.edu/elec431/projects96/DSP/bpanalysis.html">https://www.clear.rice.edu/elec431/projects96/DSP/bpanalysis.html</a>)</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0eb755fc1fae-1"><span class="brackets">1</span></dt>
<dd><p>AC Kak, M Slaney, “Principles of Computerized Tomographic
Imaging”, IEEE Press 1988.</p>
</dd>
<dt class="label" id="r0eb755fc1fae-2"><span class="brackets">2</span></dt>
<dd><p>B.R. Ramesh, N. Srinivasa, K. Rajgopal, “An Algorithm for Computing
the Discrete Radon Transform With Some Applications”, Proceedings of
the Fourth IEEE Region 10 International Conference, TENCON ‘89, 1989</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="rescale">
<h2>rescale<a class="headerlink" href="#rescale" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.rescale">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">rescale</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">scale</em>, <em class="sig-param">order=None</em>, <em class="sig-param">mode='reflect'</em>, <em class="sig-param">cval=0</em>, <em class="sig-param">clip=True</em>, <em class="sig-param">preserve_range=False</em>, <em class="sig-param">multichannel=False</em>, <em class="sig-param">anti_aliasing=None</em>, <em class="sig-param">anti_aliasing_sigma=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L201-L293"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.rescale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale image by a certain factor.</p>
<p>Performs interpolation to up-scale or down-scale N-dimensional images.
Note that anti-aliasing should be enabled when down-sizing images to avoid
aliasing artifacts. For down-sampling with an integer factor also see
<a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.downscale_local_mean</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">{float, tuple of floats}</span></dt><dd><p>Scale factors. Separate scale factors can be defined as
<em class="xref py py-obj">(rows, cols[, …][, dim])</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scaled</strong><span class="classifier">ndarray</span></dt><dd><p>Scaled version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension.</p>
</dd>
<dt><strong>anti_aliasing</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to apply a Gaussian filter to smooth the image prior
to down-scaling. It is crucial to filter when down-sampling
the image to avoid aliasing artifacts. If input image data
type is bool, no anti-aliasing is applied.</p>
</dd>
<dt><strong>anti_aliasing_sigma</strong><span class="classifier">{float, tuple of floats}, optional</span></dt><dd><p>Standard deviation for Gaussian filtering to avoid aliasing artifacts.
By default, this value is chosen as (s - 1) / 2 where s is the
down-scaling factor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">rescale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(51, 51)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(256, 256)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="resize">
<h2>resize<a class="headerlink" href="#resize" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.resize">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">resize</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">output_shape</em>, <em class="sig-param">order=None</em>, <em class="sig-param">mode='reflect'</em>, <em class="sig-param">cval=0</em>, <em class="sig-param">clip=True</em>, <em class="sig-param">preserve_range=False</em>, <em class="sig-param">anti_aliasing=None</em>, <em class="sig-param">anti_aliasing_sigma=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L19-L198"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize image to match a certain size.</p>
<p>Performs interpolation to up-size or down-size N-dimensional images. Note
that anti-aliasing should be enabled when down-sizing images to avoid
aliasing artifacts. For down-sampling with an integer factor also see
<a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.downscale_local_mean</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">tuple or ndarray</span></dt><dd><p>Size of the generated output image <em class="xref py py-obj">(rows, cols[, …][, dim])</em>. If
<em class="xref py py-obj">dim</em> is not provided, the number of channels is preserved. In case the
number of input channels does not equal the number of output channels a
n-dimensional interpolation is applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>resized</strong><span class="classifier">ndarray</span></dt><dd><p>Resized version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>anti_aliasing</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to apply a Gaussian filter to smooth the image prior
to down-scaling. It is crucial to filter when down-sampling
the image to avoid aliasing artifacts. If input image data
type is bool, no anti-aliasing is applied.</p>
</dd>
<dt><strong>anti_aliasing_sigma</strong><span class="classifier">{float, tuple of floats}, optional</span></dt><dd><p>Standard deviation for Gaussian filtering to avoid aliasing artifacts.
By default, this value is chosen as (s - 1) / 2 where s is the
down-scaling factor, where s &gt; 1. For the up-size case, s &lt; 1, no
anti-aliasing is performed prior to rescaling.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">resize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="rotate">
<h2>rotate<a class="headerlink" href="#rotate" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.rotate">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">rotate</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">angle</em>, <em class="sig-param">resize=False</em>, <em class="sig-param">center=None</em>, <em class="sig-param">order=None</em>, <em class="sig-param">mode='constant'</em>, <em class="sig-param">cval=0</em>, <em class="sig-param">clip=True</em>, <em class="sig-param">preserve_range=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L296-L404"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate image by a certain angle around its center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>angle</strong><span class="classifier">float</span></dt><dd><p>Rotation angle in degrees in counter-clockwise direction.</p>
</dd>
<dt><strong>resize</strong><span class="classifier">bool, optional</span></dt><dd><p>Determine whether the shape of the output image will be automatically
calculated, so the complete rotated image exactly fits. Default is
False.</p>
</dd>
<dt><strong>center</strong><span class="classifier">iterable of length 2</span></dt><dd><p>The rotation center. If <code class="docutils literal notranslate"><span class="pre">center=None</span></code>, the image is rotated around
its center, i.e. <code class="docutils literal notranslate"><span class="pre">center=(cols</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">-</span> <span class="pre">0.5,</span> <span class="pre">rows</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">-</span> <span class="pre">0.5)</span></code>.  Please
note that this parameter is (cols, rows), contrary to normal skimage
ordering.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rotated</strong><span class="classifier">ndarray</span></dt><dd><p>Rotated version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">rotate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(512, 512)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(530, 530)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(512, 512)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-rotate">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.rotate</span></code><a class="headerlink" href="#examples-using-skimage-transform-rotate" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="In this example we show the uncertainty on calculating perimeters, comparing classic and Crofto..."><div class="figure align-default" id="id25">
<img alt="Different perimeters" src="../_images/sphx_glr_plot_perimeters_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_perimeters.html#sphx-glr-auto-examples-segmentation-plot-perimeters-py"><span class="std std-ref">Different perimeters</span></a></span><a class="headerlink" href="#id25" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima..."><div class="figure align-default" id="id26">
<img alt="Measure region properties" src="../_images/sphx_glr_plot_regionprops_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></span><a class="headerlink" href="#id26" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="swirl">
<h2>swirl<a class="headerlink" href="#swirl" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.swirl">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">swirl</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">center=None</em>, <em class="sig-param">strength=1</em>, <em class="sig-param">radius=100</em>, <em class="sig-param">rotation=0</em>, <em class="sig-param">output_shape=None</em>, <em class="sig-param">order=None</em>, <em class="sig-param">mode='reflect'</em>, <em class="sig-param">cval=0</em>, <em class="sig-param">clip=True</em>, <em class="sig-param">preserve_range=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L473-L534"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.swirl" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a swirl transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>center</strong><span class="classifier">(column, row) tuple or (2,) ndarray, optional</span></dt><dd><p>Center coordinate of transformation.</p>
</dd>
<dt><strong>strength</strong><span class="classifier">float, optional</span></dt><dd><p>The amount of swirling applied.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>The extent of the swirl in pixels.  The effect dies out
rapidly beyond <em class="xref py py-obj">radius</em>.</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Additional rotation applied to the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>swirled</strong><span class="classifier">ndarray</span></dt><dd><p>Swirled version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>output_shape</strong><span class="classifier">tuple (rows, cols), optional</span></dt><dd><p>Shape of the output image generated. By default the shape of the input
image is preserved.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode, with ‘constant’ used as the default. Modes match
the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="warp">
<h2>warp<a class="headerlink" href="#warp" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.warp">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">warp</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">inverse_map</em>, <em class="sig-param">map_args={}</em>, <em class="sig-param">output_shape=None</em>, <em class="sig-param">order=None</em>, <em class="sig-param">mode='constant'</em>, <em class="sig-param">cval=0.0</em>, <em class="sig-param">clip=True</em>, <em class="sig-param">preserve_range=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L684-L932"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.warp" title="Permalink to this definition">¶</a></dt>
<dd><p>Warp an image according to a given coordinate transformation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>inverse_map</strong><span class="classifier">transformation object, callable <code class="docutils literal notranslate"><span class="pre">cr</span> <span class="pre">=</span> <span class="pre">f(cr,</span> <span class="pre">**kwargs)</span></code>, or ndarray</span></dt><dd><p>Inverse coordinate map, which transforms coordinates in the output
images into their corresponding coordinates in the input image.</p>
<p>There are a number of different options to define this map, depending
on the dimensionality of the input image. A 2-D image can have 2
dimensions for gray-scale images, or 3 dimensions with color
information.</p>
<blockquote>
<div><ul class="simple">
<li><p>For 2-D images, you can directly pass a transformation object,
e.g. <a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.SimilarityTransform</span></code></a>, or its inverse.</p></li>
<li><p>For 2-D images, you can pass a <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3)</span></code> homogeneous
transformation matrix, e.g.
<em class="xref py py-obj">skimage.transform.SimilarityTransform.params</em>.</p></li>
<li><p>For 2-D images, a function that transforms a <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">2)</span></code> array of
<code class="docutils literal notranslate"><span class="pre">(col,</span> <span class="pre">row)</span></code> coordinates in the output image to their
corresponding coordinates in the input image. Extra parameters to
the function can be specified through <em class="xref py py-obj">map_args</em>.</p></li>
<li><p>For N-D images, you can directly pass an array of coordinates.
The first dimension specifies the coordinates in the input image,
while the subsequent dimensions determine the position in the
output image. E.g. in case of 2-D images, you need to pass an array
of shape <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">rows,</span> <span class="pre">cols)</span></code>, where <em class="xref py py-obj">rows</em> and <em class="xref py py-obj">cols</em> determine the
shape of the output image, and the first dimension contains the
<code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> coordinate in the input image.
See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.map_coordinates.html#scipy.ndimage.map_coordinates" title="(in SciPy v1.5.4)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.ndimage.map_coordinates</span></code></a> for further documentation.</p></li>
</ul>
</div></blockquote>
<p>Note, that a <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3)</span></code> matrix is interpreted as a homogeneous
transformation matrix, so you cannot interpolate values from a 3-D
input, if the output is of shape <code class="docutils literal notranslate"><span class="pre">(3,)</span></code>.</p>
<p>See example section for usage.</p>
</dd>
<dt><strong>map_args</strong><span class="classifier">dict, optional</span></dt><dd><p>Keyword arguments passed to <em class="xref py py-obj">inverse_map</em>.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">tuple (rows, cols), optional</span></dt><dd><p>Shape of the output image generated. By default the shape of the input
image is preserved.  Note that, even for multi-band images, only rows
and columns need to be specified.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><dl>
<dt>The order of interpolation. The order has to be in the range 0-5:</dt><dd><ul class="simple">
<li><p>0: Nearest-neighbor</p></li>
<li><p>1: Bi-linear (default)</p></li>
<li><p>2: Bi-quadratic</p></li>
<li><p>3: Bi-cubic</p></li>
<li><p>4: Bi-quartic</p></li>
<li><p>5: Bi-quintic</p></li>
</ul>
<p>Default is 0 if image.dtype is bool and 1 otherwise.</p>
</dd>
</dl>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.pad</span></code></a>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <em class="xref py py-obj">img_as_float</em>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>warped</strong><span class="classifier">double ndarray</span></dt><dd><p>The warped input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The input image is converted to a <em class="xref py py-obj">double</em> image.</p></li>
<li><p>In case of a <a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SimilarityTransform</span></code></a>, <a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineTransform</span></code></a> and
<a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a> and <em class="xref py py-obj">order</em> in [0, 3] this function uses the
underlying transformation matrix to warp the image with a much faster
routine.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">warp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
</pre></div>
</div>
<p>The following image warps are all equal but differ substantially in
execution time. The image is shifted to the bottom.</p>
<p>Use a geometric transform to warp an image (fast):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">SimilarityTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">tform</span><span class="p">)</span>
</pre></div>
</div>
<p>Use a callable (slow):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_down</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">shift_down</span><span class="p">)</span>
</pre></div>
</div>
<p>Use a transformation matrix to warp an image (fast):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">ProjectiveTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ProjectiveTransform</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="p">))</span>
</pre></div>
</div>
<p>You can also use the inverse of a geometric transformation (fast):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span>
</pre></div>
</div>
<p>For N-D images you can pass a coordinate array, that specifies the
coordinates in the input image for every element in the output image. E.g.
if you want to rescale a 3-D cube, you can do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cube_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">cube_shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Setup the coordinate array, that defines the scaling:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">cube_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords0</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coords0</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span><span class="p">])</span>
</pre></div>
</div>
<p>Assume that the cube contains spatial data, where the first array element
center is at coordinate (0.5, 0.5, 0.5) in real space, i.e. we have to
account for this extra offset when scaling the image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-warp">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code><a class="headerlink" href="#examples-using-skimage-transform-warp" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Demonstration of image registration using optical flow."><div class="figure align-default" id="id27">
<img alt="Registration using optical flow" src="../_images/sphx_glr_plot_opticalflow_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/registration/plot_opticalflow.html#sphx-glr-auto-examples-registration-plot-opticalflow-py"><span class="std std-ref">Registration using optical flow</span></a></span><a class="headerlink" href="#id27" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="warp-coords">
<h2>warp_coords<a class="headerlink" href="#warp-coords" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.warp_coords">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">warp_coords</code><span class="sig-paren">(</span><em class="sig-param">coord_map</em>, <em class="sig-param">shape</em>, <em class="sig-param">dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L560-L635"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.warp_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the source coordinates for the output of a 2-D image warp.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coord_map</strong><span class="classifier">callable like GeometricTransform.inverse</span></dt><dd><p>Return input coordinates for given output coordinates.
Coordinates are in the shape (P, 2), where P is the number
of coordinates and each element is a <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> pair.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple</span></dt><dd><p>Shape of output image <code class="docutils literal notranslate"><span class="pre">(rows,</span> <span class="pre">cols[,</span> <span class="pre">bands])</span></code>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">np.dtype or string</span></dt><dd><p>dtype for return value (sane choices: float32 or float64).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>coords</strong><span class="classifier">(ndim, rows, cols[, bands]) array of dtype <em class="xref py py-obj">dtype</em></span></dt><dd><p>Coordinates for <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.map_coordinates.html#scipy.ndimage.map_coordinates" title="(in SciPy v1.5.4)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.ndimage.map_coordinates</span></code></a>, that will yield
an image of shape (orows, ocols, bands) by drawing from source
points according to the <em class="xref py py-obj">coord_transform_fn</em>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is a lower-level routine that produces the source coordinates for 2-D
images used by <em class="xref py py-obj">warp()</em>.</p>
<p>It is provided separately from <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp</span></code></a> to give additional flexibility to
users who would like, for example, to re-use a particular coordinate
mapping, to use specific dtypes at various points along the the
image-warping process, or to implement different post-processing logic
than <a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp</span></code></a> performs after the call to <em class="xref py py-obj">ndi.map_coordinates</em>.</p>
<p class="rubric">Examples</p>
<p>Produce a coordinate map that shifts an image up and to the right:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">map_coordinates</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_up10_left20</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">warp_coords</span><span class="p">(</span><span class="n">shift_up10_left20</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped_image</span> <span class="o">=</span> <span class="n">map_coordinates</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="warp-polar">
<h2>warp_polar<a class="headerlink" href="#warp-polar" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.warp_polar">
<code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">warp_polar</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">center=None</em>, <em class="sig-param">*</em>, <em class="sig-param">radius=None</em>, <em class="sig-param">output_shape=None</em>, <em class="sig-param">scaling='linear'</em>, <em class="sig-param">multichannel=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_warps.py#L997-L1095"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.warp_polar" title="Permalink to this definition">¶</a></dt>
<dd><p>Remap image to polar or log-polar coordinates space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image. Only 2-D arrays are accepted by default. If
<em class="xref py py-obj">multichannel=True</em>, 3-D arrays are accepted and the last axis is
interpreted as multiple channels.</p>
</dd>
<dt><strong>center</strong><span class="classifier">tuple (row, col), optional</span></dt><dd><p>Point in image that represents the center of the transformation (i.e.,
the origin in cartesian space). Values can be of type <em class="xref py py-obj">float</em>.
If no value is given, the center is assumed to be the center point
of the image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>Radius of the circle that bounds the area to be transformed.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">tuple (row, col), optional</span></dt><dd></dd>
<dt><strong>scaling</strong><span class="classifier">{‘linear’, ‘log’}, optional</span></dt><dd><p>Specify whether the image warp is polar or log-polar. Defaults to
‘linear’.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the image is a 3-D array in which the third axis is to be
interpreted as multiple channels. If set to <em class="xref py py-obj">False</em> (default), only 2-D
arrays are accepted.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">keyword arguments</span></dt><dd><p>Passed to <em class="xref py py-obj">transform.warp</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>warped</strong><span class="classifier">ndarray</span></dt><dd><p>The polar or log-polar warped image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Perform a basic polar warp on a grayscale image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">warp_polar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">checkerboard</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p>Perform a log-polar warp on a grayscale image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Perform a log-polar warp on a grayscale image while specifying center,
radius, and output shape:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span> <span class="n">radius</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">output_shape</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Perform a log-polar warp on a color image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">multichannel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="affinetransform">
<h2><a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a><a class="headerlink" href="#affinetransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.AffineTransform">
<em class="property">class </em><code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">AffineTransform</code><span class="sig-paren">(</span><em class="sig-param">matrix=None</em>, <em class="sig-param">scale=None</em>, <em class="sig-param">rotation=None</em>, <em class="sig-param">shear=None</em>, <em class="sig-param">translation=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L746-L844"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.AffineTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.ProjectiveTransform</span></code></p>
<p>2D affine transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">sx</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">sy</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">rotation</span> <span class="o">+</span> <span class="n">shear</span><span class="p">)</span> <span class="o">+</span> <span class="n">a2</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">sx</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">sy</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">rotation</span> <span class="o">+</span> <span class="n">shear</span><span class="p">)</span> <span class="o">+</span> <span class="n">b2</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">sx</span></code> and <code class="docutils literal notranslate"><span class="pre">sy</span></code> are scale factors in the x and y directions,
and the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">a1</span>  <span class="n">a2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">b1</span>  <span class="n">b2</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>matrix</strong><span class="classifier">(3, 3) array, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">{s as float or (sx, sy) as array, list or tuple}, optional</span></dt><dd><p>Scale factor(s). If a single value, it will be assigned to both
sx and sy.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17: </span>Added support for supplying a single scalar value.</p>
</div>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Rotation angle in counter-clockwise direction as radians.</p>
</dd>
<dt><strong>shear</strong><span class="classifier">float, optional</span></dt><dd><p>Shear angle in counter-clockwise direction as radians.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(tx, ty) as array, list or tuple, optional</span></dt><dd><p>Translation parameters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(3, 3) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="skimage.transform.AffineTransform.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">matrix=None</em>, <em class="sig-param">scale=None</em>, <em class="sig-param">rotation=None</em>, <em class="sig-param">shear=None</em>, <em class="sig-param">translation=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L790-L825"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.AffineTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.AffineTransform.rotation">
<em class="property">property </em><code class="sig-name descname">rotation</code><a class="headerlink" href="#skimage.transform.AffineTransform.rotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.AffineTransform.scale">
<em class="property">property </em><code class="sig-name descname">scale</code><a class="headerlink" href="#skimage.transform.AffineTransform.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.AffineTransform.shear">
<em class="property">property </em><code class="sig-name descname">shear</code><a class="headerlink" href="#skimage.transform.AffineTransform.shear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.AffineTransform.translation">
<em class="property">property </em><code class="sig-name descname">translation</code><a class="headerlink" href="#skimage.transform.AffineTransform.translation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="essentialmatrixtransform">
<h2><a class="reference internal" href="#skimage.transform.EssentialMatrixTransform" title="skimage.transform.EssentialMatrixTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">EssentialMatrixTransform</span></code></a><a class="headerlink" href="#essentialmatrixtransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.EssentialMatrixTransform">
<em class="property">class </em><code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">EssentialMatrixTransform</code><span class="sig-paren">(</span><em class="sig-param">rotation=None</em>, <em class="sig-param">translation=None</em>, <em class="sig-param">matrix=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L399-L494"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.EssentialMatrixTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.FundamentalMatrixTransform</span></code></p>
<p>Essential matrix transformation.</p>
<p>The essential matrix relates corresponding points between a pair of
calibrated images. The matrix transforms normalized, homogeneous image
points in one image to epipolar lines in the other image.</p>
<p>The essential matrix is only defined for a pair of moving images capturing a
non-planar scene. In the case of pure rotation or planar scenes, the
homography describes the geometric relation between two images
(<a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a>). If the intrinsic calibration of the images is
unknown, the fundamental matrix describes the projective relation between
the two images (<a class="reference internal" href="#skimage.transform.FundamentalMatrixTransform" title="skimage.transform.FundamentalMatrixTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FundamentalMatrixTransform</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rotation</strong><span class="classifier">(3, 3) array, optional</span></dt><dd><p>Rotation matrix of the relative camera motion.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(3, 1) array, optional</span></dt><dd><p>Translation vector of the relative camera motion. The vector must
have unit length.</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">(3, 3) array, optional</span></dt><dd><p>Essential matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r2fbde33858f1-1"><span class="brackets">1</span></dt>
<dd><p>Hartley, Richard, and Andrew Zisserman. Multiple view geometry in
computer vision. Cambridge university press, 2003.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(3, 3) array</span></dt><dd><p>Essential matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="skimage.transform.EssentialMatrixTransform.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">rotation=None</em>, <em class="sig-param">translation=None</em>, <em class="sig-param">matrix=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L435-L458"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.EssentialMatrixTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.EssentialMatrixTransform.estimate">
<code class="sig-name descname">estimate</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L460-L494"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.EssentialMatrixTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate essential matrix using 8-point algorithm.</p>
<p>The 8-point algorithm requires at least 8 corresponding point pairs for
a well-conditioned solution, otherwise the over-determined solution is
estimated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="euclideantransform">
<h2><a class="reference internal" href="#skimage.transform.EuclideanTransform" title="skimage.transform.EuclideanTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">EuclideanTransform</span></code></a><a class="headerlink" href="#euclideantransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.EuclideanTransform">
<em class="property">class </em><code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">EuclideanTransform</code><span class="sig-paren">(</span><em class="sig-param">matrix=None</em>, <em class="sig-param">rotation=None</em>, <em class="sig-param">translation=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L981-L1077"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.EuclideanTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.ProjectiveTransform</span></code></p>
<p>2D Euclidean transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">a1</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span>
</pre></div>
</div>
<p>where the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">b0</span>  <span class="n">a1</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">a0</span>  <span class="n">b1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>The Euclidean transformation is a rigid transformation with rotation and
translation parameters. The similarity transformation extends the Euclidean
transformation with a single scaling factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(3, 3) array, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Rotation angle in counter-clockwise direction as radians.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(tx, ty) as array, list or tuple, optional</span></dt><dd><p>x, y translation parameters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(3, 3) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="skimage.transform.EuclideanTransform.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">matrix=None</em>, <em class="sig-param">rotation=None</em>, <em class="sig-param">translation=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1018-L1043"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.EuclideanTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.EuclideanTransform.estimate">
<code class="sig-name descname">estimate</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1045-L1069"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.EuclideanTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.EuclideanTransform.rotation">
<em class="property">property </em><code class="sig-name descname">rotation</code><a class="headerlink" href="#skimage.transform.EuclideanTransform.rotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.EuclideanTransform.translation">
<em class="property">property </em><code class="sig-name descname">translation</code><a class="headerlink" href="#skimage.transform.EuclideanTransform.translation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="fundamentalmatrixtransform">
<h2><a class="reference internal" href="#skimage.transform.FundamentalMatrixTransform" title="skimage.transform.FundamentalMatrixTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">FundamentalMatrixTransform</span></code></a><a class="headerlink" href="#fundamentalmatrixtransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.FundamentalMatrixTransform">
<em class="property">class </em><code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">FundamentalMatrixTransform</code><span class="sig-paren">(</span><em class="sig-param">matrix=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L211-L396"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.GeometricTransform</span></code></p>
<p>Fundamental matrix transformation.</p>
<p>The fundamental matrix relates corresponding points between a pair of
uncalibrated images. The matrix transforms homogeneous image points in one
image to epipolar lines in the other image.</p>
<p>The fundamental matrix is only defined for a pair of moving images. In the
case of pure rotation or planar scenes, the homography describes the
geometric relation between two images (<a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a>). If the
intrinsic calibration of the images is known, the essential matrix describes
the metric relation between the two images (<a class="reference internal" href="#skimage.transform.EssentialMatrixTransform" title="skimage.transform.EssentialMatrixTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EssentialMatrixTransform</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(3, 3) array, optional</span></dt><dd><p>Fundamental matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r725e3a484348-1"><span class="brackets">1</span></dt>
<dd><p>Hartley, Richard, and Andrew Zisserman. Multiple view geometry in
computer vision. Cambridge university press, 2003.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(3, 3) array</span></dt><dd><p>Fundamental matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="skimage.transform.FundamentalMatrixTransform.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">matrix=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L241-L247"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.FundamentalMatrixTransform.estimate">
<code class="sig-name descname">estimate</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L335-L367"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate fundamental matrix using 8-point algorithm.</p>
<p>The 8-point algorithm requires at least 8 corresponding point pairs for
a well-conditioned solution, otherwise the over-determined solution is
estimated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.FundamentalMatrixTransform.inverse">
<code class="sig-name descname">inverse</code><span class="sig-paren">(</span><em class="sig-param">coords</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L266-L281"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 3) array</span></dt><dd><p>Epipolar lines in the source image.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.FundamentalMatrixTransform.residuals">
<code class="sig-name descname">residuals</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L369-L396"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Sampson distance.</p>
<p>The Sampson distance is the first approximation to the geometric error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N, ) array</span></dt><dd><p>Sampson distance.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="piecewiseaffinetransform">
<h2><a class="reference internal" href="#skimage.transform.PiecewiseAffineTransform" title="skimage.transform.PiecewiseAffineTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseAffineTransform</span></code></a><a class="headerlink" href="#piecewiseaffinetransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.PiecewiseAffineTransform">
<em class="property">class </em><code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">PiecewiseAffineTransform</code><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L847-L978"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.GeometricTransform</span></code></p>
<p>2D piecewise affine transformation.</p>
<p>Control points are used to define the mapping. The transform is based on
a Delaunay triangulation of the points to form a mesh. Each triangle is
used to find a local affine transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affines</strong><span class="classifier">list of AffineTransform objects</span></dt><dd><p>Affine transformations for each triangle in the mesh.</p>
</dd>
<dt><strong>inverse_affines</strong><span class="classifier">list of AffineTransform objects</span></dt><dd><p>Inverse affine transformations for each triangle in the mesh.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="skimage.transform.PiecewiseAffineTransform.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L863-L867"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.PiecewiseAffineTransform.estimate">
<code class="sig-name descname">estimate</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L869-L908"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.PiecewiseAffineTransform.inverse">
<code class="sig-name descname">inverse</code><span class="sig-paren">(</span><em class="sig-param">coords</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L945-L978"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<p>Coordinates outside of the mesh will be set to <em class="xref py py-obj">- 1</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Transformed coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="polynomialtransform">
<h2><a class="reference internal" href="#skimage.transform.PolynomialTransform" title="skimage.transform.PolynomialTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolynomialTransform</span></code></a><a class="headerlink" href="#polynomialtransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.PolynomialTransform">
<em class="property">class </em><code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">PolynomialTransform</code><span class="sig-paren">(</span><em class="sig-param">params=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1182-L1327"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.GeometricTransform</span></code></p>
<p>2D polynomial transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
<span class="n">Y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(2, N) array, optional</span></dt><dd><p>Polynomial coefficients where <em class="xref py py-obj">N * 2 = (order + 1) * (order + 2)</em>. So,
a_ji is defined in <em class="xref py py-obj">params[0, :]</em> and b_ji in <em class="xref py py-obj">params[1, :]</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(2, N) array</span></dt><dd><p>Polynomial coefficients where <em class="xref py py-obj">N * 2 = (order + 1) * (order + 2)</em>. So,
a_ji is defined in <em class="xref py py-obj">params[0, :]</em> and b_ji in <em class="xref py py-obj">params[1, :]</em>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="skimage.transform.PolynomialTransform.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">params=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1204-L1210"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.PolynomialTransform.estimate">
<code class="sig-name descname">estimate</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em>, <em class="sig-param">order=2</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1212-L1290"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
<span class="n">Y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span> <span class="n">x</span> <span class="n">y</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">...</span> <span class="mi">0</span> <span class="o">...</span>             <span class="mi">0</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="o">...</span>                 <span class="mi">0</span> <span class="mi">1</span> <span class="n">x</span> <span class="n">y</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a00</span> <span class="n">a10</span> <span class="n">a11</span> <span class="n">a20</span> <span class="n">a21</span> <span class="n">a22</span> <span class="o">...</span> <span class="n">ann</span>
       <span class="n">b00</span> <span class="n">b10</span> <span class="n">b11</span> <span class="n">b20</span> <span class="n">b21</span> <span class="n">b22</span> <span class="o">...</span> <span class="n">bnn</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Polynomial order (number of coefficients is order + 1).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.PolynomialTransform.inverse">
<code class="sig-name descname">inverse</code><span class="sig-paren">(</span><em class="sig-param">coords</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1322-L1327"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="projectivetransform">
<h2><a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a><a class="headerlink" href="#projectivetransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.ProjectiveTransform">
<em class="property">class </em><code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">ProjectiveTransform</code><span class="sig-paren">(</span><em class="sig-param">matrix=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L497-L743"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.GeometricTransform</span></code></p>
<p>Projective transformation.</p>
<p>Apply a projective transformation (homography) on coordinates.</p>
<p>For each homogeneous coordinate <span class="math notranslate nohighlight">\(\mathbf{x} = [x, y, 1]^T\)</span>, its
target position is calculated by multiplying with the given matrix,
<span class="math notranslate nohighlight">\(H\)</span>, to give <span class="math notranslate nohighlight">\(H \mathbf{x}\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">c0</span> <span class="n">c1</span> <span class="mi">1</span> <span class="p">]]</span><span class="o">.</span>
</pre></div>
</div>
<p>E.g., to rotate by theta degrees clockwise, the matrix should be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>  <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>            <span class="mi">0</span>         <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>or, to translate x by 10 and y by 20:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">10</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">20</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">]]</span><span class="o">.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(3, 3) array, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(3, 3) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="skimage.transform.ProjectiveTransform.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">matrix=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L536-L542"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.ProjectiveTransform.estimate">
<code class="sig-name descname">estimate</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L596-L703"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">c0</span> <span class="n">c1</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<p>In case of the affine transformation the coefficients c0 and c1 are 0.
Thus the system of equations is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.ProjectiveTransform.inverse">
<code class="sig-name descname">inverse</code><span class="sig-paren">(</span><em class="sig-param">coords</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L580-L594"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="similaritytransform">
<h2><a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimilarityTransform</span></code></a><a class="headerlink" href="#similaritytransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.SimilarityTransform">
<em class="property">class </em><code class="sig-prename descclassname">skimage.transform.</code><code class="sig-name descname">SimilarityTransform</code><span class="sig-paren">(</span><em class="sig-param">matrix=None</em>, <em class="sig-param">scale=None</em>, <em class="sig-param">rotation=None</em>, <em class="sig-param">translation=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1080-L1179"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.SimilarityTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.EuclideanTransform</span></code></p>
<p>2D similarity transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">a1</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">s</span></code> is a scale factor and the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">b0</span>  <span class="n">a1</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">a0</span>  <span class="n">b1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>The similarity transformation extends the Euclidean transformation with a
single scaling factor in addition to the rotation and translation
parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(3, 3) array, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">float, optional</span></dt><dd><p>Scale factor.</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Rotation angle in counter-clockwise direction as radians.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(tx, ty) as array, list or tuple, optional</span></dt><dd><p>x, y translation parameters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(3, 3) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="skimage.transform.SimilarityTransform.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">matrix=None</em>, <em class="sig-param">scale=None</em>, <em class="sig-param">rotation=None</em>, <em class="sig-param">translation=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1119-L1148"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.SimilarityTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.SimilarityTransform.estimate">
<code class="sig-name descname">estimate</code><span class="sig-paren">(</span><em class="sig-param">src</em>, <em class="sig-param">dst</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/transform/_geometric.py#L1150-L1174"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.SimilarityTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.SimilarityTransform.scale">
<em class="property">property </em><code class="sig-name descname">scale</code><a class="headerlink" href="#skimage.transform.SimilarityTransform.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>


        </div>
    </div>
    <div class="forum link" role="contentinfo">
	 
    </div>
    <div class="well footer" role="contentinfo">
        <small>
            &copy; Copyright the scikit-image development team.
            Created using <a href="https://getbootstrap.com/">Bootstrap</a> and <a href="https://www.sphinx-doc.org/">Sphinx</a>.
        </small>
    </div>
</body>
</html>
