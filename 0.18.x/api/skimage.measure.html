
<!DOCTYPE html>
<html lang="en">
<head>
        <title>Module: measure &mdash; skimage v0.18.0 docs</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../_static/css/custom.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
        <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
        <link rel="stylesheet" href="../_static/gallery-binder.css" type="text/css" />
        <link rel="stylesheet" href="../_static/gallery-dataframe.css" type="text/css" />
    
    <script src="https://code.jquery.com/jquery-latest.js"></script>
    <script src="../_static/js/bootstrap.min.js"></script>
    <script src="../_static/js/togglebutton.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.18.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
        <link rel="index" title="Index" href="../genindex.html" />
        <link rel="search" title="Search" href="../search.html" />
        <link rel="top" title="skimage v0.18.0 docs" href="../index.html" />
        <link rel="up" title="API Reference for skimage 0.18.0" href="api.html" />
        <link rel="next" title="Module: metrics" href="skimage.metrics.html" />
        <link rel="prev" title="Module: io" href="skimage.io.html" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="shortcut icon" href="../_static/favicon.ico">
    <!-- Plausible analytics -->
    <script async defer data-domain="scikit-image.org" src="https://plausible.io/js/plausible.outbound-links.js"></script>
</head>
<body class="container">
    <a href="https://scikit-image.org" class="logo"><img src="../_static/img/logo.png" alt=""></a>
    <div class="clearfix"></div>
    <div class="navbar">
        <div class="navbar-inner">
            <ul class="nav">
                <li><a href="/docs/stable/install.html">Installation</a></li>
<li><a href="../auto_examples/index.html">Gallery</a></li>
<li><a href="../index.html">Documentation</a></li>
<li><a href="/community_guidelines.html">Community</a></li>

<li><a href="https://github.com/scikit-image/scikit-image">
    <img src="../_static/GitHub-Mark-32px.png"
        style="height: 15px; width: 15px;
               display: inline; float: none;
               padding-bottom: 3px;">
    Source</a>
</li>
            </ul>
        </div>
    </div>
    <div class="row">
        <div class="span3"><div style="padding-bottom: 3em">
  <form class="navbar-form pull-right" action="../search.html" method="get">
    <input type="text" class="search span3" name="q" placeholder="Search documentation ...">
    <input type="hidden" name="check_keywords" value="yes" >
    <input type="hidden" name="area" value="default" >
  </form>
</div><!-- 
        <h4 class="sidebar-box-heading">Contents</h4>
        <div class="well sidebar-box toc">
            <ul class="nav nav-list">
<li><a class="reference internal" href="#">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">measure</span></code></a><ul class="nav nav-list">
<li><a class="reference internal" href="#approximate-polygon">approximate_polygon</a></li>
<li><a class="reference internal" href="#block-reduce">block_reduce</a></li>
<li><a class="reference internal" href="#euler-number">euler_number</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-measure-euler-number">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.measure.euler_number</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#find-contours">find_contours</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-measure-find-contours">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.measure.find_contours</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#grid-points-in-poly">grid_points_in_poly</a></li>
<li><a class="reference internal" href="#inertia-tensor">inertia_tensor</a></li>
<li><a class="reference internal" href="#inertia-tensor-eigvals">inertia_tensor_eigvals</a></li>
<li><a class="reference internal" href="#label">label</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-measure-label">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.measure.label</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#marching-cubes">marching_cubes</a></li>
<li><a class="reference internal" href="#marching-cubes-classic">marching_cubes_classic</a></li>
<li><a class="reference internal" href="#marching-cubes-lewiner">marching_cubes_lewiner</a></li>
<li><a class="reference internal" href="#mesh-surface-area">mesh_surface_area</a></li>
<li><a class="reference internal" href="#moments">moments</a></li>
<li><a class="reference internal" href="#moments-central">moments_central</a></li>
<li><a class="reference internal" href="#moments-coords">moments_coords</a></li>
<li><a class="reference internal" href="#moments-coords-central">moments_coords_central</a></li>
<li><a class="reference internal" href="#moments-hu">moments_hu</a></li>
<li><a class="reference internal" href="#moments-normalized">moments_normalized</a></li>
<li><a class="reference internal" href="#perimeter">perimeter</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-measure-perimeter">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.measure.perimeter</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#perimeter-crofton">perimeter_crofton</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-measure-perimeter-crofton">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.measure.perimeter_crofton</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#points-in-poly">points_in_poly</a></li>
<li><a class="reference internal" href="#profile-line">profile_line</a></li>
<li><a class="reference internal" href="#ransac">ransac</a></li>
<li><a class="reference internal" href="#regionprops">regionprops</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-measure-regionprops">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.measure.regionprops</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#regionprops-table">regionprops_table</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-measure-regionprops-table">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.measure.regionprops_table</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#shannon-entropy">shannon_entropy</a></li>
<li><a class="reference internal" href="#subdivide-polygon">subdivide_polygon</a></li>
<li><a class="reference internal" href="#circlemodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CircleModel</span></code></a></li>
<li><a class="reference internal" href="#ellipsemodel"><code class="xref py py-class docutils literal notranslate"><span class="pre">EllipseModel</span></code></a></li>
<li><a class="reference internal" href="#linemodelnd"><code class="xref py py-class docutils literal notranslate"><span class="pre">LineModelND</span></code></a></li>
</ul>
</li>
</ul>

        </div>


 --><div class="well">
    <strong>Docs for 0.18.0<br></strong>

    <a id="other">All versions</a>

    <ul id="versionList" style="display: none;">
        <script src="../../dev/_static/docversions.js"></script>
        <script type="text/javascript">
            insert_version_links();
        </script>
    </ul>

 </div>

<script type="text/javascript">
	$("#other").click(function() {
		$("#versionList").toggle();
	});
</script>
        </div>
        <div class="span9" class="body" role="main">
            
  <div class="section" id="module-skimage.measure">
<span id="module-measure"></span><h1>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">measure</span></code><a class="headerlink" href="#module-skimage.measure" title="Permalink to this headline">¶</a></h1>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.approximate_polygon" title="skimage.measure.approximate_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.approximate_polygon</span></code></a>(coords, …)</p></td>
<td><p>Approximate a polygonal chain with the specified tolerance.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.block_reduce" title="skimage.measure.block_reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.block_reduce</span></code></a>(image, block_size)</p></td>
<td><p>Downsample image by applying function <em class="xref py py-obj">func</em> to local blocks.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.euler_number" title="skimage.measure.euler_number"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.euler_number</span></code></a>(image[, …])</p></td>
<td><p>Calculate the Euler characteristic in binary image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.find_contours" title="skimage.measure.find_contours"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.find_contours</span></code></a>(image[, …])</p></td>
<td><p>Find iso-valued contours in a 2D array for a given level value.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.grid_points_in_poly" title="skimage.measure.grid_points_in_poly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.grid_points_in_poly</span></code></a>(shape, verts)</p></td>
<td><p>Test whether points on a specified grid are inside a polygon.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.inertia_tensor" title="skimage.measure.inertia_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.inertia_tensor</span></code></a>(image[, mu])</p></td>
<td><p>Compute the inertia tensor of the input image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.inertia_tensor_eigvals" title="skimage.measure.inertia_tensor_eigvals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.inertia_tensor_eigvals</span></code></a>(image)</p></td>
<td><p>Compute the eigenvalues of the inertia tensor of the image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.label" title="skimage.measure.label"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.label</span></code></a>(input[, background, …])</p></td>
<td><p>Label connected regions of an integer array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.marching_cubes</span></code></a>(volume[, …])</p></td>
<td><p>Marching cubes algorithm to find surfaces in 3d volumetric data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.marching_cubes_classic" title="skimage.measure.marching_cubes_classic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.marching_cubes_classic</span></code></a>(volume)</p></td>
<td><p>Classic marching cubes algorithm to find surfaces in 3d volumetric data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.marching_cubes_lewiner" title="skimage.measure.marching_cubes_lewiner"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.marching_cubes_lewiner</span></code></a>(volume)</p></td>
<td><p>Lewiner marching cubes algorithm to find surfaces in 3d volumetric data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.mesh_surface_area</span></code></a>(verts, faces)</p></td>
<td><p>Compute surface area, given vertices &amp; triangular faces</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.moments" title="skimage.measure.moments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.moments</span></code></a>(image[, order])</p></td>
<td><p>Calculate all raw image moments up to a certain order.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.moments_central" title="skimage.measure.moments_central"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.moments_central</span></code></a>(image[, …])</p></td>
<td><p>Calculate all central image moments up to a certain order.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.moments_coords" title="skimage.measure.moments_coords"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.moments_coords</span></code></a>(coords[, order])</p></td>
<td><p>Calculate all raw image moments up to a certain order.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.moments_coords_central" title="skimage.measure.moments_coords_central"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.moments_coords_central</span></code></a>(coords)</p></td>
<td><p>Calculate all central image moments up to a certain order.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.moments_hu" title="skimage.measure.moments_hu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.moments_hu</span></code></a>(nu)</p></td>
<td><p>Calculate Hu’s set of image moments (2D-only).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.moments_normalized" title="skimage.measure.moments_normalized"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.moments_normalized</span></code></a>(mu[, order])</p></td>
<td><p>Calculate all normalized central image moments up to a certain order.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.perimeter" title="skimage.measure.perimeter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.perimeter</span></code></a>(image[, neighbourhood])</p></td>
<td><p>Calculate total perimeter of all objects in binary image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.perimeter_crofton" title="skimage.measure.perimeter_crofton"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.perimeter_crofton</span></code></a>(image[, …])</p></td>
<td><p>Calculate total Crofton perimeter of all objects in binary image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.points_in_poly" title="skimage.measure.points_in_poly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.points_in_poly</span></code></a>(points, verts)</p></td>
<td><p>Test whether points lie inside a polygon.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.profile_line" title="skimage.measure.profile_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.profile_line</span></code></a>(image, src, dst)</p></td>
<td><p>Return the intensity profile of an image measured along a scan line.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.ransac" title="skimage.measure.ransac"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.ransac</span></code></a>(data, model_class, …)</p></td>
<td><p>Fit a model to data with the RANSAC (random sample consensus) algorithm.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.regionprops</span></code></a>(label_image[, …])</p></td>
<td><p>Measure properties of labeled image regions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.regionprops_table" title="skimage.measure.regionprops_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.regionprops_table</span></code></a>(label_image)</p></td>
<td><p>Compute image properties and return them as a pandas-compatible table.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.shannon_entropy" title="skimage.measure.shannon_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.shannon_entropy</span></code></a>(image[, base])</p></td>
<td><p>Calculate the Shannon entropy of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.subdivide_polygon" title="skimage.measure.subdivide_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.subdivide_polygon</span></code></a>(coords[, …])</p></td>
<td><p>Subdivision of polygonal curves using B-Splines.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.CircleModel" title="skimage.measure.CircleModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.CircleModel</span></code></a>()</p></td>
<td><p>Total least squares estimator for 2D circles.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.EllipseModel" title="skimage.measure.EllipseModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.EllipseModel</span></code></a>()</p></td>
<td><p>Total least squares estimator for 2D ellipses.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.LineModelND" title="skimage.measure.LineModelND"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.LineModelND</span></code></a>()</p></td>
<td><p>Total least squares estimator for N-dimensional lines.</p></td>
</tr>
</tbody>
</table>
<div class="section" id="approximate-polygon">
<h2>approximate_polygon<a class="headerlink" href="#approximate-polygon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.approximate_polygon">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">approximate_polygon</code><span class="sig-paren">(</span><em class="sig-param">coords</em>, <em class="sig-param">tolerance</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_polygon.py#L5-L92"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.approximate_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate a polygonal chain with the specified tolerance.</p>
<p>It is based on the Douglas-Peucker algorithm.</p>
<p>Note that the approximated polygon is always within the convex hull of the
original polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Coordinate array.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Maximum distance from original points of polygon to approximated
polygonal chain. If tolerance is 0, the original coordinate array
is returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(M, 2) array</span></dt><dd><p>Approximated polygonal chain where M &lt;= N.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb46d085928c9-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm">https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm</a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="block-reduce">
<h2>block_reduce<a class="headerlink" href="#block-reduce" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.block_reduce">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">block_reduce</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">block_size</em>, <em class="sig-param">func=&lt;function sum&gt;</em>, <em class="sig-param">cval=0</em>, <em class="sig-param">func_kwargs=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/block.py#L5-L87"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.block_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Downsample image by applying function <em class="xref py py-obj">func</em> to local blocks.</p>
<p>This function is useful for max and mean pooling, for example.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>N-dimensional input image.</p>
</dd>
<dt><strong>block_size</strong><span class="classifier">array_like</span></dt><dd><p>Array containing down-sampling integer factor along each axis.</p>
</dd>
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>Function object which is used to calculate the return value for each
local block. This function must implement an <code class="docutils literal notranslate"><span class="pre">axis</span></code> parameter.
Primary functions are <code class="docutils literal notranslate"><span class="pre">numpy.sum</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.min</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.max</span></code>,
<code class="docutils literal notranslate"><span class="pre">numpy.mean</span></code> and <code class="docutils literal notranslate"><span class="pre">numpy.median</span></code>.  See also <em class="xref py py-obj">func_kwargs</em>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float</span></dt><dd><p>Constant padding value if image is not perfectly divisible by the
block size.</p>
</dd>
<dt><strong>func_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Keyword arguments passed to <em class="xref py py-obj">func</em>. Notably useful for passing dtype
argument to <code class="docutils literal notranslate"><span class="pre">np.mean</span></code>. Takes dictionary of inputs, e.g.:
<code class="docutils literal notranslate"><span class="pre">func_kwargs={'dtype':</span> <span class="pre">np.float16})</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Down-sampled image with same number of dimensions as input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">block_reduce</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> 
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]],</span>
<span class="go">       [[12, 13, 14, 15],</span>
<span class="go">        [16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]],</span>
<span class="go">       [[24, 25, 26, 27],</span>
<span class="go">        [28, 29, 30, 31],</span>
<span class="go">        [32, 33, 34, 35]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_reduce</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
<span class="go">array([[[16., 17., 18., 19.]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max1</span> <span class="o">=</span> <span class="n">block_reduce</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max1</span> 
<span class="go">array([[[11]],</span>
<span class="go">       [[23]],</span>
<span class="go">       [[35]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max2</span> <span class="o">=</span> <span class="n">block_reduce</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max2</span> 
<span class="go">array([[[27],</span>
<span class="go">        [31],</span>
<span class="go">        [35]]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="euler-number">
<h2>euler_number<a class="headerlink" href="#euler-number" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.euler_number">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">euler_number</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">connectivity=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_regionprops_utils.py#L58-L183"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.euler_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Euler characteristic in binary image.</p>
<p>For 2D objects, the Euler number is the number of objects minus the number
of holes. For 3D objects, the Euler number is obtained as the number of
objects plus the number of holes, minus the number of tunnels, or loops.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image: (N, M) ndarray or (N, M, D) ndarray.</strong></dt><dd><p>2D or 3D images.
If image is not binary, all values strictly greater than zero
are considered as the object.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of orthogonal hops to consider a pixel/voxel
as a neighbor.
Accepted values are ranging from  1 to input.ndim. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a full
connectivity of <code class="docutils literal notranslate"><span class="pre">input.ndim</span></code> is used.
4 or 8 neighborhoods are defined for 2D images (connectivity 1 and 2,
respectively).
6 or 26 neighborhoods are defined for 3D images, (connectivity 1 and 3,
respectively). Connectivity 2 is not defined.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>euler_number</strong><span class="classifier">int</span></dt><dd><p>Euler characteristic of the set of all objects in the image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Euler characteristic is an integer number that describes the
topology of the set of all objects in the input image. If object is
4-connected, then background is 8-connected, and conversely.</p>
<p>The computation of the Euler characteristic is based on an integral
geometry formula in discretized space. In practice, a neighbourhood
configuration is constructed, and a LUT is applied for each
configuration. The coefficients used are the ones of Ohser et al.</p>
<p>It can be useful to compute the Euler characteristic for several
connectivities. A large relative difference between results
for different connectivities suggests that the image resolution
(with respect to the size of objects and holes) is too low.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0d660f9fa30f-1"><span class="brackets">1</span></dt>
<dd><p>S. Rivollier. Analyse d’image geometrique et morphometrique par
diagrammes de forme et voisinages adaptatifs generaux. PhD thesis,
2010. Ecole Nationale Superieure des Mines de Saint-Etienne.
<a class="reference external" href="https://tel.archives-ouvertes.fr/tel-00560838">https://tel.archives-ouvertes.fr/tel-00560838</a></p>
</dd>
<dt class="label" id="r0d660f9fa30f-2"><span class="brackets">2</span></dt>
<dd><p>Ohser J., Nagel W., Schladitz K. (2002) The Euler Number of
Discretized Sets - On the Choice of Adjacency in Homogeneous
Lattices. In: Mecke K., Stoyan D. (eds) Morphology of Condensed
Matter. Lecture Notes in Physics, vol 600. Springer, Berlin,
Heidelberg.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAMPLE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAMPLE</span><span class="p">[</span><span class="mi">40</span><span class="p">:</span><span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">:</span><span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">:</span><span class="mi">60</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">euler_number</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">)</span> 
<span class="go">1...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAMPLE</span><span class="p">[</span><span class="mi">45</span><span class="p">:</span><span class="mi">55</span><span class="p">,</span><span class="mi">45</span><span class="p">:</span><span class="mi">55</span><span class="p">,</span><span class="mi">45</span><span class="p">:</span><span class="mi">55</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">euler_number</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">)</span> 
<span class="go">2...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAMPLE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">euler_number</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">)</span>  <span class="c1"># doctest:</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">euler_number</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># doctest:</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-measure-euler-number">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.measure.euler_number</span></code><a class="headerlink" href="#examples-using-skimage-measure-euler-number" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows an illustration of the computation of the Euler number [1]_ in 2D and 3D obj..."><div class="figure align-default" id="id52">
<img alt="Euler number" src="../_images/sphx_glr_plot_euler_number_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_euler_number.html#sphx-glr-auto-examples-segmentation-plot-euler-number-py"><span class="std std-ref">Euler number</span></a></span><a class="headerlink" href="#id52" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="find-contours">
<h2>find_contours<a class="headerlink" href="#find-contours" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.find_contours">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">find_contours</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">level=None</em>, <em class="sig-param">fully_connected='low'</em>, <em class="sig-param">positive_orientation='low'</em>, <em class="sig-param">*</em>, <em class="sig-param">mask=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_find_contours.py#L11-L154"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.find_contours" title="Permalink to this definition">¶</a></dt>
<dd><p>Find iso-valued contours in a 2D array for a given level value.</p>
<p>Uses the “marching squares” method to compute a the iso-valued contours of
the input 2D array for a particular level value. Array values are linearly
interpolated to provide better precision for the output contours.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">2D ndarray of double</span></dt><dd><p>Input image in which to find contours.</p>
</dd>
<dt><strong>level</strong><span class="classifier">float, optional</span></dt><dd><p>Value along which to find contours in the array. By default, the level
is set to (max(image) + min(image)) / 2</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18: </span>This parameter is now optional.</p>
</div>
</dd>
<dt><strong>fully_connected</strong><span class="classifier">str, {‘low’, ‘high’}</span></dt><dd><p>Indicates whether array elements below the given level value are to be
considered fully-connected (and hence elements above the value will
only be face connected), or vice-versa. (See notes below for details.)</p>
</dd>
<dt><strong>positive_orientation</strong><span class="classifier">str, {‘low’, ‘high’}</span></dt><dd><p>Indicates whether the output contours will produce positively-oriented
polygons around islands of low- or high-valued elements. If ‘low’ then
contours will wind counter- clockwise around elements below the
iso-value. Alternately, this means that low-valued elements are always
on the left of the contour. (See below for details.)</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2D ndarray of bool, or None</span></dt><dd><p>A boolean mask, True where we want to draw contours.
Note that NaN values are always excluded from the considered region
(<code class="docutils literal notranslate"><span class="pre">mask</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> wherever <code class="docutils literal notranslate"><span class="pre">array</span></code> is <code class="docutils literal notranslate"><span class="pre">NaN</span></code>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>contours</strong><span class="classifier">list of (n,2)-ndarrays</span></dt><dd><p>Each contour is an ndarray of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">2)</span></code>,
consisting of n <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">column)</span></code> coordinates along the contour.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.marching_cubes</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The marching squares algorithm is a special case of the marching cubes
algorithm <a class="reference internal" href="#r8ed60f468bf9-1" id="id4">[1]</a>.  A simple explanation is available here:</p>
<p><a class="reference external" href="http://users.polytech.unice.fr/~lingrand/MarchingCubes/algo.html">http://users.polytech.unice.fr/~lingrand/MarchingCubes/algo.html</a></p>
<p>There is a single ambiguous case in the marching squares algorithm: when
a given <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">x</span> <span class="pre">2</span></code>-element square has two high-valued and two low-valued
elements, each pair diagonally adjacent. (Where high- and low-valued is
with respect to the contour value sought.) In this case, either the
high-valued elements can be ‘connected together’ via a thin isthmus that
separates the low-valued elements, or vice-versa. When elements are
connected together across a diagonal, they are considered ‘fully
connected’ (also known as ‘face+vertex-connected’ or ‘8-connected’). Only
high-valued or low-valued elements can be fully-connected, the other set
will be considered as ‘face-connected’ or ‘4-connected’. By default,
low-valued elements are considered fully-connected; this can be altered
with the ‘fully_connected’ parameter.</p>
<p>Output contours are not guaranteed to be closed: contours which intersect
the array edge or a masked-off region (either where mask is False or where
array is NaN) will be left open. All other contours will be closed. (The
closed-ness of a contours can be tested by checking whether the beginning
point is the same as the end point.)</p>
<p>Contours are oriented. By default, array values lower than the contour
value are to the left of the contour and values greater than the contour
value are to the right. This means that contours will wind
counter-clockwise (i.e. in ‘positive orientation’) around islands of
low-valued pixels. This behavior can be altered with the
‘positive_orientation’ parameter.</p>
<p>The order of the contours in the output list is determined by the position
of the smallest <code class="docutils literal notranslate"><span class="pre">x,y</span></code> (in lexicographical order) coordinate in the
contour.  This is a side-effect of how the input array is traversed, but
can be relied upon.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Array coordinates/values are assumed to refer to the <em>center</em> of the
array element. Take a simple example input: <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>. The interpolated
position of 0.5 in this array is midway between the 0-element (at
<code class="docutils literal notranslate"><span class="pre">x=0</span></code>) and the 1-element (at <code class="docutils literal notranslate"><span class="pre">x=1</span></code>), and thus would fall at
<code class="docutils literal notranslate"><span class="pre">x=0.5</span></code>.</p>
</div>
<p>This means that to find reasonable contours, it is best to find contours
midway between the expected “light” and “dark” values. In particular,
given a binarized array, <em>do not</em> choose to find contours at the low or
high value of the array. This will often yield degenerate contours,
especially around structures that are a single array element wide. Instead
choose a middle value, as above.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8ed60f468bf9-1"><span class="brackets"><a class="fn-backref" href="#id4">1</a></span></dt>
<dd><p>Lorensen, William and Harvey E. Cline. Marching Cubes: A High
Resolution 3D Surface Construction Algorithm. Computer Graphics
(SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170).
<a class="reference external" href="https://doi.org/10.1145/37401.37422">DOI:10.1145/37401.37422</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1., 0., 0.],</span>
<span class="go">       [0., 0., 0.],</span>
<span class="go">       [0., 0., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_contours</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">[array([[0. , 0.5],</span>
<span class="go">       [0.5, 0. ]])]</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-measure-find-contours">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.measure.find_contours</span></code><a class="headerlink" href="#examples-using-skimage-measure-find-contours" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="We use a marching squares method to find constant valued contours in an image. In skimage.measu..."><div class="figure align-default" id="id53">
<img alt="Contour finding" src="../_images/sphx_glr_plot_contours_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/edges/plot_contours.html#sphx-glr-auto-examples-edges-plot-contours-py"><span class="std std-ref">Contour finding</span></a></span><a class="headerlink" href="#id53" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima..."><div class="figure align-default" id="id54">
<img alt="Measure region properties" src="../_images/sphx_glr_plot_regionprops_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></span><a class="headerlink" href="#id54" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="grid-points-in-poly">
<h2>grid_points_in_poly<a class="headerlink" href="#grid-points-in-poly" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.grid_points_in_poly">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">grid_points_in_poly</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">verts</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/pnpoly.py#L4-L29"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.grid_points_in_poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether points on a specified grid are inside a polygon.</p>
<p>For each <code class="docutils literal notranslate"><span class="pre">(r,</span> <span class="pre">c)</span></code> coordinate on a grid, i.e. <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code>, <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1)</span></code> etc.,
test whether that point lies inside a polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">tuple (M, N)</span></dt><dd><p>Shape of the grid.</p>
</dd>
<dt><strong>verts</strong><span class="classifier">(V, 2) array</span></dt><dd><p>Specify the V vertices of the polygon, sorted either clockwise
or anti-clockwise. The first point may (but does not need to be)
duplicated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mask</strong><span class="classifier">(M, N) ndarray of bool</span></dt><dd><p>True where the grid falls inside the polygon.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.points_in_poly" title="skimage.measure.points_in_poly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">points_in_poly</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

</div>
<div class="section" id="inertia-tensor">
<h2>inertia_tensor<a class="headerlink" href="#inertia-tensor" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.inertia_tensor">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">inertia_tensor</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">mu=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L379-L428"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.inertia_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the inertia tensor of the input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array, optional</span></dt><dd><p>The pre-computed central moments of <code class="docutils literal notranslate"><span class="pre">image</span></code>. The inertia tensor
computation requires the central moments of the image. If an
application requires both the central moments and the inertia tensor
(for example, <a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.regionprops</span></code></a>), then it is more
efficient to pre-compute them and pass them to the inertia tensor
call.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>T</strong><span class="classifier">array, shape <code class="docutils literal notranslate"><span class="pre">(image.ndim,</span> <span class="pre">image.ndim)</span></code></span></dt><dd><p>The inertia tensor of the input image. <span class="math notranslate nohighlight">\(T_{i, j}\)</span> contains
the covariance of image intensity along axes <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rfbef8c192cf5-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Moment_of_inertia#Inertia_tensor">https://en.wikipedia.org/wiki/Moment_of_inertia#Inertia_tensor</a></p>
</dd>
<dt class="label" id="rfbef8c192cf5-2"><span class="brackets">2</span></dt>
<dd><p>Bernd Jähne. Spatio-Temporal Image Processing: Theory and
Scientific Applications. (Chapter 8: Tensor Methods) Springer, 1993.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="inertia-tensor-eigvals">
<h2>inertia_tensor_eigvals<a class="headerlink" href="#inertia-tensor-eigvals" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.inertia_tensor_eigvals">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">inertia_tensor_eigvals</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">mu=None</em>, <em class="sig-param">T=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L431-L469"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.inertia_tensor_eigvals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the eigenvalues of the inertia tensor of the image.</p>
<p>The inertia tensor measures covariance of the image intensity along
the image axes. (See <a class="reference internal" href="#skimage.measure.inertia_tensor" title="skimage.measure.inertia_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inertia_tensor</span></code></a>.) The relative magnitude of the
eigenvalues of the tensor is thus a measure of the elongation of a
(bright) object in the image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array, optional</span></dt><dd><p>The pre-computed central moments of <code class="docutils literal notranslate"><span class="pre">image</span></code>.</p>
</dd>
<dt><strong>T</strong><span class="classifier">array, shape <code class="docutils literal notranslate"><span class="pre">(image.ndim,</span> <span class="pre">image.ndim)</span></code></span></dt><dd><p>The pre-computed inertia tensor. If <code class="docutils literal notranslate"><span class="pre">T</span></code> is given, <code class="docutils literal notranslate"><span class="pre">mu</span></code> and
<code class="docutils literal notranslate"><span class="pre">image</span></code> are ignored.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>eigvals</strong><span class="classifier">list of float, length <code class="docutils literal notranslate"><span class="pre">image.ndim</span></code></span></dt><dd><p>The eigenvalues of the inertia tensor of <code class="docutils literal notranslate"><span class="pre">image</span></code>, in descending
order.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Computing the eigenvalues requires the inertia tensor of the input image.
This is much faster if the central moments (<code class="docutils literal notranslate"><span class="pre">mu</span></code>) are provided, or,
alternatively, one can provide the inertia tensor (<code class="docutils literal notranslate"><span class="pre">T</span></code>) directly.</p>
</dd></dl>

</div>
<div class="section" id="label">
<h2>label<a class="headerlink" href="#label" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.label">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">label</code><span class="sig-paren">(</span><em class="sig-param">input</em>, <em class="sig-param">background=None</em>, <em class="sig-param">return_num=False</em>, <em class="sig-param">connectivity=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_label.py#L32-L120"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Label connected regions of an integer array.</p>
<p>Two pixels are connected when they are neighbors and have the same value.
In 2D, they can be neighbors either in a 1- or 2-connected sense.
The value refers to the maximum number of orthogonal hops to consider a
pixel/voxel a neighbor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">-</span><span class="n">connectivity</span>     <span class="mi">2</span><span class="o">-</span><span class="n">connectivity</span>     <span class="n">diagonal</span> <span class="n">connection</span> <span class="n">close</span><span class="o">-</span><span class="n">up</span>

     <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>             <span class="p">[</span> <span class="p">]</span>
      <span class="o">|</span>               \  <span class="o">|</span>  <span class="o">/</span>                 <span class="o">|</span>  <span class="o">&lt;-</span> <span class="n">hop</span> <span class="mi">2</span>
<span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>      <span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>        <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>
      <span class="o">|</span>               <span class="o">/</span>  <span class="o">|</span>  \             <span class="n">hop</span> <span class="mi">1</span>
     <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input</strong><span class="classifier">ndarray of dtype int</span></dt><dd><p>Image to label.</p>
</dd>
<dt><strong>background</strong><span class="classifier">int, optional</span></dt><dd><p>Consider all pixels with this value as background pixels, and label
them as 0. By default, 0-valued pixels are considered as background
pixels.</p>
</dd>
<dt><strong>return_num</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to return the number of assigned labels.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of orthogonal hops to consider a pixel/voxel
as a neighbor.
Accepted values are ranging from  1 to input.ndim. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a full
connectivity of <code class="docutils literal notranslate"><span class="pre">input.ndim</span></code> is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">ndarray of dtype int</span></dt><dd><p>Labeled array, where all connected regions are assigned the
same integer value.</p>
</dd>
<dt><strong>num</strong><span class="classifier">int, optional</span></dt><dd><p>Number of labels, which equals the maximum label index and is only
returned if return_num is <em class="xref py py-obj">True</em>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regionprops</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.measure.regionprops_table" title="skimage.measure.regionprops_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regionprops_table</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4c017a27ed0c-1"><span class="brackets">1</span></dt>
<dd><p>Christophe Fiorio and Jens Gustedt, “Two linear time Union-Find
strategies for image processing”, Theoretical Computer Science
154 (1996), pp. 165-181.</p>
</dd>
<dt class="label" id="r4c017a27ed0c-2"><span class="brackets">2</span></dt>
<dd><p>Kensheng Wu, Ekow Otoo and Arie Shoshani, “Optimizing connected
component labeling algorithms”, Paper LBNL-56864, 2005,
Lawrence Berkeley National Laboratory (University of California),
<a class="reference external" href="http://repositories.cdlib.org/lbnl/LBNL-56864">http://repositories.cdlib.org/lbnl/LBNL-56864</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 1 0]</span>
<span class="go"> [0 0 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 2 0]</span>
<span class="go"> [0 0 3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 1 0]</span>
<span class="go"> [0 0 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">background</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1 2 2]</span>
<span class="go"> [2 1 2]</span>
<span class="go"> [2 2 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [1 1 2]</span>
<span class="go"> [0 0 0]]</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-measure-label">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.measure.label</span></code><a class="headerlink" href="#examples-using-skimage-measure-label" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima..."><div class="figure align-default" id="id55">
<img alt="Measure region properties" src="../_images/sphx_glr_plot_regionprops_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></span><a class="headerlink" href="#id55" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows an illustration of the computation of the Euler number [1]_ in 2D and 3D obj..."><div class="figure align-default" id="id56">
<img alt="Euler number" src="../_images/sphx_glr_plot_euler_number_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_euler_number.html#sphx-glr-auto-examples-segmentation-plot-euler-number-py"><span class="std std-ref">Euler number</span></a></span><a class="headerlink" href="#id56" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example, we analyze a microscopy image of human cells. We use data provided by Jason Mo..."><div class="figure align-default" id="id57">
<img alt="Segment human cells (in mitosis)" src="../_images/sphx_glr_plot_human_mitosis_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_human_mitosis.html#sphx-glr-auto-examples-applications-plot-human-mitosis-py"><span class="std std-ref">Segment human cells (in mitosis)</span></a></span><a class="headerlink" href="#id57" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="marching-cubes">
<h2>marching_cubes<a class="headerlink" href="#marching-cubes" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.marching_cubes">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">marching_cubes</code><span class="sig-paren">(</span><em class="sig-param">volume</em>, <em class="sig-param">level=None</em>, <em class="sig-param">*</em>, <em class="sig-param">spacing=(1.0</em>, <em class="sig-param">1.0</em>, <em class="sig-param">1.0)</em>, <em class="sig-param">gradient_direction='descent'</em>, <em class="sig-param">step_size=1</em>, <em class="sig-param">allow_degenerate=True</em>, <em class="sig-param">method='lewiner'</em>, <em class="sig-param">mask=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_marching_cubes_lewiner.py#L11-L153"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.marching_cubes" title="Permalink to this definition">¶</a></dt>
<dd><p>Marching cubes algorithm to find surfaces in 3d volumetric data.</p>
<p>In contrast with Lorensen et al. approach <a class="reference internal" href="#rcddcc8f5d58b-2" id="id10">[2]</a>, Lewiner et
al. algorithm is faster, resolves ambiguities, and guarantees
topologically correct results. Therefore, this algorithm generally
a better choice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>volume</strong><span class="classifier">(M, N, P) array</span></dt><dd><p>Input data volume to find isosurfaces. Will internally be
converted to float32 if necessary.</p>
</dd>
<dt><strong>level</strong><span class="classifier">float, optional</span></dt><dd><p>Contour value to search for isosurfaces in <em class="xref py py-obj">volume</em>. If not
given or None, the average of the min and max of vol is used.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">length-3 tuple of floats, optional</span></dt><dd><p>Voxel spacing in spatial dimensions corresponding to numpy array
indexing dimensions (M, N, P) as in <em class="xref py py-obj">volume</em>.</p>
</dd>
<dt><strong>gradient_direction</strong><span class="classifier">string, optional</span></dt><dd><p>Controls if the mesh was generated from an isosurface with gradient
descent toward objects of interest (the default), or the opposite,
considering the <em>left-hand</em> rule.
The two options are:
* descent : Object was greater than exterior
* ascent : Exterior was greater than object</p>
</dd>
<dt><strong>step_size</strong><span class="classifier">int, optional</span></dt><dd><p>Step size in voxels. Default 1. Larger steps yield faster but
coarser results. The result will always be topologically correct
though.</p>
</dd>
<dt><strong>allow_degenerate</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to allow degenerate (i.e. zero-area) triangles in the
end-result. Default True. If False, degenerate triangles are
removed, at the cost of making the algorithm slower.</p>
</dd>
<dt><strong>method: str, optional</strong></dt><dd><p>One of ‘lewiner’, ‘lorensen’ or ‘_lorensen’. Specify witch of
Lewiner et al. or Lorensen et al. method will be used. The
‘_lorensen’ flag correspond to an old implementation that will
be deprecated in version 0.19.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">(M, N, P) array, optional</span></dt><dd><p>Boolean array. The marching cube algorithm will be computed only on
True elements. This will save computational time when interfaces
are located within certain region of the volume M, N, P-e.g. the top
half of the cube-and also allow to compute finite surfaces-i.e. open
surfaces that do not end at the border of the cube.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>verts</strong><span class="classifier">(V, 3) array</span></dt><dd><p>Spatial coordinates for V unique mesh vertices. Coordinate order
matches input <em class="xref py py-obj">volume</em> (M, N, P). If <code class="docutils literal notranslate"><span class="pre">allow_degenerate</span></code> is set to
True, then the presence of degenerate triangles in the mesh can make
this array have duplicate vertices.</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(F, 3) array</span></dt><dd><p>Define triangular faces via referencing vertex indices from <code class="docutils literal notranslate"><span class="pre">verts</span></code>.
This algorithm specifically outputs triangles, so each face has
exactly three indices.</p>
</dd>
<dt><strong>normals</strong><span class="classifier">(V, 3) array</span></dt><dd><p>The normal direction at each vertex, as calculated from the
data.</p>
</dd>
<dt><strong>values</strong><span class="classifier">(V, ) array</span></dt><dd><p>Gives a measure for the maximum value of the data in the local region
near each vertex. This can be used by visualization tools to apply
a colormap to the mesh.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.mesh_surface_area</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.measure.find_contours" title="skimage.measure.find_contours"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.find_contours</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The algorithm <a class="reference internal" href="#rcddcc8f5d58b-1" id="id11">[1]</a> is an improved version of Chernyaev’s Marching
Cubes 33 algorithm. It is an efficient algorithm that relies on
heavy use of lookup tables to handle the many different cases,
keeping the algorithm relatively easy. This implementation is
written in Cython, ported from Lewiner’s C++ implementation.</p>
<p>To quantify the area of an isosurface generated by this algorithm, pass
verts and faces to <a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.mesh_surface_area</span></code></a>.</p>
<p>Regarding visualization of algorithm output, to contour a volume
named <em class="xref py py-obj">myvolume</em> about the level 0.0, using the <code class="docutils literal notranslate"><span class="pre">mayavi</span></code> package:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;</span>
<span class="go">&gt;&gt; from mayavi import mlab</span>
<span class="go">&gt;&gt; verts, faces, _, _ = marching_cubes(myvolume, 0.0)</span>
<span class="go">&gt;&gt; mlab.triangular_mesh([vert[0] for vert in verts],</span>
<span class="go">                        [vert[1] for vert in verts],</span>
<span class="go">                        [vert[2] for vert in verts],</span>
<span class="go">                        faces)</span>
<span class="go">&gt;&gt; mlab.show()</span>
</pre></div>
</div>
<p>Similarly using the <code class="docutils literal notranslate"><span class="pre">visvis</span></code> package:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;</span>
<span class="go">&gt;&gt; import visvis as vv</span>
<span class="go">&gt;&gt; verts, faces, normals, values = marching_cubes(myvolume, 0.0)</span>
<span class="go">&gt;&gt; vv.mesh(np.fliplr(verts), faces, normals, values)</span>
<span class="go">&gt;&gt; vv.use().Run()</span>
</pre></div>
</div>
<p>To reduce the number of triangles in the mesh for better performance,
see this <a class="reference external" href="https://docs.enthought.com/mayavi/mayavi/auto/example_julia_set_decimation.html#example-julia-set-decimation">example</a>
using the <code class="docutils literal notranslate"><span class="pre">mayavi</span></code> package.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rcddcc8f5d58b-1"><span class="brackets"><a class="fn-backref" href="#id11">1</a></span></dt>
<dd><p>Thomas Lewiner, Helio Lopes, Antonio Wilson Vieira and Geovan
Tavares. Efficient implementation of Marching Cubes’ cases with
topological guarantees. Journal of Graphics Tools 8(2)
pp. 1-15 (december 2003).
<a class="reference external" href="https://doi.org/10.1080/10867651.2003.10487582">DOI:10.1080/10867651.2003.10487582</a></p>
</dd>
<dt class="label" id="rcddcc8f5d58b-2"><span class="brackets"><a class="fn-backref" href="#id10">2</a></span></dt>
<dd><p>Lorensen, William and Harvey E. Cline. Marching Cubes: A High
Resolution 3D Surface Construction Algorithm. Computer Graphics
(SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170).
<a class="reference external" href="https://doi.org/10.1145/37401.37422">DOI:10.1145/37401.37422</a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="marching-cubes-classic">
<h2>marching_cubes_classic<a class="headerlink" href="#marching-cubes-classic" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.marching_cubes_classic">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">marching_cubes_classic</code><span class="sig-paren">(</span><em class="sig-param">volume</em>, <em class="sig-param">level=None</em>, <em class="sig-param">spacing=(1.0</em>, <em class="sig-param">1.0</em>, <em class="sig-param">1.0)</em>, <em class="sig-param">gradient_direction='descent'</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_marching_cubes_classic.py#L7-L111"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.marching_cubes_classic" title="Permalink to this definition">¶</a></dt>
<dd><p>Classic marching cubes algorithm to find surfaces in 3d volumetric data.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">marching_cubes()</span></code> algorithm is recommended over
this algorithm, because it’s faster and produces better results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>volume</strong><span class="classifier">(M, N, P) array of doubles</span></dt><dd><p>Input data volume to find isosurfaces. Will be cast to <em class="xref py py-obj">np.float64</em>.</p>
</dd>
<dt><strong>level</strong><span class="classifier">float</span></dt><dd><p>Contour value to search for isosurfaces in <em class="xref py py-obj">volume</em>. If not
given or None, the average of the min and max of vol is used.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">length-3 tuple of floats</span></dt><dd><p>Voxel spacing in spatial dimensions corresponding to numpy array
indexing dimensions (M, N, P) as in <em class="xref py py-obj">volume</em>.</p>
</dd>
<dt><strong>gradient_direction</strong><span class="classifier">string</span></dt><dd><p>Controls if the mesh was generated from an isosurface with gradient
descent toward objects of interest (the default), or the opposite.
The two options are:
* descent : Object was greater than exterior
* ascent : Exterior was greater than object</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>verts</strong><span class="classifier">(V, 3) array</span></dt><dd><p>Spatial coordinates for V unique mesh vertices. Coordinate order
matches input <em class="xref py py-obj">volume</em> (M, N, P). If <code class="docutils literal notranslate"><span class="pre">allow_degenerate</span></code> is set to
True, then the presence of degenerate triangles in the mesh can make
this array have duplicate vertices.</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(F, 3) array</span></dt><dd><p>Define triangular faces via referencing vertex indices from <code class="docutils literal notranslate"><span class="pre">verts</span></code>.
This algorithm specifically outputs triangles, so each face has
exactly three indices.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.marching_cubes</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.mesh_surface_area</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The marching cubes algorithm is implemented as described in <a class="reference internal" href="#r1e43a330a523-1" id="id14">[1]</a>.
A simple explanation is available here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">users</span><span class="o">.</span><span class="n">polytech</span><span class="o">.</span><span class="n">unice</span><span class="o">.</span><span class="n">fr</span><span class="o">/~</span><span class="n">lingrand</span><span class="o">/</span><span class="n">MarchingCubes</span><span class="o">/</span><span class="n">algo</span><span class="o">.</span><span class="n">html</span>
</pre></div>
</div>
<p>There are several known ambiguous cases in the marching cubes algorithm.
Using point labeling as in <a class="reference internal" href="#r1e43a330a523-1" id="id15">[1]</a>, Figure 4, as shown:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    v8 ------ v7
   / |       / |        y
  /  |      /  |        ^  z
v4 ------ v3   |        | /
 |  v5 ----|- v6        |/          (note: NOT right handed!)
 |  /      |  /          ----&gt; x
 | /       | /
v1 ------ v2
</pre></div>
</div>
<p>Most notably, if v4, v8, v2, and v6 are all &gt;= <em class="xref py py-obj">level</em> (or any
generalization of this case) two parallel planes are generated by this
algorithm, separating v4 and v8 from v2 and v6. An equally valid
interpretation would be a single connected thin surface enclosing all
four points. This is the best known ambiguity, though there are others.</p>
<p>This algorithm does not attempt to resolve such ambiguities; it is a naive
implementation of marching cubes as in <a class="reference internal" href="#r1e43a330a523-1" id="id16">[1]</a>, but may be a good beginning
for work with more recent techniques (Dual Marching Cubes, Extended
Marching Cubes, Cubic Marching Squares, etc.).</p>
<p>Because of interactions between neighboring cubes, the isosurface(s)
generated by this algorithm are NOT guaranteed to be closed, particularly
for complicated contours. Furthermore, this algorithm does not guarantee
a single contour will be returned. Indeed, ALL isosurfaces which cross
<em class="xref py py-obj">level</em> will be found, regardless of connectivity.</p>
<p>The output is a triangular mesh consisting of a set of unique vertices and
connecting triangles. The order of these vertices and triangles in the
output list is determined by the position of the smallest <code class="docutils literal notranslate"><span class="pre">x,y,z</span></code> (in
lexicographical order) coordinate in the contour.  This is a side-effect
of how the input array is traversed, but can be relied upon.</p>
<p>The generated mesh guarantees coherent orientation as of version 0.12.</p>
<p>To quantify the area of an isosurface generated by this algorithm, pass
outputs directly into <a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.mesh_surface_area</span></code></a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1e43a330a523-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id14">1</a>,<a href="#id15">2</a>,<a href="#id16">3</a>)</span></dt>
<dd><p>Lorensen, William and Harvey E. Cline. Marching Cubes: A High
Resolution 3D Surface Construction Algorithm. Computer Graphics
(SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170).
<a class="reference external" href="https://doi.org/10.1145/37401.37422">DOI:10.1145/37401.37422</a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="marching-cubes-lewiner">
<h2>marching_cubes_lewiner<a class="headerlink" href="#marching-cubes-lewiner" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.marching_cubes_lewiner">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">marching_cubes_lewiner</code><span class="sig-paren">(</span><em class="sig-param">volume</em>, <em class="sig-param">level=None</em>, <em class="sig-param">spacing=(1.0</em>, <em class="sig-param">1.0</em>, <em class="sig-param">1.0)</em>, <em class="sig-param">gradient_direction='descent'</em>, <em class="sig-param">step_size=1</em>, <em class="sig-param">allow_degenerate=True</em>, <em class="sig-param">use_classic=False</em>, <em class="sig-param">mask=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_marching_cubes_lewiner.py#L156-L277"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.marching_cubes_lewiner" title="Permalink to this definition">¶</a></dt>
<dd><p>Lewiner marching cubes algorithm to find surfaces in 3d volumetric data.</p>
<p>In contrast to <code class="docutils literal notranslate"><span class="pre">marching_cubes_classic()</span></code>, this algorithm is faster,
resolves ambiguities, and guarantees topologically correct results.
Therefore, this algorithm generally a better choice, unless there
is a specific need for the classic algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>volume</strong><span class="classifier">(M, N, P) array</span></dt><dd><p>Input data volume to find isosurfaces. Will internally be
converted to float32 if necessary.</p>
</dd>
<dt><strong>level</strong><span class="classifier">float</span></dt><dd><p>Contour value to search for isosurfaces in <em class="xref py py-obj">volume</em>. If not
given or None, the average of the min and max of vol is used.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">length-3 tuple of floats</span></dt><dd><p>Voxel spacing in spatial dimensions corresponding to numpy array
indexing dimensions (M, N, P) as in <em class="xref py py-obj">volume</em>.</p>
</dd>
<dt><strong>gradient_direction</strong><span class="classifier">string</span></dt><dd><p>Controls if the mesh was generated from an isosurface with gradient
descent toward objects of interest (the default), or the opposite,
considering the <em>left-hand</em> rule.
The two options are:
* descent : Object was greater than exterior
* ascent : Exterior was greater than object</p>
</dd>
<dt><strong>step_size</strong><span class="classifier">int</span></dt><dd><p>Step size in voxels. Default 1. Larger steps yield faster but
coarser results. The result will always be topologically correct
though.</p>
</dd>
<dt><strong>allow_degenerate</strong><span class="classifier">bool</span></dt><dd><p>Whether to allow degenerate (i.e. zero-area) triangles in the
end-result. Default True. If False, degenerate triangles are
removed, at the cost of making the algorithm slower.</p>
</dd>
<dt><strong>use_classic</strong><span class="classifier">bool</span></dt><dd><p>If given and True, the classic marching cubes by Lorensen (1987)
is used. This option is included for reference purposes. Note
that this algorithm has ambiguities and is not guaranteed to
produce a topologically correct result. The results with using
this option are <em>not</em> generally the same as the
<code class="docutils literal notranslate"><span class="pre">marching_cubes_classic()</span></code> function.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">(M, N, P) array</span></dt><dd><p>Boolean array. The marching cube algorithm will be computed only on
True elements. This will save computational time when interfaces
are located within certain region of the volume M, N, P-e.g. the top
half of the cube-and also allow to compute finite surfaces-i.e. open
surfaces that do not end at the border of the cube.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>verts</strong><span class="classifier">(V, 3) array</span></dt><dd><p>Spatial coordinates for V unique mesh vertices. Coordinate order
matches input <em class="xref py py-obj">volume</em> (M, N, P). If <code class="docutils literal notranslate"><span class="pre">allow_degenerate</span></code> is set to
True, then the presence of degenerate triangles in the mesh can make
this array have duplicate vertices.</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(F, 3) array</span></dt><dd><p>Define triangular faces via referencing vertex indices from <code class="docutils literal notranslate"><span class="pre">verts</span></code>.
This algorithm specifically outputs triangles, so each face has
exactly three indices.</p>
</dd>
<dt><strong>normals</strong><span class="classifier">(V, 3) array</span></dt><dd><p>The normal direction at each vertex, as calculated from the
data.</p>
</dd>
<dt><strong>values</strong><span class="classifier">(V, ) array</span></dt><dd><p>Gives a measure for the maximum value of the data in the local region
near each vertex. This can be used by visualization tools to apply
a colormap to the mesh.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.marching_cubes</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.mesh_surface_area</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The algorithm [1] is an improved version of Chernyaev’s Marching
Cubes 33 algorithm. It is an efficient algorithm that relies on
heavy use of lookup tables to handle the many different cases,
keeping the algorithm relatively easy. This implementation is
written in Cython, ported from Lewiner’s C++ implementation.</p>
<p>To quantify the area of an isosurface generated by this algorithm, pass
verts and faces to <a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.mesh_surface_area</span></code></a>.</p>
<p>Regarding visualization of algorithm output, to contour a volume
named <em class="xref py py-obj">myvolume</em> about the level 0.0, using the <code class="docutils literal notranslate"><span class="pre">mayavi</span></code> package:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mayavi</span> <span class="kn">import</span> <span class="n">mlab</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">marching_cubes_lewiner</span><span class="p">(</span><span class="n">myvolume</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">mlab</span><span class="o">.</span><span class="n">triangular_mesh</span><span class="p">([</span><span class="n">vert</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">],</span>
<span class="gp">... </span>                     <span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">],</span>
<span class="gp">... </span>                     <span class="p">[</span><span class="n">vert</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">vert</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">],</span>
<span class="gp">... </span>                     <span class="n">faces</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">mlab</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> 
</pre></div>
</div>
<p>Similarly using the <code class="docutils literal notranslate"><span class="pre">visvis</span></code> package:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">visvis</span> <span class="k">as</span> <span class="nn">vv</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">marching_cubes_lewiner</span><span class="p">(</span><span class="n">myvolume</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">vv</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">verts</span><span class="p">),</span> <span class="n">faces</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">vv</span><span class="o">.</span><span class="n">use</span><span class="p">()</span><span class="o">.</span><span class="n">Run</span><span class="p">()</span> 
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rda8f856612d5-1"><span class="brackets">1</span></dt>
<dd><p>Thomas Lewiner, Helio Lopes, Antonio Wilson Vieira and Geovan
Tavares. Efficient implementation of Marching Cubes’ cases with
topological guarantees. Journal of Graphics Tools 8(2)
pp. 1-15 (december 2003).
<a class="reference external" href="https://doi.org/10.1080/10867651.2003.10487582">DOI:10.1080/10867651.2003.10487582</a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="mesh-surface-area">
<h2>mesh_surface_area<a class="headerlink" href="#mesh-surface-area" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.mesh_surface_area">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">mesh_surface_area</code><span class="sig-paren">(</span><em class="sig-param">verts</em>, <em class="sig-param">faces</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_marching_cubes_classic.py#L157-L196"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.mesh_surface_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute surface area, given vertices &amp; triangular faces</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>verts</strong><span class="classifier">(V, 3) array of floats</span></dt><dd><p>Array containing (x, y, z) coordinates for V unique mesh vertices.</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(F, 3) array of ints</span></dt><dd><p>List of length-3 lists of integers, referencing vertex coordinates as
provided in <em class="xref py py-obj">verts</em></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>area</strong><span class="classifier">float</span></dt><dd><p>Surface area of mesh. Units now [coordinate units] ** 2.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.marching_cubes</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.measure.marching_cubes_classic" title="skimage.measure.marching_cubes_classic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.marching_cubes_classic</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The arguments expected by this function are the first two outputs from
<a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.marching_cubes</span></code></a>. For unit correct output, ensure correct
<em class="xref py py-obj">spacing</em> was passed to <a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.marching_cubes</span></code></a>.</p>
<p>This algorithm works properly only if the <code class="docutils literal notranslate"><span class="pre">faces</span></code> provided are all
triangles.</p>
</dd></dl>

</div>
<div class="section" id="moments">
<h2>moments<a class="headerlink" href="#moments" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.moments">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">moments</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">order=3</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L149-L191"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.moments" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate all raw image moments up to a certain order.</p>
<dl class="simple">
<dt>The following properties can be calculated from raw image moments:</dt><dd><ul class="simple">
<li><p>Area as: <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">0]</span></code>.</p></li>
<li><p>Centroid as: {<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p></li>
</ul>
</dd>
</dl>
<p>Note that raw moments are neither translation, scale nor rotation
invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">nD double or uint8 array</span></dt><dd><p>Rasterized shape as image.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>m</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>) array</span></dt><dd><p>Raw image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r3012f4679c28-1"><span class="brackets">1</span></dt>
<dd><p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</dd>
<dt class="label" id="r3012f4679c28-2"><span class="brackets">2</span></dt>
<dd><p>B. Jähne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</dd>
<dt class="label" id="r3012f4679c28-3"><span class="brackets">3</span></dt>
<dd><p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</dd>
<dt class="label" id="r3012f4679c28-4"><span class="brackets">4</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">moments</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span>
<span class="go">(14.5, 14.5)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="moments-central">
<h2>moments_central<a class="headerlink" href="#moments-central" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.moments_central">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">moments_central</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">center=None</em>, <em class="sig-param">order=3</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L194-L250"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.moments_central" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate all central image moments up to a certain order.</p>
<p>The center coordinates (cr, cc) can be calculated from the raw moments as:
{<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p>
<p>Note that central moments are translation invariant but not scale and
rotation invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">nD double or uint8 array</span></dt><dd><p>Rasterized shape as image.</p>
</dd>
<dt><strong>center</strong><span class="classifier">tuple of float, optional</span></dt><dd><p>Coordinates of the image centroid. This will be computed if it
is not provided.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The maximum order of moments computed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>mu</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>) array</span></dt><dd><p>Central image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="re30db7550969-1"><span class="brackets">1</span></dt>
<dd><p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</dd>
<dt class="label" id="re30db7550969-2"><span class="brackets">2</span></dt>
<dd><p>B. Jähne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</dd>
<dt class="label" id="re30db7550969-3"><span class="brackets">3</span></dt>
<dd><p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</dd>
<dt class="label" id="re30db7550969-4"><span class="brackets">4</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">moments</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_central</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">centroid</span><span class="p">)</span>
<span class="go">array([[16.,  0., 20.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.],</span>
<span class="go">       [20.,  0., 25.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="moments-coords">
<h2>moments_coords<a class="headerlink" href="#moments-coords" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.moments_coords">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">moments_coords</code><span class="sig-paren">(</span><em class="sig-param">coords</em>, <em class="sig-param">order=3</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L7-L45"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.moments_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate all raw image moments up to a certain order.</p>
<dl class="simple">
<dt>The following properties can be calculated from raw image moments:</dt><dd><ul class="simple">
<li><p>Area as: <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">0]</span></code>.</p></li>
<li><p>Centroid as: {<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p></li>
</ul>
</dd>
</dl>
<p>Note that raw moments are neither translation, scale nor rotation
invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) double or uint8 array</span></dt><dd><p>Array of N points that describe an image of D dimensionality in
Cartesian space.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>M</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, …) array</span></dt><dd><p>Raw image moments. (D dimensions)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1906bd878ddc-1"><span class="brackets">1</span></dt>
<dd><p>Johannes Kilian. Simple Image Analysis By Moments. Durham
University, version 0.2, Durham, 2001.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">18</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">moments_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span>
<span class="go">(14.5, 15.5)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="moments-coords-central">
<h2>moments_coords_central<a class="headerlink" href="#moments-coords-central" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.moments_coords_central">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">moments_coords_central</code><span class="sig-paren">(</span><em class="sig-param">coords</em>, <em class="sig-param">center=None</em>, <em class="sig-param">order=3</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L48-L146"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.moments_coords_central" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate all central image moments up to a certain order.</p>
<dl class="simple">
<dt>The following properties can be calculated from raw image moments:</dt><dd><ul class="simple">
<li><p>Area as: <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">0]</span></code>.</p></li>
<li><p>Centroid as: {<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p></li>
</ul>
</dd>
</dl>
<p>Note that raw moments are neither translation, scale nor rotation
invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) double or uint8 array</span></dt><dd><p>Array of N points that describe an image of D dimensionality in
Cartesian space. A tuple of coordinates as returned by
<code class="docutils literal notranslate"><span class="pre">np.nonzero</span></code> is also accepted as input.</p>
</dd>
<dt><strong>center</strong><span class="classifier">tuple of float, optional</span></dt><dd><p>Coordinates of the image centroid. This will be computed if it
is not provided.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>Mc</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, …) array</span></dt><dd><p>Central image moments. (D dimensions)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rdba8c2d58a27-1"><span class="brackets">1</span></dt>
<dd><p>Johannes Kilian. Simple Image Analysis By Moments. Durham
University, version 0.2, Durham, 2001.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">18</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_coords_central</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
<span class="go">array([[16.,  0., 20.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.],</span>
<span class="go">       [20.,  0., 25.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
<p>As seen above, for symmetric objects, odd-order moments (columns 1 and 3,
rows 1 and 3) are zero when centered on the centroid, or center of mass,
of the object (the default). If we break the symmetry by adding a new
point, this no longer holds:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">coords</span><span class="p">,</span> <span class="p">[[</span><span class="mi">17</span><span class="p">,</span> <span class="mi">17</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">moments_coords_central</span><span class="p">(</span><span class="n">coords2</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">decimals</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">array([[17.  ,  0.  , 22.12, -2.49],</span>
<span class="go">       [ 0.  ,  3.53,  1.73,  7.4 ],</span>
<span class="go">       [25.88,  6.02, 36.63,  8.83],</span>
<span class="go">       [ 4.15, 19.17, 14.8 , 39.6 ]])</span>
</pre></div>
</div>
<p>Image moments and central image moments are equivalent (by definition)
when the center is (0, 0):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">moments_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span>
<span class="gp">... </span>            <span class="n">moments_coords_central</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="moments-hu">
<h2>moments_hu<a class="headerlink" href="#moments-hu" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.moments_hu">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">moments_hu</code><span class="sig-paren">(</span><em class="sig-param">nu</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L308-L348"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.moments_hu" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Hu’s set of image moments (2D-only).</p>
<p>Note that this set of moments is proofed to be translation, scale and
rotation invariant.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nu</strong><span class="classifier">(M, M) array</span></dt><dd><p>Normalized central image moments, where M must be &gt;= 4.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nu</strong><span class="classifier">(7,) array</span></dt><dd><p>Hu’s set of image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8f5f4137a534-1"><span class="brackets">1</span></dt>
<dd><p>M. K. Hu, “Visual Pattern Recognition by Moment Invariants”,
IRE Trans. Info. Theory, vol. IT-8, pp. 179-187, 1962</p>
</dd>
<dt class="label" id="r8f5f4137a534-2"><span class="brackets">2</span></dt>
<dd><p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</dd>
<dt class="label" id="r8f5f4137a534-3"><span class="brackets">3</span></dt>
<dd><p>B. Jähne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</dd>
<dt class="label" id="r8f5f4137a534-4"><span class="brackets">4</span></dt>
<dd><p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</dd>
<dt class="label" id="r8f5f4137a534-5"><span class="brackets">5</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mu</span> <span class="o">=</span> <span class="n">moments_central</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nu</span> <span class="o">=</span> <span class="n">moments_normalized</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_hu</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
<span class="go">array([7.45370370e-01, 3.51165981e-01, 1.04049179e-01, 4.06442107e-02,</span>
<span class="go">       2.64312299e-03, 2.40854582e-02, 4.33680869e-19])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="moments-normalized">
<h2>moments_normalized<a class="headerlink" href="#moments-normalized" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.moments_normalized">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">moments_normalized</code><span class="sig-paren">(</span><em class="sig-param">mu</em>, <em class="sig-param">order=3</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L253-L305"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.moments_normalized" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate all normalized central image moments up to a certain order.</p>
<p>Note that normalized central moments are translation and scale invariant
but not rotation invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mu</strong><span class="classifier">(M,[ …,] M) array</span></dt><dd><p>Central image moments, where M must be greater than or equal
to <code class="docutils literal notranslate"><span class="pre">order</span></code>.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>nu</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>,[ …,] <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>) array</span></dt><dd><p>Normalized central image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rc5867b15e1bf-1"><span class="brackets">1</span></dt>
<dd><p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</dd>
<dt class="label" id="rc5867b15e1bf-2"><span class="brackets">2</span></dt>
<dd><p>B. Jähne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</dd>
<dt class="label" id="rc5867b15e1bf-3"><span class="brackets">3</span></dt>
<dd><p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</dd>
<dt class="label" id="rc5867b15e1bf-4"><span class="brackets">4</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">moments</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mu</span> <span class="o">=</span> <span class="n">moments_central</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">centroid</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_normalized</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="go">array([[       nan,        nan, 0.078125  , 0.        ],</span>
<span class="go">       [       nan, 0.        , 0.        , 0.        ],</span>
<span class="go">       [0.078125  , 0.        , 0.00610352, 0.        ],</span>
<span class="go">       [0.        , 0.        , 0.        , 0.        ]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="perimeter">
<h2>perimeter<a class="headerlink" href="#perimeter" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.perimeter">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">perimeter</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">neighbourhood=4</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_regionprops_utils.py#L186-L249"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.perimeter" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate total perimeter of all objects in binary image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>2D binary image.</p>
</dd>
<dt><strong>neighbourhood</strong><span class="classifier">4 or 8, optional</span></dt><dd><p>Neighborhood connectivity for border pixel determination. It is used to
compute the contour. A higher neighbourhood widens the border on which
the perimeter is computed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perimeter</strong><span class="classifier">float</span></dt><dd><p>Total perimeter of all objects in binary image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5745cfa18943-1"><span class="brackets">1</span></dt>
<dd><p>K. Benkrid, D. Crookes. Design and FPGA Implementation of
a Perimeter Estimator. The Queen’s University of Belfast.
<a class="reference external" href="http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc">http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">label</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># coins image (binary)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_coins</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">110</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># total perimeter of all objects in the image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perimeter</span><span class="p">(</span><span class="n">img_coins</span><span class="p">,</span> <span class="n">neighbourhood</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  
<span class="go">7796.867...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perimeter</span><span class="p">(</span><span class="n">img_coins</span><span class="p">,</span> <span class="n">neighbourhood</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>  
<span class="go">8806.268...</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-measure-perimeter">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.measure.perimeter</span></code><a class="headerlink" href="#examples-using-skimage-measure-perimeter" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="In this example we show the uncertainty on calculating perimeters, comparing classic and Crofto..."><div class="figure align-default" id="id58">
<img alt="Different perimeters" src="../_images/sphx_glr_plot_perimeters_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_perimeters.html#sphx-glr-auto-examples-segmentation-plot-perimeters-py"><span class="std std-ref">Different perimeters</span></a></span><a class="headerlink" href="#id58" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="perimeter-crofton">
<h2>perimeter_crofton<a class="headerlink" href="#perimeter-crofton" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.perimeter_crofton">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">perimeter_crofton</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">directions=4</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_regionprops_utils.py#L252-L328"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.perimeter_crofton" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate total Crofton perimeter of all objects in binary image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>2D image. If image is not binary, all values strictly greater than zero
are considered as the object.</p>
</dd>
<dt><strong>directions</strong><span class="classifier">2 or 4, optional</span></dt><dd><p>Number of directions used to approximate the Crofton perimeter. By
default, 4 is used: it should be more accurate than 2.
Computation time is the same in both cases.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perimeter</strong><span class="classifier">float</span></dt><dd><p>Total perimeter of all objects in binary image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This measure is based on Crofton formula [1], which is a measure from
integral geometry. It is defined for general curve length evaluation via
a double integral along all directions. In a discrete
space, 2 or 4 directions give a quite good approximation, 4 being more
accurate than 2 for more complex shapes.</p>
<p>Similar to <a class="reference internal" href="#skimage.measure.perimeter" title="skimage.measure.perimeter"><code class="xref py py-func docutils literal notranslate"><span class="pre">perimeter()</span></code></a>, this function returns an
approximation of the perimeter in continuous space.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r08d850c42e9e-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Crofton_formula">https://en.wikipedia.org/wiki/Crofton_formula</a></p>
</dd>
<dt class="label" id="r08d850c42e9e-2"><span class="brackets">2</span></dt>
<dd><p>S. Rivollier. Analyse d’image geometrique et morphometrique par
diagrammes de forme et voisinages adaptatifs generaux. PhD thesis,
2010.
Ecole Nationale Superieure des Mines de Saint-Etienne.
<a class="reference external" href="https://tel.archives-ouvertes.fr/tel-00560838">https://tel.archives-ouvertes.fr/tel-00560838</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">label</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># coins image (binary)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_coins</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">110</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># total perimeter of all objects in the image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perimeter_crofton</span><span class="p">(</span><span class="n">img_coins</span><span class="p">,</span> <span class="n">directions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">8144.578...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perimeter_crofton</span><span class="p">(</span><span class="n">img_coins</span><span class="p">,</span> <span class="n">directions</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  
<span class="go">7837.077...</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-measure-perimeter-crofton">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.measure.perimeter_crofton</span></code><a class="headerlink" href="#examples-using-skimage-measure-perimeter-crofton" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="In this example we show the uncertainty on calculating perimeters, comparing classic and Crofto..."><div class="figure align-default" id="id59">
<img alt="Different perimeters" src="../_images/sphx_glr_plot_perimeters_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_perimeters.html#sphx-glr-auto-examples-segmentation-plot-perimeters-py"><span class="std std-ref">Different perimeters</span></a></span><a class="headerlink" href="#id59" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="points-in-poly">
<h2>points_in_poly<a class="headerlink" href="#points-in-poly" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.points_in_poly">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">points_in_poly</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">verts</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/pnpoly.py#L32-L53"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.points_in_poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether points lie inside a polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Input points, <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code>.</p>
</dd>
<dt><strong>verts</strong><span class="classifier">(M, 2) array</span></dt><dd><p>Vertices of the polygon, sorted either clockwise or anti-clockwise.
The first point may (but does not need to be) duplicated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mask</strong><span class="classifier">(N,) array of bool</span></dt><dd><p>True if corresponding point is inside the polygon.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.grid_points_in_poly" title="skimage.measure.grid_points_in_poly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_points_in_poly</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

</div>
<div class="section" id="profile-line">
<h2>profile_line<a class="headerlink" href="#profile-line" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.profile_line">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">profile_line</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">src</em>, <em class="sig-param">dst</em>, <em class="sig-param">linewidth=1</em>, <em class="sig-param">order=None</em>, <em class="sig-param">mode=None</em>, <em class="sig-param">cval=0.0</em>, <em class="sig-param">*</em>, <em class="sig-param">reduce_func=&lt;function mean&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/profile.py#L8-L127"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.profile_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intensity profile of an image measured along a scan line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray, shape (M, N[, C])</span></dt><dd><p>The image, either grayscale (2D array) or multichannel
(3D array, where the final axis contains the channel
information).</p>
</dd>
<dt><strong>src</strong><span class="classifier">array_like, shape (2, )</span></dt><dd><p>The coordinates of the start point of the scan line.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">array_like, shape (2, )</span></dt><dd><p>The coordinates of the end point of the scan
line. The destination point is <em>included</em> in the profile, in
contrast to standard numpy indexing.</p>
</dd>
<dt><strong>linewidth</strong><span class="classifier">int, optional</span></dt><dd><p>Width of the scan, perpendicular to the line</p>
</dd>
<dt><strong>order</strong><span class="classifier">int in {0, 1, 2, 3, 4, 5}, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <a class="reference internal" href="skimage.transform.html#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘nearest’, ‘reflect’, ‘mirror’, ‘wrap’}, optional</span></dt><dd><p>How to compute any values falling outside of the image.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>If <em class="xref py py-obj">mode</em> is ‘constant’, what constant value to use outside the image.</p>
</dd>
<dt><strong>reduce_func</strong><span class="classifier">callable, optional</span></dt><dd><p>Function used to calculate the aggregation of pixel values
perpendicular to the profile_line direction when <em class="xref py py-obj">linewidth</em> &gt; 1.
If set to None the unreduced array will be returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>return_value</strong><span class="classifier">array</span></dt><dd><p>The intensity profile along the scan line. The length of the profile
is the ceil of the computed length of the scan line.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span>
<span class="go">array([[0, 0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 1, 2, 2, 2],</span>
<span class="go">       [1, 1, 1, 2, 2, 2],</span>
<span class="go">       [1, 1, 1, 2, 2, 2],</span>
<span class="go">       [0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">array([1., 1., 2., 2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">cval</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([1., 1., 1., 2., 2., 2., 4.])</span>
</pre></div>
</div>
<p>The destination point is included in the profile, in contrast to
standard numpy indexing.
For example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>  <span class="c1"># The final point is out of bounds</span>
<span class="go">array([1., 1., 1., 2., 2., 2., 0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>  <span class="c1"># This accesses the full first row</span>
<span class="go">array([1., 1., 1., 2., 2., 2.])</span>
</pre></div>
</div>
<p>For different reduce_func inputs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
<span class="go">array([0.66666667, 0.66666667, 0.66666667, 1.33333333])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">)</span>
<span class="go">array([2, 2, 2, 4])</span>
</pre></div>
</div>
<p>The unreduced array will be returned when <em class="xref py py-obj">reduce_func</em> is None or when
<em class="xref py py-obj">reduce_func</em> acts on each pixel value individually.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">reduce_func</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">array([[1, 1, 2],</span>
<span class="go">       [1, 1, 2],</span>
<span class="go">       [1, 1, 2],</span>
<span class="go">       [0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">)</span>
<span class="go">array([[1.        , 1.        , 0.        ],</span>
<span class="go">       [1.        , 1.        , 0.        ],</span>
<span class="go">       [1.        , 1.        , 0.        ],</span>
<span class="go">       [1.41421356, 1.41421356, 0.        ]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="ransac">
<h2>ransac<a class="headerlink" href="#ransac" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.ransac">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">ransac</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">model_class</em>, <em class="sig-param">min_samples</em>, <em class="sig-param">residual_threshold</em>, <em class="sig-param">is_data_valid=None</em>, <em class="sig-param">is_model_valid=None</em>, <em class="sig-param">max_trials=100</em>, <em class="sig-param">stop_sample_num=inf</em>, <em class="sig-param">stop_residuals_sum=0</em>, <em class="sig-param">stop_probability=1</em>, <em class="sig-param">random_state=None</em>, <em class="sig-param">initial_inliers=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L621-L881"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.ransac" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a model to data with the RANSAC (random sample consensus) algorithm.</p>
<p>RANSAC is an iterative algorithm for the robust estimation of parameters
from a subset of inliers from the complete data set. Each iteration
performs the following tasks:</p>
<ol class="arabic simple">
<li><p>Select <em class="xref py py-obj">min_samples</em> random samples from the original data and check
whether the set of data is valid (see <em class="xref py py-obj">is_data_valid</em>).</p></li>
<li><p>Estimate a model to the random subset
(<em class="xref py py-obj">model_cls.estimate(*data[random_subset]</em>) and check whether the
estimated model is valid (see <em class="xref py py-obj">is_model_valid</em>).</p></li>
<li><p>Classify all data as inliers or outliers by calculating the residuals
to the estimated model (<em class="xref py py-obj">model_cls.residuals(*data)</em>) - all data samples
with residuals smaller than the <em class="xref py py-obj">residual_threshold</em> are considered as
inliers.</p></li>
<li><p>Save estimated model as best model if number of inlier samples is
maximal. In case the current estimated model has the same number of
inliers, it is only considered as the best model if it has less sum of
residuals.</p></li>
</ol>
<p>These steps are performed either a maximum number of times or until one of
the special stop criteria are met. The final model is estimated using all
inlier samples of the previously determined best model.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">[list, tuple of] (N, …) array</span></dt><dd><p>Data set to which the model is fitted, where N is the number of data
points and the remaining dimension are depending on model requirements.
If the model class requires multiple input data arrays (e.g. source and
destination coordinates of  <code class="docutils literal notranslate"><span class="pre">skimage.transform.AffineTransform</span></code>),
they can be optionally passed as tuple or list. Note, that in this case
the functions <code class="docutils literal notranslate"><span class="pre">estimate(*data)</span></code>, <code class="docutils literal notranslate"><span class="pre">residuals(*data)</span></code>,
<code class="docutils literal notranslate"><span class="pre">is_model_valid(model,</span> <span class="pre">*random_data)</span></code> and
<code class="docutils literal notranslate"><span class="pre">is_data_valid(*random_data)</span></code> must all take each data array as
separate arguments.</p>
</dd>
<dt><strong>model_class</strong><span class="classifier">object</span></dt><dd><p>Object with the following object methods:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">success</span> <span class="pre">=</span> <span class="pre">estimate(*data)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">residuals(*data)</span></code></p></li>
</ul>
</div></blockquote>
<p>where <em class="xref py py-obj">success</em> indicates whether the model estimation succeeded
(<em class="xref py py-obj">True</em> or <em class="xref py py-obj">None</em> for success, <em class="xref py py-obj">False</em> for failure).</p>
</dd>
<dt><strong>min_samples</strong><span class="classifier">int in range (0, N)</span></dt><dd><p>The minimum number of data points to fit a model to.</p>
</dd>
<dt><strong>residual_threshold</strong><span class="classifier">float larger than 0</span></dt><dd><p>Maximum distance for a data point to be classified as an inlier.</p>
</dd>
<dt><strong>is_data_valid</strong><span class="classifier">function, optional</span></dt><dd><p>This function is called with the randomly selected data before the
model is fitted to it: <em class="xref py py-obj">is_data_valid(*random_data)</em>.</p>
</dd>
<dt><strong>is_model_valid</strong><span class="classifier">function, optional</span></dt><dd><p>This function is called with the estimated model and the randomly
selected data: <em class="xref py py-obj">is_model_valid(model, *random_data)</em>, .</p>
</dd>
<dt><strong>max_trials</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of iterations for random sample selection.</p>
</dd>
<dt><strong>stop_sample_num</strong><span class="classifier">int, optional</span></dt><dd><p>Stop iteration if at least this number of inliers are found.</p>
</dd>
<dt><strong>stop_residuals_sum</strong><span class="classifier">float, optional</span></dt><dd><p>Stop iteration if sum of residuals is less than or equal to this
threshold.</p>
</dd>
<dt><strong>stop_probability</strong><span class="classifier">float in range [0, 1], optional</span></dt><dd><p>RANSAC iteration stops if at least one outlier-free set of the
training data is sampled with <code class="docutils literal notranslate"><span class="pre">probability</span> <span class="pre">&gt;=</span> <span class="pre">stop_probability</span></code>,
depending on the current best model’s inlier ratio and the number
of trials. This requires to generate at least N samples (trials):</p>
<blockquote>
<div><p>N &gt;= log(1 - probability) / log(1 - e**m)</p>
</div></blockquote>
<p>where the probability (confidence) is typically set to a high value
such as 0.99, e is the current fraction of inliers w.r.t. the
total number of samples, and m is the min_samples value.</p>
</dd>
<dt><strong>random_state</strong><span class="classifier">int, RandomState instance or None, optional</span></dt><dd><p>If int, random_state is the seed used by the random number generator;
If RandomState instance, random_state is the random number generator;
If None, the random number generator is the RandomState instance used
by <em class="xref py py-obj">np.random</em>.</p>
</dd>
<dt><strong>initial_inliers</strong><span class="classifier">array-like of bool, shape (N,), optional</span></dt><dd><p>Initial samples selection for model estimation</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>model</strong><span class="classifier">object</span></dt><dd><p>Best model with largest consensus set.</p>
</dd>
<dt><strong>inliers</strong><span class="classifier">(N, ) array</span></dt><dd><p>Boolean mask of inliers classified as <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="radbaf2717b1f-1"><span class="brackets">1</span></dt>
<dd><p>“RANSAC”, Wikipedia, <a class="reference external" href="https://en.wikipedia.org/wiki/RANSAC">https://en.wikipedia.org/wiki/RANSAC</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Generate ellipse data without tilt and add noise:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">xc</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">yc</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Add some faulty data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="mi">120</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="mi">130</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">140</span><span class="p">,</span> <span class="mi">130</span><span class="p">)</span>
</pre></div>
</div>
<p>Estimate ellipse model using all available data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">EllipseModel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>  
<span class="go">array([ 72.,  75.,  77.,  14.,   1.])</span>
</pre></div>
</div>
<p>Estimate ellipse model using RANSAC:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ransac_model</span><span class="p">,</span> <span class="n">inliers</span> <span class="o">=</span> <span class="n">ransac</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">EllipseModel</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">max_trials</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ransac_model</span><span class="o">.</span><span class="n">params</span><span class="p">))</span>
<span class="go">array([20., 30.,  5., 10.,  0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inliers</span> 
<span class="go">array([False, False, False, False,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">inliers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">40</span>
<span class="go">True</span>
</pre></div>
</div>
<p>RANSAC can be used to robustly estimate a geometric transformation. In this section,
we also show how to use a proportion of the total samples, rather than an absolute number.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">SimilarityTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model0</span> <span class="o">=</span> <span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">model0</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ratio</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># use half of the samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ratio</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="p">,</span> <span class="n">inliers</span> <span class="o">=</span> <span class="n">ransac</span><span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">),</span> <span class="n">SimilarityTransform</span><span class="p">,</span> <span class="n">min_samples</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">initial_inliers</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inliers</span>
<span class="go">array([False, False, False,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="regionprops">
<h2>regionprops<a class="headerlink" href="#regionprops" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.regionprops">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">regionprops</code><span class="sig-paren">(</span><em class="sig-param">label_image</em>, <em class="sig-param">intensity_image=None</em>, <em class="sig-param">cache=True</em>, <em class="sig-param">coordinates=None</em>, <em class="sig-param">*</em>, <em class="sig-param">extra_properties=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_regionprops.py#L867-L1159"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.regionprops" title="Permalink to this definition">¶</a></dt>
<dd><p>Measure properties of labeled image regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>label_image</strong><span class="classifier">(M, N[, P]) ndarray</span></dt><dd><p>Labeled input image. Labels with value 0 are ignored.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.14.1: </span>Previously, <code class="docutils literal notranslate"><span class="pre">label_image</span></code> was processed by <code class="docutils literal notranslate"><span class="pre">numpy.squeeze</span></code> and
so any number of singleton dimensions was allowed. This resulted in
inconsistent handling of images with singleton dimensions. To
recover the old behaviour, use
<code class="docutils literal notranslate"><span class="pre">regionprops(np.squeeze(label_image),</span> <span class="pre">...)</span></code>.</p>
</div>
</dd>
<dt><strong>intensity_image</strong><span class="classifier">(M, N[, P][, C]) ndarray, optional</span></dt><dd><p>Intensity (i.e., input) image with same size as labeled image, plus
optionally an extra dimension for multichannel data.
Default is None.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18.0: </span>The ability to provide an extra dimension for channels was added.</p>
</div>
</dd>
<dt><strong>cache</strong><span class="classifier">bool, optional</span></dt><dd><p>Determine whether to cache calculated properties. The computation is
much faster for cached properties, whereas the memory consumption
increases.</p>
</dd>
<dt><strong>coordinates</strong><span class="classifier">DEPRECATED</span></dt><dd><p>This argument is deprecated and will be removed in a future version
of scikit-image.</p>
<p>See <a class="reference internal" href="../user_guide/numpy_images.html#numpy-images-coordinate-conventions"><span class="std std-ref">Coordinate conventions</span></a>
for more details.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 0.16.0: </span>Use “rc” coordinates everywhere. It may be sufficient to call
<code class="docutils literal notranslate"><span class="pre">numpy.transpose</span></code> on your label image to get the same values as
0.15 and earlier. However, for some properties, the transformation
will be less trivial. For example, the new orientation is
<span class="math notranslate nohighlight">\(\frac{\pi}{2}\)</span> plus the old orientation.</p>
</div>
</dd>
<dt><strong>extra_properties</strong><span class="classifier">Iterable of callables</span></dt><dd><p>Add extra property computation functions that are not included with
skimage. The name of the property is derived from the function name,
the dtype is inferred by calling the function on a small sample.
If the name of an extra property clashes with the name of an existing
property the extra property wil not be visible and a UserWarning is
issued. A property computation function must take a region mask as its
first argument. If the property requires an intensity image, it must
accept the intensity image as the second argument.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>properties</strong><span class="classifier">list of RegionProperties</span></dt><dd><p>Each item describes one labeled region, and can be accessed using the
attributes listed below.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.label" title="skimage.measure.label"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The following properties can be accessed as attributes or keys:</p>
<dl>
<dt><strong>area</strong><span class="classifier">int</span></dt><dd><p>Number of pixels of the region.</p>
</dd>
<dt><strong>bbox</strong><span class="classifier">tuple</span></dt><dd><p>Bounding box <code class="docutils literal notranslate"><span class="pre">(min_row,</span> <span class="pre">min_col,</span> <span class="pre">max_row,</span> <span class="pre">max_col)</span></code>.
Pixels belonging to the bounding box are in the half-open interval
<code class="docutils literal notranslate"><span class="pre">[min_row;</span> <span class="pre">max_row)</span></code> and <code class="docutils literal notranslate"><span class="pre">[min_col;</span> <span class="pre">max_col)</span></code>.</p>
</dd>
<dt><strong>bbox_area</strong><span class="classifier">int</span></dt><dd><p>Number of pixels of bounding box.</p>
</dd>
<dt><strong>centroid</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code>.</p>
</dd>
<dt><strong>convex_area</strong><span class="classifier">int</span></dt><dd><p>Number of pixels of convex hull image, which is the smallest convex
polygon that encloses the region.</p>
</dd>
<dt><strong>convex_image</strong><span class="classifier">(H, J) ndarray</span></dt><dd><p>Binary convex hull image which has the same size as bounding box.</p>
</dd>
<dt><strong>coords</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Coordinate list <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> of the region.</p>
</dd>
<dt><strong>eccentricity</strong><span class="classifier">float</span></dt><dd><p>Eccentricity of the ellipse that has the same second-moments as the
region. The eccentricity is the ratio of the focal distance
(distance between focal points) over the major axis length.
The value is in the interval [0, 1).
When it is 0, the ellipse becomes a circle.</p>
</dd>
<dt><strong>equivalent_diameter</strong><span class="classifier">float</span></dt><dd><p>The diameter of a circle with the same area as the region.</p>
</dd>
<dt><strong>euler_number</strong><span class="classifier">int</span></dt><dd><p>Euler characteristic of the set of non-zero pixels.
Computed as number of connected components subtracted by number of
holes (input.ndim connectivity). In 3D, number of connected
components plus number of holes subtracted by number of tunnels.</p>
</dd>
<dt><strong>extent</strong><span class="classifier">float</span></dt><dd><p>Ratio of pixels in the region to pixels in the total bounding box.
Computed as <code class="docutils literal notranslate"><span class="pre">area</span> <span class="pre">/</span> <span class="pre">(rows</span> <span class="pre">*</span> <span class="pre">cols)</span></code></p>
</dd>
<dt><strong>feret_diameter_max</strong><span class="classifier">float</span></dt><dd><p>Maximum Feret’s diameter computed as the longest distance between
points around a region’s convex hull contour as determined by
<code class="docutils literal notranslate"><span class="pre">find_contours</span></code>. <a class="reference internal" href="#r4a29d8446b4f-5" id="id42">[5]</a></p>
</dd>
<dt><strong>filled_area</strong><span class="classifier">int</span></dt><dd><p>Number of pixels of the region will all the holes filled in. Describes
the area of the filled_image.</p>
</dd>
<dt><strong>filled_image</strong><span class="classifier">(H, J) ndarray</span></dt><dd><p>Binary region image with filled holes which has the same size as
bounding box.</p>
</dd>
<dt><strong>image</strong><span class="classifier">(H, J) ndarray</span></dt><dd><p>Sliced binary region image which has the same size as bounding box.</p>
</dd>
<dt><strong>inertia_tensor</strong><span class="classifier">ndarray</span></dt><dd><p>Inertia tensor of the region for the rotation around its mass.</p>
</dd>
<dt><strong>inertia_tensor_eigvals</strong><span class="classifier">tuple</span></dt><dd><p>The eigenvalues of the inertia tensor in decreasing order.</p>
</dd>
<dt><strong>intensity_image</strong><span class="classifier">ndarray</span></dt><dd><p>Image inside region bounding box.</p>
</dd>
<dt><strong>label</strong><span class="classifier">int</span></dt><dd><p>The label in the labeled input image.</p>
</dd>
<dt><strong>local_centroid</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code>, relative to region bounding
box.</p>
</dd>
<dt><strong>major_axis_length</strong><span class="classifier">float</span></dt><dd><p>The length of the major axis of the ellipse that has the same
normalized second central moments as the region.</p>
</dd>
<dt><strong>max_intensity</strong><span class="classifier">float</span></dt><dd><p>Value with the greatest intensity in the region.</p>
</dd>
<dt><strong>mean_intensity</strong><span class="classifier">float</span></dt><dd><p>Value with the mean intensity in the region.</p>
</dd>
<dt><strong>min_intensity</strong><span class="classifier">float</span></dt><dd><p>Value with the least intensity in the region.</p>
</dd>
<dt><strong>minor_axis_length</strong><span class="classifier">float</span></dt><dd><p>The length of the minor axis of the ellipse that has the same
normalized second central moments as the region.</p>
</dd>
<dt><strong>moments</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Spatial moments up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="n">row</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="n">col</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <em class="xref py py-obj">row</em>, <em class="xref py py-obj">col</em> coordinates of the region.</p>
</dd>
<dt><strong>moments_central</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Central moments (translation invariant) up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mu_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">row_c</span><span class="p">)</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">col_c</span><span class="p">)</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <em class="xref py py-obj">row</em>, <em class="xref py py-obj">col</em> coordinates of the region,
and <em class="xref py py-obj">row_c</em> and <em class="xref py py-obj">col_c</em> are the coordinates of the region’s centroid.</p>
</dd>
<dt><strong>moments_hu</strong><span class="classifier">tuple</span></dt><dd><p>Hu moments (translation, scale and rotation invariant).</p>
</dd>
<dt><strong>moments_normalized</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Normalized moments (translation and scale invariant) up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nu_ij</span> <span class="o">=</span> <span class="n">mu_ij</span> <span class="o">/</span> <span class="n">m_00</span><span class="o">^</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>where <em class="xref py py-obj">m_00</em> is the zeroth spatial moment.</p>
</dd>
<dt><strong>orientation</strong><span class="classifier">float</span></dt><dd><p>Angle between the 0th axis (rows) and the major
axis of the ellipse that has the same second moments as the region,
ranging from <em class="xref py py-obj">-pi/2</em> to <em class="xref py py-obj">pi/2</em> counter-clockwise.</p>
</dd>
<dt><strong>perimeter</strong><span class="classifier">float</span></dt><dd><p>Perimeter of object which approximates the contour as a line
through the centers of border pixels using a 4-connectivity.</p>
</dd>
<dt><strong>perimeter_crofton</strong><span class="classifier">float</span></dt><dd><p>Perimeter of object approximated by the Crofton formula in 4
directions.</p>
</dd>
<dt><strong>slice</strong><span class="classifier">tuple of slices</span></dt><dd><p>A slice to extract the object from the source image.</p>
</dd>
<dt><strong>solidity</strong><span class="classifier">float</span></dt><dd><p>Ratio of pixels in the region to pixels of the convex hull image.</p>
</dd>
<dt><strong>weighted_centroid</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> weighted with intensity
image.</p>
</dd>
<dt><strong>weighted_local_centroid</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code>, relative to region bounding
box, weighted with intensity image.</p>
</dd>
<dt><strong>weighted_moments</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Spatial moments of intensity image up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wm_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="n">row</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="n">col</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <em class="xref py py-obj">row</em>, <em class="xref py py-obj">col</em> coordinates of the region.</p>
</dd>
<dt><strong>weighted_moments_central</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Central moments (translation invariant) of intensity image up to
3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wmu_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">row_c</span><span class="p">)</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">col_c</span><span class="p">)</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <em class="xref py py-obj">row</em>, <em class="xref py py-obj">col</em> coordinates of the region,
and <em class="xref py py-obj">row_c</em> and <em class="xref py py-obj">col_c</em> are the coordinates of the region’s weighted
centroid.</p>
</dd>
<dt><strong>weighted_moments_hu</strong><span class="classifier">tuple</span></dt><dd><p>Hu moments (translation, scale and rotation invariant) of intensity
image.</p>
</dd>
<dt><strong>weighted_moments_normalized</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Normalized moments (translation and scale invariant) of intensity
image up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wnu_ij</span> <span class="o">=</span> <span class="n">wmu_ij</span> <span class="o">/</span> <span class="n">wm_00</span><span class="o">^</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">wm_00</span></code> is the zeroth spatial moment (intensity-weighted area).</p>
</dd>
</dl>
<p>Each region also supports iteration, so that you can do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">region</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">region</span><span class="p">[</span><span class="n">prop</span><span class="p">])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4a29d8446b4f-1"><span class="brackets">1</span></dt>
<dd><p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</dd>
<dt class="label" id="r4a29d8446b4f-2"><span class="brackets">2</span></dt>
<dd><p>B. Jähne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</dd>
<dt class="label" id="r4a29d8446b4f-3"><span class="brackets">3</span></dt>
<dd><p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</dd>
<dt class="label" id="r4a29d8446b4f-4"><span class="brackets">4</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</dd>
<dt class="label" id="r4a29d8446b4f-5"><span class="brackets"><a class="fn-backref" href="#id42">5</a></span></dt>
<dd><p>W. Pabst, E. Gregorová. Characterization of particles and particle
systems, pp. 27-28. ICT Prague, 2007.
<a class="reference external" href="https://old.vscht.cz/sil/keramika/Characterization_of_particles/CPPS%20_English%20version_.pdf">https://old.vscht.cz/sil/keramika/Characterization_of_particles/CPPS%20_English%20version_.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">label</span><span class="p">,</span> <span class="n">regionprops</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">110</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_img</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">label_img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># centroid of first labeled object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>
<span class="go">(22.72987986048314, 81.91228523446583)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># centroid of first labeled object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;centroid&#39;</span><span class="p">]</span>
<span class="go">(22.72987986048314, 81.91228523446583)</span>
</pre></div>
</div>
<p>Add custom measurements by passing functions as <code class="docutils literal notranslate"><span class="pre">extra_properties</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">label</span><span class="p">,</span> <span class="n">regionprops</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">110</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_img</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pixelcount</span><span class="p">(</span><span class="n">regionmask</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">regionmask</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">label_img</span><span class="p">,</span> <span class="n">extra_properties</span><span class="o">=</span><span class="p">(</span><span class="n">pixelcount</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pixelcount</span>
<span class="go">7741</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;pixelcount&#39;</span><span class="p">]</span>
<span class="go">42</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-measure-regionprops">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.measure.regionprops</span></code><a class="headerlink" href="#examples-using-skimage-measure-regionprops" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima..."><div class="figure align-default" id="id60">
<img alt="Measure region properties" src="../_images/sphx_glr_plot_regionprops_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></span><a class="headerlink" href="#id60" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="regionprops-table">
<h2>regionprops_table<a class="headerlink" href="#regionprops-table" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.regionprops_table">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">regionprops_table</code><span class="sig-paren">(</span><em class="sig-param">label_image</em>, <em class="sig-param">intensity_image=None</em>, <em class="sig-param">properties=('label'</em>, <em class="sig-param">'bbox')</em>, <em class="sig-param">*</em>, <em class="sig-param">cache=True</em>, <em class="sig-param">separator='-'</em>, <em class="sig-param">extra_properties=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_regionprops.py#L705-L864"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.regionprops_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute image properties and return them as a pandas-compatible table.</p>
<p>The table is a dictionary mapping column names to value arrays. See Notes
section below for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.16.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>label_image</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Labeled input image. Labels with value 0 are ignored.</p>
</dd>
<dt><strong>intensity_image</strong><span class="classifier">(M, N[, P][, C]) ndarray, optional</span></dt><dd><p>Intensity (i.e., input) image with same size as labeled image, plus
optionally an extra dimension for multichannel data.
Default is None.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18.0: </span>The ability to provide an extra dimension for channels was added.</p>
</div>
</dd>
<dt><strong>properties</strong><span class="classifier">tuple or list of str, optional</span></dt><dd><p>Properties that will be included in the resulting dictionary
For a list of available properties, please see <a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><code class="xref py py-func docutils literal notranslate"><span class="pre">regionprops()</span></code></a>.
Users should remember to add “label” to keep track of region
identities.</p>
</dd>
<dt><strong>cache</strong><span class="classifier">bool, optional</span></dt><dd><p>Determine whether to cache calculated properties. The computation is
much faster for cached properties, whereas the memory consumption
increases.</p>
</dd>
<dt><strong>separator</strong><span class="classifier">str, optional</span></dt><dd><p>For non-scalar properties not listed in OBJECT_COLUMNS, each element
will appear in its own column, with the index of that element separated
from the property name by this separator. For example, the inertia
tensor of a 2D region will appear in four columns:
<code class="docutils literal notranslate"><span class="pre">inertia_tensor-0-0</span></code>, <code class="docutils literal notranslate"><span class="pre">inertia_tensor-0-1</span></code>, <code class="docutils literal notranslate"><span class="pre">inertia_tensor-1-0</span></code>,
and <code class="docutils literal notranslate"><span class="pre">inertia_tensor-1-1</span></code> (where the separator is <code class="docutils literal notranslate"><span class="pre">-</span></code>).</p>
<p>Object columns are those that cannot be split in this way because the
number of columns would change depending on the object. For example,
<code class="docutils literal notranslate"><span class="pre">image</span></code> and <code class="docutils literal notranslate"><span class="pre">coords</span></code>.</p>
</dd>
<dt><strong>extra_properties</strong><span class="classifier">Iterable of callables</span></dt><dd><p>Add extra property computation functions that are not included with
skimage. The name of the property is derived from the function name,
the dtype is inferred by calling the function on a small sample.
If the name of an extra property clashes with the name of an existing
property the extra property wil not be visible and a UserWarning is
issued. A property computation function must take a region mask as its
first argument. If the property requires an intensity image, it must
accept the intensity image as the second argument.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out_dict</strong><span class="classifier">dict</span></dt><dd><p>Dictionary mapping property names to an array of values of that
property, one value per region. This dictionary can be used as input to
pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> to map property names to columns in the frame and
regions to rows. If the image has no regions,
the arrays will have length 0, but the correct type.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Each column contains either a scalar property, an object property, or an
element in a multidimensional array.</p>
<p>Properties with scalar values for each region, such as “eccentricity”, will
appear as a float or int array with that property name as key.</p>
<p>Multidimensional properties <em>of fixed size</em> for a given image dimension,
such as “centroid” (every centroid will have three elements in a 3D image,
no matter the region size), will be split into that many columns, with the
name {property_name}{separator}{element_num} (for 1D properties),
{property_name}{separator}{elem_num0}{separator}{elem_num1} (for 2D
properties), and so on.</p>
<p>For multidimensional properties that don’t have a fixed size, such as
“image” (the image of a region varies in size depending on the region
size), an object array will be used, with the corresponding property name
as the key.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span><span class="p">,</span> <span class="n">measure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_image</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">image</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops_table</span><span class="p">(</span><span class="n">label_image</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;inertia_tensor&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="s1">&#39;inertia_tensor_eigvals&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span>  
<span class="go">{&#39;label&#39;: array([ 1,  2, ...]), ...</span>
<span class="go"> &#39;inertia_tensor-0-0&#39;: array([  4.012...e+03,   8.51..., ...]), ...</span>
<span class="go"> ...,</span>
<span class="go"> &#39;inertia_tensor_eigvals-1&#39;: array([  2.67...e+02,   2.83..., ...])}</span>
</pre></div>
</div>
<p>The resulting dictionary can be directly passed to pandas, if installed, to
obtain a clean DataFrame:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">props</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>  
<span class="go">   label  inertia_tensor-0-0  ...  inertia_tensor_eigvals-1</span>
<span class="go">0      1         4012.909888  ...                267.065503</span>
<span class="go">1      2            8.514739  ...                  2.834806</span>
<span class="go">2      3            0.666667  ...                  0.000000</span>
<span class="go">3      4            0.000000  ...                  0.000000</span>
<span class="go">4      5            0.222222  ...                  0.111111</span>
</pre></div>
</div>
<p>[5 rows x 7 columns]</p>
<p>If we want to measure a feature that does not come as a built-in
property, we can define custom functions and pass them as
<code class="docutils literal notranslate"><span class="pre">extra_properties</span></code>. For example, we can create a custom function
that measures the intensity quartiles in a region:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span><span class="p">,</span> <span class="n">measure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">quartiles</span><span class="p">(</span><span class="n">regionmask</span><span class="p">,</span> <span class="n">intensity</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">intensity</span><span class="p">[</span><span class="n">regionmask</span><span class="p">],</span> <span class="n">q</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_image</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">image</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops_table</span><span class="p">(</span><span class="n">label_image</span><span class="p">,</span> <span class="n">intensity_image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="n">properties</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,),</span>
<span class="gp">... </span>                                  <span class="n">extra_properties</span><span class="o">=</span><span class="p">(</span><span class="n">quartiles</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">props</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span> 
<span class="go">       label  quartiles-0  quartiles-1  quartiles-2</span>
<span class="go">0      1       117.00        123.0        130.0</span>
<span class="go">1      2       111.25        112.0        114.0</span>
<span class="go">2      3       111.00        111.0        111.0</span>
<span class="go">3      4       111.00        111.5        112.5</span>
<span class="go">4      5       112.50        113.0        114.0</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-measure-regionprops-table">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.measure.regionprops_table</span></code><a class="headerlink" href="#examples-using-skimage-measure-regionprops-table" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima..."><div class="figure align-default" id="id61">
<img alt="Measure region properties" src="../_images/sphx_glr_plot_regionprops_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></span><a class="headerlink" href="#id61" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="shannon-entropy">
<h2>shannon_entropy<a class="headerlink" href="#shannon-entropy" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.shannon_entropy">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">shannon_entropy</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">base=2</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/entropy.py#L5-L41"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.shannon_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Shannon entropy of an image.</p>
<p>The Shannon entropy is defined as S = -sum(pk * log(pk)),
where pk are frequency/probability of pixels of value k.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>base</strong><span class="classifier">float, optional</span></dt><dd><p>The logarithmic base to use.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>entropy</strong><span class="classifier">float</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The returned value is measured in bits or shannon (Sh) for base=2, natural
unit (nat) for base=np.e and hartley (Hart) for base=10.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd3de3b6e4b40-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">https://en.wikipedia.org/wiki/Entropy_(information_theory)</a></p>
</dd>
<dt class="label" id="rd3de3b6e4b40-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wiktionary.org/wiki/Shannon_entropy">https://en.wiktionary.org/wiki/Shannon_entropy</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">shannon_entropy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shannon_entropy</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="go">7.231695011055706</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="subdivide-polygon">
<h2>subdivide_polygon<a class="headerlink" href="#subdivide-polygon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.subdivide_polygon">
<code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">subdivide_polygon</code><span class="sig-paren">(</span><em class="sig-param">coords</em>, <em class="sig-param">degree=2</em>, <em class="sig-param">preserve_ends=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_polygon.py#L109-L168"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.subdivide_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivision of polygonal curves using B-Splines.</p>
<p>Note that the resulting curve is always within the convex hull of the
original polygon. Circular polygons stay closed after subdivision.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Coordinate array.</p>
</dd>
<dt><strong>degree</strong><span class="classifier">{1, 2, 3, 4, 5, 6, 7}, optional</span></dt><dd><p>Degree of B-Spline. Default is 2.</p>
</dd>
<dt><strong>preserve_ends</strong><span class="classifier">bool, optional</span></dt><dd><p>Preserve first and last coordinate of non-circular polygon. Default is
False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(M, 2) array</span></dt><dd><p>Subdivided coordinate array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r13f3ce062a97-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf">http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf</a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="circlemodel">
<h2><a class="reference internal" href="#skimage.measure.CircleModel" title="skimage.measure.CircleModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CircleModel</span></code></a><a class="headerlink" href="#circlemodel" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.measure.CircleModel">
<em class="property">class </em><code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">CircleModel</code><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L221-L347"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.CircleModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.measure.fit.BaseModel</span></code></p>
<p>Total least squares estimator for 2D circles.</p>
<p>The functional model of the circle is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">yc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>This estimator minimizes the squared distances from all points to the
circle:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">min</span><span class="p">{</span> <span class="nb">sum</span><span class="p">((</span><span class="n">r</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">x_i</span> <span class="o">-</span> <span class="n">xc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y_i</span> <span class="o">-</span> <span class="n">yc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>A minimum number of 3 points is required to solve for the parameters.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xy</span> <span class="o">=</span> <span class="n">CircleModel</span><span class="p">()</span><span class="o">.</span><span class="n">predict_xy</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">CircleModel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">(2.0, 3.0, 4.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">residuals</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="go">array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,</span>
<span class="go">       0., 0., 0., 0., 0., 0., 0., 0.])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">tuple</span></dt><dd><p>Circle model parameters in the following order <em class="xref py py-obj">xc</em>, <em class="xref py py-obj">yc</em>, <em class="xref py py-obj">r</em>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="skimage.measure.CircleModel.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L26-L27"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.CircleModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.CircleModel.estimate">
<code class="sig-name descname">estimate</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L256-L295"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.CircleModel.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate circle model from data using total least squares.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(N, 2) array</span></dt><dd><p>N points with <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> coordinates, respectively.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.CircleModel.predict_xy">
<code class="sig-name descname">predict_xy</code><span class="sig-paren">(</span><em class="sig-param">t</em>, <em class="sig-param">params=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L323-L347"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.CircleModel.predict_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict x- and y-coordinates using the estimated model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">array</span></dt><dd><p>Angles in circle in radians. Angles start to count from positive
x-axis to positive y-axis in a right-handed system.</p>
</dd>
<dt><strong>params</strong><span class="classifier">(3, ) array, optional</span></dt><dd><p>Optional custom parameter set.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xy</strong><span class="classifier">(…, 2) array</span></dt><dd><p>Predicted x- and y-coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.CircleModel.residuals">
<code class="sig-name descname">residuals</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L297-L321"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.CircleModel.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine residuals of data to model.</p>
<p>For each point the shortest distance to the circle is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(N, 2) array</span></dt><dd><p>N points with <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> coordinates, respectively.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N, ) array</span></dt><dd><p>Residual for each data point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="ellipsemodel">
<h2><a class="reference internal" href="#skimage.measure.EllipseModel" title="skimage.measure.EllipseModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">EllipseModel</span></code></a><a class="headerlink" href="#ellipsemodel" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.measure.EllipseModel">
<em class="property">class </em><code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">EllipseModel</code><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L350-L578"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.EllipseModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.measure.fit.BaseModel</span></code></p>
<p>Total least squares estimator for 2D ellipses.</p>
<p>The functional model of the ellipse is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xt</span> <span class="o">=</span> <span class="n">xc</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">yt</span> <span class="o">=</span> <span class="n">yc</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">xt</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">yt</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">(xt,</span> <span class="pre">yt)</span></code> is the closest point on the ellipse to <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code>. Thus
d is the shortest distance from the point to the ellipse.</p>
<p>The estimator is based on a least squares minimization. The optimal
solution is computed directly, no iterations are required. This leads
to a simple, stable and robust fitting method.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">params</span></code> attribute contains the parameters in the following order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">theta</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xy</span> <span class="o">=</span> <span class="n">EllipseModel</span><span class="p">()</span><span class="o">.</span><span class="n">predict_xy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span>
<span class="gp">... </span>                               <span class="n">params</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">30</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ellipse</span> <span class="o">=</span> <span class="n">EllipseModel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ellipse</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ellipse</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([10.  , 15.  ,  4.  ,  8.  ,  0.52])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">ellipse</span><span class="o">.</span><span class="n">residuals</span><span class="p">(</span><span class="n">xy</span><span class="p">)),</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,</span>
<span class="go">       0., 0., 0., 0., 0., 0., 0., 0.])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">tuple</span></dt><dd><p>Ellipse model parameters in the following order <em class="xref py py-obj">xc</em>, <em class="xref py py-obj">yc</em>, <em class="xref py py-obj">a</em>, <em class="xref py py-obj">b</em>,
<em class="xref py py-obj">theta</em>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="skimage.measure.EllipseModel.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L26-L27"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.EllipseModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.EllipseModel.estimate">
<code class="sig-name descname">estimate</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L391-L483"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.EllipseModel.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate circle model from data using total least squares.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(N, 2) array</span></dt><dd><p>N points with <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> coordinates, respectively.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb82f40f15f1b-1"><span class="brackets">1</span></dt>
<dd><p>Halir, R.; Flusser, J. “Numerically stable direct least squares
fitting of ellipses”. In Proc. 6th International Conference in
Central Europe on Computer Graphics and Visualization.
WSCG (Vol. 98, pp. 125-132).</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.EllipseModel.predict_xy">
<code class="sig-name descname">predict_xy</code><span class="sig-paren">(</span><em class="sig-param">t</em>, <em class="sig-param">params=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L547-L578"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.EllipseModel.predict_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict x- and y-coordinates using the estimated model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">array</span></dt><dd><p>Angles in circle in radians. Angles start to count from positive
x-axis to positive y-axis in a right-handed system.</p>
</dd>
<dt><strong>params</strong><span class="classifier">(5, ) array, optional</span></dt><dd><p>Optional custom parameter set.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xy</strong><span class="classifier">(…, 2) array</span></dt><dd><p>Predicted x- and y-coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.EllipseModel.residuals">
<code class="sig-name descname">residuals</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L485-L545"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.EllipseModel.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine residuals of data to model.</p>
<p>For each point the shortest distance to the ellipse is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(N, 2) array</span></dt><dd><p>N points with <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> coordinates, respectively.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N, ) array</span></dt><dd><p>Residual for each data point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="linemodelnd">
<h2><a class="reference internal" href="#skimage.measure.LineModelND" title="skimage.measure.LineModelND"><code class="xref py py-class docutils literal notranslate"><span class="pre">LineModelND</span></code></a><a class="headerlink" href="#linemodelnd" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.measure.LineModelND">
<em class="property">class </em><code class="sig-prename descclassname">skimage.measure.</code><code class="sig-name descname">LineModelND</code><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L30-L218"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.LineModelND" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.measure.fit.BaseModel</span></code></p>
<p>Total least squares estimator for N-dimensional lines.</p>
<p>In contrast to ordinary least squares line estimation, this estimator
minimizes the orthogonal distances of points to the estimated line.</p>
<p>Lines are defined by a point (origin) and a unit vector (direction)
according to the following vector equation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">origin</span> <span class="o">+</span> <span class="k">lambda</span> <span class="o">*</span> <span class="n">direction</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lm</span> <span class="o">=</span> <span class="n">LineModelND</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lm</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">(array([1.5 , 5.25]), array([0.5547 , 0.83205]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">lm</span><span class="o">.</span><span class="n">residuals</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="go">array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,</span>
<span class="go">       0., 0., 0., 0., 0., 0., 0., 0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">predict_y</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="mi">5</span><span class="p">]),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([4.5  , 4.562, 4.625, 4.688, 4.75 ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">predict_x</span><span class="p">(</span><span class="n">y</span><span class="p">[:</span><span class="mi">5</span><span class="p">]),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([1.   , 1.042, 1.083, 1.125, 1.167])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">tuple</span></dt><dd><p>Line model parameters in the following order <em class="xref py py-obj">origin</em>, <em class="xref py py-obj">direction</em>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="skimage.measure.LineModelND.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L26-L27"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.LineModelND.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.LineModelND.estimate">
<code class="sig-name descname">estimate</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L66-L101"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.LineModelND.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate line model from data.</p>
<p>This minimizes the sum of shortest (orthogonal) distances
from the given data points to the estimated line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(N, dim) array</span></dt><dd><p>N points in a space of dimensionality dim &gt;= 2.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.LineModelND.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">params=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L134-L172"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.LineModelND.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict intersection of the estimated line model with a hyperplane
orthogonal to a given axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">(n, 1) array</span></dt><dd><p>Coordinates along an axis.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>Axis orthogonal to the hyperplane intersecting the line.</p>
</dd>
<dt><strong>params</strong><span class="classifier">(2, ) array, optional</span></dt><dd><p>Optional custom parameter set in the form (<em class="xref py py-obj">origin</em>, <em class="xref py py-obj">direction</em>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(n, m) array</span></dt><dd><p>Predicted coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If the line is parallel to the given axis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.LineModelND.predict_x">
<code class="sig-name descname">predict_x</code><span class="sig-paren">(</span><em class="sig-param">y</em>, <em class="sig-param">params=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L174-L195"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.LineModelND.predict_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict x-coordinates for 2D lines using the estimated model.</p>
<p>Alias for:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">predict</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">array</span></dt><dd><p>y-coordinates.</p>
</dd>
<dt><strong>params</strong><span class="classifier">(2, ) array, optional</span></dt><dd><p>Optional custom parameter set in the form (<em class="xref py py-obj">origin</em>, <em class="xref py py-obj">direction</em>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array</span></dt><dd><p>Predicted x-coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.LineModelND.predict_y">
<code class="sig-name descname">predict_y</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">params=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L197-L218"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.LineModelND.predict_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict y-coordinates for 2D lines using the estimated model.</p>
<p>Alias for:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array</span></dt><dd><p>x-coordinates.</p>
</dd>
<dt><strong>params</strong><span class="classifier">(2, ) array, optional</span></dt><dd><p>Optional custom parameter set in the form (<em class="xref py py-obj">origin</em>, <em class="xref py py-obj">direction</em>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">array</span></dt><dd><p>Predicted y-coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.LineModelND.residuals">
<code class="sig-name descname">residuals</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">params=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L103-L132"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.measure.LineModelND.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine residuals of data to model.</p>
<p>For each point, the shortest (orthogonal) distance to the line is
returned. It is obtained by projecting the data onto the line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(N, dim) array</span></dt><dd><p>N points in a space of dimension dim.</p>
</dd>
<dt><strong>params</strong><span class="classifier">(2, ) array, optional</span></dt><dd><p>Optional custom parameter set in the form (<em class="xref py py-obj">origin</em>, <em class="xref py py-obj">direction</em>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N, ) array</span></dt><dd><p>Residual for each data point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


        </div>
    </div>
    <div class="forum link" role="contentinfo">
	 
    </div>
    <div class="well footer" role="contentinfo">
        <small>
            &copy; Copyright the scikit-image development team.
            Created using <a href="https://getbootstrap.com/">Bootstrap</a> and <a href="https://www.sphinx-doc.org/">Sphinx</a>.
        </small>
    </div>
</body>
</html>
