



<!DOCTYPE html>
<html lang="en">
<head>
        <title>Module: segmentation.random_walker_segmentation &mdash; skimage v0.8.0 docs</title>
    
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../_static/css/custom.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
    
    <script src="http://code.jquery.com/jquery-latest.js"></script>
    <script src="../_static/js/bootstrap.min.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.8.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <link rel="top" title="skimage v0.8.0 docs" href="../index.html" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="shortcut icon" href="../_static/favicon.ico">
</head>
<body class="container">
    <a href="http://scikit-image.org" class="logo"><img src="../_static/img/logo.png" alt=""></a>
    <div class="clearfix"></div>
    <div class="navbar">
        <div class="navbar-inner">
            <ul class="nav">
                <li><a href="/">Home</a></li>
<li><a href="/docs/stable/install.html">Download</a></li>
<li><a href="/docs/dev/auto_examples">Gallery</a></li>
<li><a href="/docs/dev">Documentation</a></li>
<li><a href="https://github.com/scikit-image/scikit-image">Source</a></li>
            </ul>
            <form class="navbar-form pull-right" action="../search.html" method="get">
                <input type="text" class="search span3" name="q" placeholder="Search documentation ...">
                <input type="hidden" name="check_keywords" value="yes" >
                <input type="hidden" name="area" value="default" >
            </form>
        </div>
    </div>
    <div class="row">
        <div class="span9">
            
  <div class="section" id="module-skimage.segmentation.random_walker_segmentation">
<span id="module-segmentation-random-walker-segmentation"></span><h1>Module: <tt class="xref py py-mod docutils literal"><span class="pre">segmentation.random_walker_segmentation</span></tt><a class="headerlink" href="#module-skimage.segmentation.random_walker_segmentation" title="Permalink to this headline">¶</a></h1>
<p>Random walker segmentation algorithm</p>
<p>from <em>Random walks for image segmentation</em>, Leo Grady, IEEE Trans
Pattern Anal Mach Intell. 2006 Nov;28(11):1768-83.</p>
<p>Installing pyamg and using the &#8216;cg_mg&#8217; mode of random_walker improves
significantly the performance.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#skimage.segmentation.random_walker_segmentation.cg" title="skimage.segmentation.random_walker_segmentation.cg"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.random_walker_segmentation.cg</span></tt></a>(A,&nbsp;b)</td>
<td>Use Conjugate Gradient iteration to solve A x = b</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.segmentation.random_walker_segmentation.img_as_float" title="skimage.segmentation.random_walker_segmentation.img_as_float"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.random_walker_segmentation.img_as_float</span></tt></a>(image)</td>
<td>Convert an image to double-precision floating point format.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.segmentation.random_walker_segmentation.random_walker" title="skimage.segmentation.random_walker_segmentation.random_walker"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.random_walker_segmentation.random_walker</span></tt></a>(...)</td>
<td>Random walker algorithm for segmentation from markers.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.segmentation.random_walker_segmentation.rank_order" title="skimage.segmentation.random_walker_segmentation.rank_order"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.random_walker_segmentation.rank_order</span></tt></a>(image)</td>
<td>Return an image of the same shape where each pixel is the index of the pixel value in the ascending order of the unique values of <cite>image</cite>, aka the rank-order value.</td>
</tr>
</tbody>
</table>
<div class="section" id="cg">
<h2>cg<a class="headerlink" href="#cg" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.random_walker_segmentation.cg">
<tt class="descclassname">skimage.segmentation.random_walker_segmentation.</tt><tt class="descname">cg</tt><big>(</big><em>A</em>, <em>b</em>, <em>x0=None</em>, <em>tol=1e-05</em>, <em>maxiter=None</em>, <em>xtype=None</em>, <em>M=None</em>, <em>callback=None</em><big>)</big><a class="headerlink" href="#skimage.segmentation.random_walker_segmentation.cg" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Conjugate Gradient iteration to solve A x = b</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>A</strong> : {sparse matrix, dense matrix, LinearOperator}</p>
<blockquote>
<div><p>The real or complex N-by-N matrix of the linear system
<tt class="docutils literal"><span class="pre">A</span></tt> must represent a hermitian, positive definite matrix</p>
</div></blockquote>
<p><strong>b</strong> : {array, matrix}</p>
<blockquote>
<div><p>Right hand side of the linear system. Has shape (N,) or (N,1).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>x</strong> : {array, matrix}</p>
<blockquote>
<div><p>The converged solution.</p>
</div></blockquote>
<p><strong>info</strong> : integer</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>Provides convergence information:</dt>
<dd><p class="first last">0  : successful exit
&gt;0 : convergence to tolerance not achieved, number of iterations
&lt;0 : illegal input or breakdown</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="img-as-float">
<h2>img_as_float<a class="headerlink" href="#img-as-float" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.random_walker_segmentation.img_as_float">
<tt class="descclassname">skimage.segmentation.random_walker_segmentation.</tt><tt class="descname">img_as_float</tt><big>(</big><em>image</em>, <em>force_copy=False</em><big>)</big><a class="headerlink" href="#skimage.segmentation.random_walker_segmentation.img_as_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an image to double-precision floating point format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>force_copy</strong> : bool</p>
<blockquote>
<div><p>Force a copy of the data, irrespective of its current dtype.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray of float64</p>
<blockquote class="last">
<div><p>Output image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The range of a floating point image is [0.0, 1.0] or [-1.0, 1.0] when
converting from unsigned or signed datatypes, respectively.</p>
</dd></dl>

</div>
<div class="section" id="random-walker">
<h2>random_walker<a class="headerlink" href="#random-walker" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.random_walker_segmentation.random_walker">
<tt class="descclassname">skimage.segmentation.random_walker_segmentation.</tt><tt class="descname">random_walker</tt><big>(</big><em>data</em>, <em>labels</em>, <em>beta=130</em>, <em>mode='bf'</em>, <em>tol=0.001</em>, <em>copy=True</em>, <em>multichannel=False</em>, <em>return_full_prob=False</em>, <em>depth=1.0</em><big>)</big><a class="headerlink" href="#skimage.segmentation.random_walker_segmentation.random_walker" title="Permalink to this definition">¶</a></dt>
<dd><p>Random walker algorithm for segmentation from markers.</p>
<p>Random walker algorithm is implemented for gray-level or multichannel
images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>data</strong> : array_like</p>
<blockquote>
<div><p>Image to be segmented in phases. Gray-level <cite>data</cite> can be two- or
three-dimensional; multichannel data can be three- or four-
dimensional (multichannel=True) with the highest dimension denoting
channels. Data spacing is assumed isotropic unless depth keyword
argument is used.</p>
</div></blockquote>
<p><strong>labels</strong> : array of ints, of same shape as <cite>data</cite> without channels dimension</p>
<blockquote>
<div><p>Array of seed markers labeled with different positive integers
for different phases. Zero-labeled pixels are unlabeled pixels.
Negative labels correspond to inactive pixels that are not taken
into account (they are removed from the graph). If labels are not
consecutive integers, the labels array will be transformed so that
labels are consecutive. In the multichannel case, <cite>labels</cite> should have
the same shape as a single channel of <cite>data</cite>, i.e. without the final
dimension denoting channels.</p>
</div></blockquote>
<p><strong>beta</strong> : float</p>
<blockquote>
<div><p>Penalization coefficient for the random walker motion
(the greater <cite>beta</cite>, the more difficult the diffusion).</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;bf&#8217;, &#8216;cg_mg&#8217;, &#8216;cg&#8217;} (default: &#8216;bf&#8217;)</p>
<blockquote>
<div><p>Mode for solving the linear system in the random walker
algorithm.</p>
<ul class="simple">
<li>&#8216;bf&#8217; (brute force, default): an LU factorization of the Laplacian is
computed. This is fast for small images (&lt;1024x1024), but very slow
(due to the memory cost) and memory-consuming for big images (in 3-D
for example).</li>
<li>&#8216;cg&#8217; (conjugate gradient): the linear system is solved iteratively
using the Conjugate Gradient method from scipy.sparse.linalg. This is
less memory-consuming than the brute force method for large images,
but it is quite slow.</li>
<li>&#8216;cg_mg&#8217; (conjugate gradient with multigrid preconditioner): a
preconditioner is computed using a multigrid solver, then the
solution is computed with the Conjugate Gradient method.  This mode
requires that the pyamg module (<a class="reference external" href="http://code.google.com/p/pyamg/">http://code.google.com/p/pyamg/</a>) is
installed. For images of size &gt; 512x512, this is the recommended
(fastest) mode.</li>
</ul>
</div></blockquote>
<p><strong>tol</strong> : float</p>
<blockquote>
<div><p>tolerance to achieve when solving the linear system, in
cg&#8217; and &#8216;cg_mg&#8217; modes.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>If copy is False, the <cite>labels</cite> array will be overwritten with
the result of the segmentation. Use copy=False if you want to
save on memory.</p>
</div></blockquote>
<p><strong>multichannel</strong> : bool, default False</p>
<blockquote>
<div><p>If True, input data is parsed as multichannel data (see &#8216;data&#8217; above
for proper input format in this case)</p>
</div></blockquote>
<p><strong>return_full_prob</strong> : bool, default False</p>
<blockquote>
<div><p>If True, the probability that a pixel belongs to each of the labels
will be returned, instead of only the most likely label.</p>
</div></blockquote>
<p><strong>depth</strong> : float, default 1.</p>
<blockquote>
<div><p>Correction for non-isotropic voxel depths in 3D volumes.
Default (1.) implies isotropy.  This factor is derived as follows:
depth = (out-of-plane voxel spacing) / (in-plane voxel spacing), where
in-plane voxel spacing represents the first two spatial dimensions and
out-of-plane voxel spacing represents the third spatial dimension.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>output</strong> : ndarray</p>
<blockquote class="last">
<div><ul class="simple">
<li>If <cite>return_full_prob</cite> is False, array of ints of same shape as
<cite>data</cite>, in which each pixel has been labeled according to the marker
that reached the pixel first by anisotropic diffusion.</li>
<li>If <cite>return_full_prob</cite> is True, array of floats of shape
<cite>(nlabels, data.shape)</cite>. <cite>output[label_nb, i, j]</cite> is the probability
that label <cite>label_nb</cite> reaches the pixel <cite>(i, j)</cite> first.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="skimage.morphology.watershed.html#module-skimage.morphology.watershed" title="skimage.morphology.watershed"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.watershed</span></tt></a></dt>
<dd>watershed segmentation A segmentation algorithm based on mathematical morphology and &#8220;flooding&#8221; of regions from markers.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Multichannel inputs are scaled with all channel data combined. Ensure all
channels are separately normalized prior to running this algorithm.</p>
<p>The <cite>depth</cite> argument is specifically for certain types of 3-dimensional
volumes which, due to how they were acquired, have different spacing
along in-plane and out-of-plane dimensions. This is commonly encountered
in medical imaging. The <cite>depth</cite> argument corrects gradients calculated
along the third spatial dimension for the otherwise inherent assumption
that all points are equally spaced.</p>
<p>The algorithm was first proposed in <em>Random walks for image
segmentation</em>, Leo Grady, IEEE Trans Pattern Anal Mach Intell.
2006 Nov;28(11):1768-83.</p>
<p>The algorithm solves the diffusion equation at infinite times for
sources placed on markers of each phase in turn. A pixel is labeled with
the phase that has the greatest probability to diffuse first to the pixel.</p>
<p>The diffusion equation is solved by minimizing x.T L x for each phase,
where L is the Laplacian of the weighted graph of the image, and x is
the probability that a marker of the given phase arrives first at a pixel
by diffusion (x=1 on markers of the phase, x=0 on the other markers, and
the other coefficients are looked for). Each pixel is attributed the label
for which it has a maximal value of x. The Laplacian L of the image
is defined as:</p>
<blockquote>
<div><ul class="simple">
<li>L_ii = d_i, the number of neighbors of pixel i (the degree of i)</li>
<li>L_ij = -w_ij if i and j are adjacent pixels</li>
</ul>
</div></blockquote>
<p>The weight w_ij is a decreasing function of the norm of the local gradient.
This ensures that diffusion is easier between pixels of similar values.</p>
<p>When the Laplacian is decomposed into blocks of marked and unmarked
pixels:</p>
<div class="highlight-python"><pre>L = M B.T
    B A</pre>
</div>
<p>with first indices corresponding to marked pixels, and then to unmarked
pixels, minimizing x.T L x for one phase amount to solving:</p>
<div class="highlight-python"><pre>A x = - B x_m</pre>
</div>
<p>where x_m = 1 on markers of the given phase, and 0 on other markers.
This linear system is solved in the algorithm using a direct method for
small images, and an iterative method for larger images.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c">#Marker for first phase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="c">#Marker for second phase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_walker</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], dtype=int32)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="rank-order">
<h2>rank_order<a class="headerlink" href="#rank-order" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.random_walker_segmentation.rank_order">
<tt class="descclassname">skimage.segmentation.random_walker_segmentation.</tt><tt class="descname">rank_order</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#skimage.segmentation.random_walker_segmentation.rank_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an image of the same shape where each pixel is the
index of the pixel value in the ascending order of the unique
values of <cite>image</cite>, aka the rank-order value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image: ndarray</strong> :</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>labels: ndarray of type np.uint32, of shape image.shape</strong> :</p>
<blockquote>
<div><p>New array where each pixel has the rank-order value of the
corresponding pixel in <cite>image</cite>. Pixel values are between 0 and
n - 1, where n is the number of distinct unique values in
<cite>image</cite>.</p>
</div></blockquote>
<p><strong>original_values: 1-d ndarray</strong> :</p>
<blockquote class="last">
<div><p>Unique original values of <cite>image</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 4, 5],</span>
<span class="go">    [4, 4, 1],</span>
<span class="go">    [5, 1, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rank_order</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(array([[0, 1, 2],</span>
<span class="go">    [1, 1, 0],</span>
<span class="go">    [2, 0, 0]], dtype=uint32), array([1, 4, 5]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rank_order</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">(array([0, 1, 2, 1], dtype=uint32), array([-1. ,  2.5,  3.1]))</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


        </div>
        <div class="span3"><h4 class="sidebar-box-heading">Navigation</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <li><a href="../index.html">Documentation Home</a></li>
    </ul>
</div>
        <h4 class="sidebar-box-heading">Contents</h4>
        <div class="well sidebar-box toc">
            <ul class="nav nav-list">
<li><a class="reference internal" href="#">Module: <tt class="docutils literal"><span class="pre">segmentation.random_walker_segmentation</span></tt></a><ul class="nav nav-list">
<li><a class="reference internal" href="#cg">cg</a></li>
<li><a class="reference internal" href="#img-as-float">img_as_float</a></li>
<li><a class="reference internal" href="#random-walker">random_walker</a></li>
<li><a class="reference internal" href="#rank-order">rank_order</a></li>
</ul>
</li>
</ul>

        </div>

<h4 class="sidebar-box-heading">Versions</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <script src="../../dev/_static/docversions.js"></script>
        <script type="text/javascript">
            insert_version_links();
        </script>
    </ul>
</div>
        </div>
    </div>
    <div class="well footer">
        <small>
            &copy; Copyright the scikit-image development team.
            Created using <a href="http://twitter.github.com/bootstrap/">Bootstrap</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.
        </small>
    </div>
</body>
</html>