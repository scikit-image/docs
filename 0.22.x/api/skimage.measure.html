
<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>skimage.measure &#8212; skimage 0.22.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=ac02cc09edc035673794" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=61a4c737" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../_static/theme_overrides.css?v=4340df76" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=ac02cc09edc035673794" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794" />
  <script src="../_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=ac02cc09edc035673794"></script>

    <script src="../_static/documentation_options.js?v=25b4b00c"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/design-tabs.js?v=36754332"></script>
    <script data-domain="scikit-image.org" defer="defer" src="https://views.scientific-python.org/js/script.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'api/skimage.measure';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.14.1';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://scikit-image.org/docs/dev/_static/version_switcher.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '0.22.0';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = true;
        </script>
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="skimage.metrics" href="skimage.metrics.html" />
    <link rel="prev" title="skimage.io" href="skimage.io.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">
   

<a class="navbar-brand logo" href="https://scikit-image.org">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="scikit-image's logo, showing a snake's head overlayed with green and orange"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="scikit-image's logo, showing a snake's head overlayed with green and orange"/>`);</script>
  
  
    <p class="title logo__title">scikit-image</p>
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../user_guide/index.html">
                        User guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../auto_examples/index.html">
                        Examples
                      </a>
                    </li>
                

                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="api.html">
                        API reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../release_notes/index.html">
                        Release notes
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../development/index.html">
                        Development
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../about/index.html">
                        About
                      </a>
                    </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          
 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="versionswitcherbutton" type="button" role="button" class="version-switcher__button btn btn-sm navbar-btn dropdown-toggle" data-bs-toggle="dropdown" aria-haspopup="listbox" aria-controls="versionswitcherlist" aria-label="Version switcher list">
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="versionswitcherlist" class="version-switcher__menu dropdown-menu list-group-flush py-0" role="listbox" aria-labelledby="versionswitcherbutton">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/scikit-image/scikit-image" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/scikit-image/" title="PyPI" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-solid fa-box fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">
 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
    <label class="sidebar-toggle secondary-toggle" for="__secondary" tabindex="0">
      <span class="fa-solid fa-outdent"></span>
    </label>
  
</div>

    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../user_guide/index.html">
                        User guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../auto_examples/index.html">
                        Examples
                      </a>
                    </li>
                

                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="api.html">
                        API reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../release_notes/index.html">
                        Release notes
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../development/index.html">
                        Development
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../about/index.html">
                        About
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="versionswitcherbutton" type="button" role="button" class="version-switcher__button btn btn-sm navbar-btn dropdown-toggle" data-bs-toggle="dropdown" aria-haspopup="listbox" aria-controls="versionswitcherlist" aria-label="Version switcher list">
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="versionswitcherlist" class="version-switcher__menu dropdown-menu list-group-flush py-0" role="listbox" aria-labelledby="versionswitcherbutton">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/scikit-image/scikit-image" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/scikit-image/" title="PyPI" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-solid fa-box fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item"><nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="skimage.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.color.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.color</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.data.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.data</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.draw.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.draw</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.exposure.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.exposure</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.feature.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.feature</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.filters.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.filters</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.filters.rank.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.filters.rank</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.future.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.future</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.graph.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.graph</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.io.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.io</span></code></a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.measure</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.metrics.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.metrics</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.morphology.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.morphology</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.registration.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.registration</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.restoration.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.restoration</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.segmentation.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.segmentation</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.transform.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.transform</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="skimage.util.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.util</span></code></a></li>
</ul>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="api.html" class="nav-link">API reference</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><code...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="module-skimage.measure">
<span id="skimage-measure"></span><h1><a class="reference internal" href="#module-skimage.measure" title="skimage.measure"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.measure</span></code></a><a class="headerlink" href="#module-skimage.measure" title="Link to this heading">#</a></h1>
<table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.approximate_polygon" title="skimage.measure.approximate_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.approximate_polygon</span></code></a></p></td>
<td><p>Approximate a polygonal chain with the specified tolerance.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.block_reduce" title="skimage.measure.block_reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.block_reduce</span></code></a></p></td>
<td><p>Downsample image by applying function <em class="xref py py-obj">func</em> to local blocks.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.blur_effect" title="skimage.measure.blur_effect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.blur_effect</span></code></a></p></td>
<td><p>Compute a metric that indicates the strength of blur in an image (0 for no blur, 1 for maximal blur).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.centroid" title="skimage.measure.centroid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.centroid</span></code></a></p></td>
<td><p>Return the (weighted) centroid of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.euler_number" title="skimage.measure.euler_number"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.euler_number</span></code></a></p></td>
<td><p>Calculate the Euler characteristic in binary image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.find_contours" title="skimage.measure.find_contours"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.find_contours</span></code></a></p></td>
<td><p>Find iso-valued contours in a 2D array for a given level value.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.grid_points_in_poly" title="skimage.measure.grid_points_in_poly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.grid_points_in_poly</span></code></a></p></td>
<td><p>Test whether points on a specified grid are inside a polygon.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.inertia_tensor" title="skimage.measure.inertia_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.inertia_tensor</span></code></a></p></td>
<td><p>Compute the inertia tensor of the input image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.inertia_tensor_eigvals" title="skimage.measure.inertia_tensor_eigvals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.inertia_tensor_eigvals</span></code></a></p></td>
<td><p>Compute the eigenvalues of the inertia tensor of the image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.intersection_coeff" title="skimage.measure.intersection_coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.intersection_coeff</span></code></a></p></td>
<td><p>Fraction of a channel's segmented binary mask that overlaps with a second channel's segmented binary mask.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.label" title="skimage.measure.label"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.label</span></code></a></p></td>
<td><p>Label connected regions of an integer array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.manders_coloc_coeff" title="skimage.measure.manders_coloc_coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.manders_coloc_coeff</span></code></a></p></td>
<td><p>Manders' colocalization coefficient between two channels.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.manders_overlap_coeff" title="skimage.measure.manders_overlap_coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.manders_overlap_coeff</span></code></a></p></td>
<td><p>Manders' overlap coefficient</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.marching_cubes</span></code></a></p></td>
<td><p>Marching cubes algorithm to find surfaces in 3d volumetric data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.mesh_surface_area</span></code></a></p></td>
<td><p>Compute surface area, given vertices and triangular faces.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.moments" title="skimage.measure.moments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.moments</span></code></a></p></td>
<td><p>Calculate all raw image moments up to a certain order.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.moments_central" title="skimage.measure.moments_central"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.moments_central</span></code></a></p></td>
<td><p>Calculate all central image moments up to a certain order.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.moments_coords" title="skimage.measure.moments_coords"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.moments_coords</span></code></a></p></td>
<td><p>Calculate all raw image moments up to a certain order.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.moments_coords_central" title="skimage.measure.moments_coords_central"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.moments_coords_central</span></code></a></p></td>
<td><p>Calculate all central image moments up to a certain order.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.moments_hu" title="skimage.measure.moments_hu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.moments_hu</span></code></a></p></td>
<td><p>Calculate Hu's set of image moments (2D-only).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.moments_normalized" title="skimage.measure.moments_normalized"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.moments_normalized</span></code></a></p></td>
<td><p>Calculate all normalized central image moments up to a certain order.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.pearson_corr_coeff" title="skimage.measure.pearson_corr_coeff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.pearson_corr_coeff</span></code></a></p></td>
<td><p>Calculate Pearson's Correlation Coefficient between pixel intensities in channels.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.perimeter" title="skimage.measure.perimeter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.perimeter</span></code></a></p></td>
<td><p>Calculate total perimeter of all objects in binary image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.perimeter_crofton" title="skimage.measure.perimeter_crofton"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.perimeter_crofton</span></code></a></p></td>
<td><p>Calculate total Crofton perimeter of all objects in binary image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.points_in_poly" title="skimage.measure.points_in_poly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.points_in_poly</span></code></a></p></td>
<td><p>Test whether points lie inside a polygon.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.profile_line" title="skimage.measure.profile_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.profile_line</span></code></a></p></td>
<td><p>Return the intensity profile of an image measured along a scan line.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.ransac" title="skimage.measure.ransac"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.ransac</span></code></a></p></td>
<td><p>Fit a model to data with the RANSAC (random sample consensus) algorithm.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.regionprops</span></code></a></p></td>
<td><p>Measure properties of labeled image regions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.regionprops_table" title="skimage.measure.regionprops_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.regionprops_table</span></code></a></p></td>
<td><p>Compute image properties and return them as a pandas-compatible table.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.shannon_entropy" title="skimage.measure.shannon_entropy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.shannon_entropy</span></code></a></p></td>
<td><p>Calculate the Shannon entropy of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.subdivide_polygon" title="skimage.measure.subdivide_polygon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.subdivide_polygon</span></code></a></p></td>
<td><p>Subdivision of polygonal curves using B-Splines.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.CircleModel" title="skimage.measure.CircleModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.CircleModel</span></code></a></p></td>
<td><p>Total least squares estimator for 2D circles.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.measure.EllipseModel" title="skimage.measure.EllipseModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.EllipseModel</span></code></a></p></td>
<td><p>Total least squares estimator for 2D ellipses.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.measure.LineModelND" title="skimage.measure.LineModelND"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.LineModelND</span></code></a></p></td>
<td><p>Total least squares estimator for N-dimensional lines.</p></td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.approximate_polygon">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">approximate_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_polygon.py#L5-L92"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.approximate_polygon" title="Link to this definition">#</a></dt>
<dd><p>Approximate a polygonal chain with the specified tolerance.</p>
<p>It is based on the Douglas-Peucker algorithm.</p>
<p>Note that the approximated polygon is always within the convex hull of the
original polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Coordinate array.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Maximum distance from original points of polygon to approximated
polygonal chain. If tolerance is 0, the original coordinate array
is returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(M, 2) array</span></dt><dd><p>Approximated polygonal chain where M &lt;= N.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rb46d085928c9-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm">https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm</a></p>
</div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to approximate (Douglas-Peucker algorithm) and subdivide (B-Splines) pol..."><img alt="" src="../_images/sphx_glr_plot_polygon_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_polygon.html#sphx-glr-auto-examples-edges-plot-polygon-py"><span class="std std-ref">Approximate and subdivide polygons</span></a></p>
  <div class="sphx-glr-thumbnail-title">Approximate and subdivide polygons</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.block_reduce">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">block_reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_size=2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func=&lt;function</span> <span class="pre">sum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func_kwargs=None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/block.py#L5-L91"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.block_reduce" title="Link to this definition">#</a></dt>
<dd><p>Downsample image by applying function <em class="xref py py-obj">func</em> to local blocks.</p>
<p>This function is useful for max and mean pooling, for example.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>N-dimensional input image.</p>
</dd>
<dt><strong>block_size</strong><span class="classifier">array_like or int</span></dt><dd><p>Array containing down-sampling integer factor along each axis.
Default block_size is 2.</p>
</dd>
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>Function object which is used to calculate the return value for each
local block. This function must implement an <code class="docutils literal notranslate"><span class="pre">axis</span></code> parameter.
Primary functions are <code class="docutils literal notranslate"><span class="pre">numpy.sum</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.min</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.max</span></code>,
<code class="docutils literal notranslate"><span class="pre">numpy.mean</span></code> and <code class="docutils literal notranslate"><span class="pre">numpy.median</span></code>.  See also <em class="xref py py-obj">func_kwargs</em>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float</span></dt><dd><p>Constant padding value if image is not perfectly divisible by the
block size.</p>
</dd>
<dt><strong>func_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Keyword arguments passed to <em class="xref py py-obj">func</em>. Notably useful for passing dtype
argument to <code class="docutils literal notranslate"><span class="pre">np.mean</span></code>. Takes dictionary of inputs, e.g.:
<code class="docutils literal notranslate"><span class="pre">func_kwargs={'dtype':</span> <span class="pre">np.float16})</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Down-sampled image with same number of dimensions as input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">block_reduce</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> 
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]],</span>
<span class="go">       [[12, 13, 14, 15],</span>
<span class="go">        [16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]],</span>
<span class="go">       [[24, 25, 26, 27],</span>
<span class="go">        [28, 29, 30, 31],</span>
<span class="go">        [32, 33, 34, 35]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_reduce</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
<span class="go">array([[[16., 17., 18., 19.]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max1</span> <span class="o">=</span> <span class="n">block_reduce</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max1</span> 
<span class="go">array([[[11]],</span>
<span class="go">       [[23]],</span>
<span class="go">       [[35]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max2</span> <span class="o">=</span> <span class="n">block_reduce</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max2</span> 
<span class="go">array([[[27],</span>
<span class="go">        [31],</span>
<span class="go">        [35]]])</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.blur_effect">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">blur_effect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h_size=11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel_axis=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_func=&lt;function</span> <span class="pre">max&gt;</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_blur_effect.py#L19-L89"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.blur_effect" title="Link to this definition">#</a></dt>
<dd><p>Compute a metric that indicates the strength of blur in an image
(0 for no blur, 1 for maximal blur).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>RGB or grayscale nD image. The input image is converted to grayscale
before computing the blur metric.</p>
</dd>
<dt><strong>h_size</strong><span class="classifier">int, optional</span></dt><dd><p>Size of the re-blurring filter.</p>
</dd>
<dt><strong>channel_axis</strong><span class="classifier">int or None, optional</span></dt><dd><p>If None, the image is assumed to be grayscale (single-channel).
Otherwise, this parameter indicates which axis of the array
corresponds to color channels.</p>
</dd>
<dt><strong>reduce_func</strong><span class="classifier">callable, optional</span></dt><dd><p>Function used to calculate the aggregation of blur metrics along all
axes. If set to None, the entire list is returned, where the i-th
element is the blur metric along the i-th axis.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>blur</strong><span class="classifier">float (0 to 1) or list of floats</span></dt><dd><p>Blur metric: by default, the maximum of blur metrics along all axes.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><em class="xref py py-obj">h_size</em> must keep the same value in order to compare results between
images. Most of the time, the default size (11) is enough. This means that
the metric can clearly discriminate blur up to an average 11x11 filter; if
blur is higher, the metric still gives good results but its values tend
towards an asymptote.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="reb5cfd250e5b-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Frederique Crete, Thierry Dolmiere, Patricia Ladret, and Marina
Nicolas “The blur effect: perception and estimation with a new
no-reference perceptual blur metric” Proc. SPIE 6492, Human Vision and
Electronic Imaging XII, 64920I (2007)
<a class="reference external" href="https://hal.archives-ouvertes.fr/hal-00232709">https://hal.archives-ouvertes.fr/hal-00232709</a>
<a class="reference external" href="https://doi.org/10.1117/12.702790">DOI:10.1117/12.702790</a></p>
</div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how the metric implemented in measure.blur_effect behaves, both as a functio..."><img alt="" src="../_images/sphx_glr_plot_blur_effect_thumb.png" />
<p><a class="reference internal" href="../auto_examples/filters/plot_blur_effect.html#sphx-glr-auto-examples-filters-plot-blur-effect-py"><span class="std std-ref">Estimate strength of blur</span></a></p>
  <div class="sphx-glr-thumbnail-title">Estimate strength of blur</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.centroid">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">centroid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_moments.py#L374-L401"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.centroid" title="Link to this definition">#</a></dt>
<dd><p>Return the (weighted) centroid of an image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>spacing: tuple of float, shape (ndim, )</strong></dt><dd><p>The pixel spacing along each axis of the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>center</strong><span class="classifier">tuple of float, length <code class="docutils literal notranslate"><span class="pre">image.ndim</span></code></span></dt><dd><p>The centroid of the (nonzero) pixels in <code class="docutils literal notranslate"><span class="pre">image</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">array([13.16666667, 13.16666667])</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In various image analysis situations, it is useful to think of the pixels of an image, or of a ..."><img alt="" src="../_images/sphx_glr_plot_pixel_graphs_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_pixel_graphs.html#sphx-glr-auto-examples-applications-plot-pixel-graphs-py"><span class="std std-ref">Use pixel graphs to find an object’s geodesic center</span></a></p>
  <div class="sphx-glr-thumbnail-title">Use pixel graphs to find an object's geodesic center</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.euler_number">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">euler_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_regionprops_utils.py#L59-L184"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.euler_number" title="Link to this definition">#</a></dt>
<dd><p>Calculate the Euler characteristic in binary image.</p>
<p>For 2D objects, the Euler number is the number of objects minus the number
of holes. For 3D objects, the Euler number is obtained as the number of
objects plus the number of holes, minus the number of tunnels, or loops.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image: (N, M) ndarray or (N, M, D) ndarray.</strong></dt><dd><p>2D or 3D images.
If image is not binary, all values strictly greater than zero
are considered as the object.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of orthogonal hops to consider a pixel/voxel
as a neighbor.
Accepted values are ranging from  1 to input.ndim. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a full
connectivity of <code class="docutils literal notranslate"><span class="pre">input.ndim</span></code> is used.
4 or 8 neighborhoods are defined for 2D images (connectivity 1 and 2,
respectively).
6 or 26 neighborhoods are defined for 3D images, (connectivity 1 and 3,
respectively). Connectivity 2 is not defined.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>euler_number</strong><span class="classifier">int</span></dt><dd><p>Euler characteristic of the set of all objects in the image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Euler characteristic is an integer number that describes the
topology of the set of all objects in the input image. If object is
4-connected, then background is 8-connected, and conversely.</p>
<p>The computation of the Euler characteristic is based on an integral
geometry formula in discretized space. In practice, a neighborhood
configuration is constructed, and a LUT is applied for each
configuration. The coefficients used are the ones of Ohser et al.</p>
<p>It can be useful to compute the Euler characteristic for several
connectivities. A large relative difference between results
for different connectivities suggests that the image resolution
(with respect to the size of objects and holes) is too low.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r0d660f9fa30f-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>S. Rivollier. Analyse d’image geometrique et morphometrique par
diagrammes de forme et voisinages adaptatifs generaux. PhD thesis,
2010. Ecole Nationale Superieure des Mines de Saint-Etienne.
<a class="reference external" href="https://tel.archives-ouvertes.fr/tel-00560838">https://tel.archives-ouvertes.fr/tel-00560838</a></p>
</div>
<div class="citation" id="r0d660f9fa30f-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Ohser J., Nagel W., Schladitz K. (2002) The Euler Number of
Discretized Sets - On the Choice of Adjacency in Homogeneous
Lattices. In: Mecke K., Stoyan D. (eds) Morphology of Condensed
Matter. Lecture Notes in Physics, vol 600. Springer, Berlin,
Heidelberg.</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAMPLE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAMPLE</span><span class="p">[</span><span class="mi">40</span><span class="p">:</span><span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">:</span><span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">:</span><span class="mi">60</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">euler_number</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">)</span> 
<span class="go">1...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAMPLE</span><span class="p">[</span><span class="mi">45</span><span class="p">:</span><span class="mi">55</span><span class="p">,</span><span class="mi">45</span><span class="p">:</span><span class="mi">55</span><span class="p">,</span><span class="mi">45</span><span class="p">:</span><span class="mi">55</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">euler_number</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">)</span> 
<span class="go">2...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAMPLE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">euler_number</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">)</span>  <span class="c1"># doctest:</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">euler_number</span><span class="p">(</span><span class="n">SAMPLE</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># doctest:</span>
<span class="go">2</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows an illustration of the computation of the Euler number [1]_ in 2D and 3D obj..."><img alt="" src="../_images/sphx_glr_plot_euler_number_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_euler_number.html#sphx-glr-auto-examples-segmentation-plot-euler-number-py"><span class="std std-ref">Euler number</span></a></p>
  <div class="sphx-glr-thumbnail-title">Euler number</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.find_contours">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">find_contours</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fully_connected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'low'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positive_orientation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'low'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_find_contours.py#L10-L152"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.find_contours" title="Link to this definition">#</a></dt>
<dd><p>Find iso-valued contours in a 2D array for a given level value.</p>
<p>Uses the “marching squares” method to compute a the iso-valued contours of
the input 2D array for a particular level value. Array values are linearly
interpolated to provide better precision for the output contours.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">2D ndarray of double</span></dt><dd><p>Input image in which to find contours.</p>
</dd>
<dt><strong>level</strong><span class="classifier">float, optional</span></dt><dd><p>Value along which to find contours in the array. By default, the level
is set to (max(image) + min(image)) / 2</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18: </span>This parameter is now optional.</p>
</div>
</dd>
<dt><strong>fully_connected</strong><span class="classifier">str, {‘low’, ‘high’}</span></dt><dd><p>Indicates whether array elements below the given level value are to be
considered fully-connected (and hence elements above the value will
only be face connected), or vice-versa. (See notes below for details.)</p>
</dd>
<dt><strong>positive_orientation</strong><span class="classifier">str, {‘low’, ‘high’}</span></dt><dd><p>Indicates whether the output contours will produce positively-oriented
polygons around islands of low- or high-valued elements. If ‘low’ then
contours will wind counter- clockwise around elements below the
iso-value. Alternately, this means that low-valued elements are always
on the left of the contour. (See below for details.)</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2D ndarray of bool, or None</span></dt><dd><p>A boolean mask, True where we want to draw contours.
Note that NaN values are always excluded from the considered region
(<code class="docutils literal notranslate"><span class="pre">mask</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> wherever <code class="docutils literal notranslate"><span class="pre">array</span></code> is <code class="docutils literal notranslate"><span class="pre">NaN</span></code>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>contours</strong><span class="classifier">list of (n,2)-ndarrays</span></dt><dd><p>Each contour is an ndarray of shape <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">2)</span></code>,
consisting of n <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">column)</span></code> coordinates along the contour.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.marching_cubes</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The marching squares algorithm is a special case of the marching cubes
algorithm <a class="reference internal" href="#r8ed60f468bf9-1" id="id5">[1]</a>.  A simple explanation is available here:</p>
<p><a class="reference external" href="http://users.polytech.unice.fr/~lingrand/MarchingCubes/algo.html">http://users.polytech.unice.fr/~lingrand/MarchingCubes/algo.html</a></p>
<p>There is a single ambiguous case in the marching squares algorithm: when
a given <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">x</span> <span class="pre">2</span></code>-element square has two high-valued and two low-valued
elements, each pair diagonally adjacent. (Where high- and low-valued is
with respect to the contour value sought.) In this case, either the
high-valued elements can be ‘connected together’ via a thin isthmus that
separates the low-valued elements, or vice-versa. When elements are
connected together across a diagonal, they are considered ‘fully
connected’ (also known as ‘face+vertex-connected’ or ‘8-connected’). Only
high-valued or low-valued elements can be fully-connected, the other set
will be considered as ‘face-connected’ or ‘4-connected’. By default,
low-valued elements are considered fully-connected; this can be altered
with the ‘fully_connected’ parameter.</p>
<p>Output contours are not guaranteed to be closed: contours which intersect
the array edge or a masked-off region (either where mask is False or where
array is NaN) will be left open. All other contours will be closed. (The
closed-ness of a contours can be tested by checking whether the beginning
point is the same as the end point.)</p>
<p>Contours are oriented. By default, array values lower than the contour
value are to the left of the contour and values greater than the contour
value are to the right. This means that contours will wind
counter-clockwise (i.e. in ‘positive orientation’) around islands of
low-valued pixels. This behavior can be altered with the
‘positive_orientation’ parameter.</p>
<p>The order of the contours in the output list is determined by the position
of the smallest <code class="docutils literal notranslate"><span class="pre">x,y</span></code> (in lexicographical order) coordinate in the
contour.  This is a side-effect of how the input array is traversed, but
can be relied upon.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Array coordinates/values are assumed to refer to the <em>center</em> of the
array element. Take a simple example input: <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>. The interpolated
position of 0.5 in this array is midway between the 0-element (at
<code class="docutils literal notranslate"><span class="pre">x=0</span></code>) and the 1-element (at <code class="docutils literal notranslate"><span class="pre">x=1</span></code>), and thus would fall at
<code class="docutils literal notranslate"><span class="pre">x=0.5</span></code>.</p>
</div>
<p>This means that to find reasonable contours, it is best to find contours
midway between the expected “light” and “dark” values. In particular,
given a binarized array, <em>do not</em> choose to find contours at the low or
high value of the array. This will often yield degenerate contours,
especially around structures that are a single array element wide. Instead
choose a middle value, as above.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r8ed60f468bf9-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">1</a><span class="fn-bracket">]</span></span>
<p>Lorensen, William and Harvey E. Cline. Marching Cubes: A High
Resolution 3D Surface Construction Algorithm. Computer Graphics
(SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170).
<a class="reference external" href="https://doi.org/10.1145/37401.37422">DOI:10.1145/37401.37422</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1., 0., 0.],</span>
<span class="go">       [0., 0., 0.],</span>
<span class="go">       [0., 0., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_contours</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">[array([[0. , 0.5],</span>
<span class="go">       [0.5, 0. ]])]</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="We use a marching squares method to find constant valued contours in an image. In skimage.measu..."><img alt="" src="../_images/sphx_glr_plot_contours_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_contours.html#sphx-glr-auto-examples-edges-plot-contours-py"><span class="std std-ref">Contour finding</span></a></p>
  <div class="sphx-glr-thumbnail-title">Contour finding</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to approximate (Douglas-Peucker algorithm) and subdivide (B-Splines) pol..."><img alt="" src="../_images/sphx_glr_plot_polygon_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_polygon.html#sphx-glr-auto-examples-edges-plot-polygon-py"><span class="std std-ref">Approximate and subdivide polygons</span></a></p>
  <div class="sphx-glr-thumbnail-title">Approximate and subdivide polygons</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima..."><img alt="" src="../_images/sphx_glr_plot_regionprops_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></p>
  <div class="sphx-glr-thumbnail-title">Measure region properties</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Optical coherence tomography (OCT) is a non-invasive imaging technique used by ophthalmologists..."><img alt="" src="../_images/sphx_glr_plot_cornea_spot_inpainting_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_cornea_spot_inpainting.html#sphx-glr-auto-examples-applications-plot-cornea-spot-inpainting-py"><span class="std std-ref">Restore spotted cornea image with inpainting</span></a></p>
  <div class="sphx-glr-thumbnail-title">Restore spotted cornea image with inpainting</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.grid_points_in_poly">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">grid_points_in_poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binarize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/pnpoly.py#L4-L43"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.grid_points_in_poly" title="Link to this definition">#</a></dt>
<dd><p>Test whether points on a specified grid are inside a polygon.</p>
<p>For each <code class="docutils literal notranslate"><span class="pre">(r,</span> <span class="pre">c)</span></code> coordinate on a grid, i.e. <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code>, <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1)</span></code> etc.,
test whether that point lies inside a polygon.</p>
<p>You can control the output type with the <em class="xref py py-obj">binarize</em> flag. Please refer to its
documentation for further details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>shape</strong><span class="classifier">tuple (M, N)</span></dt><dd><p>Shape of the grid.</p>
</dd>
<dt><strong>verts</strong><span class="classifier">(V, 2) array</span></dt><dd><p>Specify the V vertices of the polygon, sorted either clockwise
or anti-clockwise. The first point may (but does not need to be)
duplicated.</p>
</dd>
<dt><strong>binarize: bool</strong></dt><dd><p>If <em class="xref py py-obj">True</em>, the output of the function is a boolean mask.
Otherwise, it is a labeled array. The labels are:
O - outside, 1 - inside, 2 - vertex, 3 - edge.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mask</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>If <em class="xref py py-obj">binarize</em> is True, the output is a boolean mask. True means the
corresponding pixel falls inside the polygon.
If <em class="xref py py-obj">binarize</em> is False, the output is a labeled array, with pixels
having a label between 0 and 3. The meaning of the values is:
O - outside, 1 - inside, 2 - vertex, 3 - edge.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.points_in_poly" title="skimage.measure.points_in_poly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">points_in_poly</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.inertia_tensor">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">inertia_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_moments.py#L404-L455"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.inertia_tensor" title="Link to this definition">#</a></dt>
<dd><p>Compute the inertia tensor of the input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array, optional</span></dt><dd><p>The pre-computed central moments of <code class="docutils literal notranslate"><span class="pre">image</span></code>. The inertia tensor
computation requires the central moments of the image. If an
application requires both the central moments and the inertia tensor
(for example, <a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.regionprops</span></code></a>), then it is more
efficient to pre-compute them and pass them to the inertia tensor
call.</p>
</dd>
<dt><strong>spacing: tuple of float, shape (ndim, )</strong></dt><dd><p>The pixel spacing along each axis of the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>T</strong><span class="classifier">array, shape <code class="docutils literal notranslate"><span class="pre">(image.ndim,</span> <span class="pre">image.ndim)</span></code></span></dt><dd><p>The inertia tensor of the input image. <span class="math notranslate nohighlight">\(T_{i, j}\)</span> contains
the covariance of image intensity along axes <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rfbef8c192cf5-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Moment_of_inertia#Inertia_tensor">https://en.wikipedia.org/wiki/Moment_of_inertia#Inertia_tensor</a></p>
</div>
<div class="citation" id="rfbef8c192cf5-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Bernd Jähne. Spatio-Temporal Image Processing: Theory and
Scientific Applications. (Chapter 8: Tensor Methods) Springer, 1993.</p>
</div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.inertia_tensor_eigvals">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">inertia_tensor_eigvals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_moments.py#L458-L498"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.inertia_tensor_eigvals" title="Link to this definition">#</a></dt>
<dd><p>Compute the eigenvalues of the inertia tensor of the image.</p>
<p>The inertia tensor measures covariance of the image intensity along
the image axes. (See <a class="reference internal" href="#skimage.measure.inertia_tensor" title="skimage.measure.inertia_tensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inertia_tensor</span></code></a>.) The relative magnitude of the
eigenvalues of the tensor is thus a measure of the elongation of a
(bright) object in the image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array, optional</span></dt><dd><p>The pre-computed central moments of <code class="docutils literal notranslate"><span class="pre">image</span></code>.</p>
</dd>
<dt><strong>T</strong><span class="classifier">array, shape <code class="docutils literal notranslate"><span class="pre">(image.ndim,</span> <span class="pre">image.ndim)</span></code></span></dt><dd><p>The pre-computed inertia tensor. If <code class="docutils literal notranslate"><span class="pre">T</span></code> is given, <code class="docutils literal notranslate"><span class="pre">mu</span></code> and
<code class="docutils literal notranslate"><span class="pre">image</span></code> are ignored.</p>
</dd>
<dt><strong>spacing: tuple of float, shape (ndim, )</strong></dt><dd><p>The pixel spacing along each axis of the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>eigvals</strong><span class="classifier">list of float, length <code class="docutils literal notranslate"><span class="pre">image.ndim</span></code></span></dt><dd><p>The eigenvalues of the inertia tensor of <code class="docutils literal notranslate"><span class="pre">image</span></code>, in descending
order.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Computing the eigenvalues requires the inertia tensor of the input image.
This is much faster if the central moments (<code class="docutils literal notranslate"><span class="pre">mu</span></code>) are provided, or,
alternatively, one can provide the inertia tensor (<code class="docutils literal notranslate"><span class="pre">T</span></code>) directly.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.intersection_coeff">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">intersection_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image0_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image1_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_colocalization.py#L266-L303"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.intersection_coeff" title="Link to this definition">#</a></dt>
<dd><p>Fraction of a channel’s segmented binary mask that overlaps with a
second channel’s segmented binary mask.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image0_mask</strong><span class="classifier">(M, N) ndarray of dtype bool</span></dt><dd><p>Image mask of channel A.</p>
</dd>
<dt><strong>image1_mask</strong><span class="classifier">(M, N) ndarray of dtype bool</span></dt><dd><p>Image mask of channel B.
Must have same dimensions as <em class="xref py py-obj">image0_mask</em>.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">(M, N) ndarray of dtype bool, optional</span></dt><dd><p>Only <em class="xref py py-obj">image0_mask</em> and <em class="xref py py-obj">image1_mask</em> pixels within this region of
interest
mask are included in the calculation.
Must have same dimensions as <em class="xref py py-obj">image0_mask</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Intersection coefficient, float</dt><dd><p>Fraction of <em class="xref py py-obj">image0_mask</em> that overlaps with <em class="xref py py-obj">image1_mask</em>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In this example, we demonstrate the use of different metrics to assess the colocalization of tw..."><img alt="" src="../_images/sphx_glr_plot_colocalization_metrics_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_colocalization_metrics.html#sphx-glr-auto-examples-applications-plot-colocalization-metrics-py"><span class="std std-ref">Colocalization metrics</span></a></p>
  <div class="sphx-glr-thumbnail-title">Colocalization metrics</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.label">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">label</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_label.py#L32-L120"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.label" title="Link to this definition">#</a></dt>
<dd><p>Label connected regions of an integer array.</p>
<p>Two pixels are connected when they are neighbors and have the same value.
In 2D, they can be neighbors either in a 1- or 2-connected sense.
The value refers to the maximum number of orthogonal hops to consider a
pixel/voxel a neighbor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">-</span><span class="n">connectivity</span>     <span class="mi">2</span><span class="o">-</span><span class="n">connectivity</span>     <span class="n">diagonal</span> <span class="n">connection</span> <span class="n">close</span><span class="o">-</span><span class="n">up</span>

     <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>             <span class="p">[</span> <span class="p">]</span>
      <span class="o">|</span>               \  <span class="o">|</span>  <span class="o">/</span>                 <span class="o">|</span>  <span class="o">&lt;-</span> <span class="n">hop</span> <span class="mi">2</span>
<span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>      <span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>        <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>
      <span class="o">|</span>               <span class="o">/</span>  <span class="o">|</span>  \             <span class="n">hop</span> <span class="mi">1</span>
     <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label_image</strong><span class="classifier">ndarray of dtype int</span></dt><dd><p>Image to label.</p>
</dd>
<dt><strong>background</strong><span class="classifier">int, optional</span></dt><dd><p>Consider all pixels with this value as background pixels, and label
them as 0. By default, 0-valued pixels are considered as background
pixels.</p>
</dd>
<dt><strong>return_num</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to return the number of assigned labels.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of orthogonal hops to consider a pixel/voxel
as a neighbor.
Accepted values are ranging from  1 to input.ndim. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a full
connectivity of <code class="docutils literal notranslate"><span class="pre">input.ndim</span></code> is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">ndarray of dtype int</span></dt><dd><p>Labeled array, where all connected regions are assigned the
same integer value.</p>
</dd>
<dt><strong>num</strong><span class="classifier">int, optional</span></dt><dd><p>Number of labels, which equals the maximum label index and is only
returned if return_num is <em class="xref py py-obj">True</em>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regionprops</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.measure.regionprops_table" title="skimage.measure.regionprops_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regionprops_table</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r4c017a27ed0c-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Christophe Fiorio and Jens Gustedt, “Two linear time Union-Find
strategies for image processing”, Theoretical Computer Science
154 (1996), pp. 165-181.</p>
</div>
<div class="citation" id="r4c017a27ed0c-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Kensheng Wu, Ekow Otoo and Arie Shoshani, “Optimizing connected
component labeling algorithms”, Paper LBNL-56864, 2005,
Lawrence Berkeley National Laboratory (University of California),
<a class="reference external" href="http://repositories.cdlib.org/lbnl/LBNL-56864">http://repositories.cdlib.org/lbnl/LBNL-56864</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 1 0]</span>
<span class="go"> [0 0 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 2 0]</span>
<span class="go"> [0 0 3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 1 0]</span>
<span class="go"> [0 0 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">background</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1 2 2]</span>
<span class="go"> [2 1 2]</span>
<span class="go"> [2 2 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [1 1 2]</span>
<span class="go"> [0 0 0]]</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Given several connected components represented by a label image, these connected components can..."><img alt="" src="../_images/sphx_glr_plot_expand_labels_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_expand_labels.html#sphx-glr-auto-examples-segmentation-plot-expand-labels-py"><span class="std std-ref">Expand segmentation labels without overlap</span></a></p>
  <div class="sphx-glr-thumbnail-title">Expand segmentation labels without overlap</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to segment an image with image labelling. The following steps are applie..."><img alt="" src="../_images/sphx_glr_plot_label_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_label.html#sphx-glr-auto-examples-segmentation-plot-label-py"><span class="std std-ref">Label image regions</span></a></p>
  <div class="sphx-glr-thumbnail-title">Label image regions</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="When segmenting an image, you may want to combine multiple alternative segmentations. The :pysk..."><img alt="" src="../_images/sphx_glr_plot_join_segmentations_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_join_segmentations.html#sphx-glr-auto-examples-segmentation-plot-join-segmentations-py"><span class="std std-ref">Find the intersection of two segmentations</span></a></p>
  <div class="sphx-glr-thumbnail-title">Find the intersection of two segmentations</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="We detect local maxima in a galaxy image. The image is corrupted by noise, generating many loca..."><img alt="" src="../_images/sphx_glr_plot_extrema_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_extrema.html#sphx-glr-auto-examples-segmentation-plot-extrema-py"><span class="std std-ref">Extrema</span></a></p>
  <div class="sphx-glr-thumbnail-title">Extrema</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This toy example shows how to compute the size of every labelled region in a series of 10 image..."><img alt="" src="../_images/sphx_glr_plot_regionprops_table_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops_table.html#sphx-glr-auto-examples-segmentation-plot-regionprops-table-py"><span class="std std-ref">Explore and visualize region properties with pandas</span></a></p>
  <div class="sphx-glr-thumbnail-title">Explore and visualize region properties with pandas</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima..."><img alt="" src="../_images/sphx_glr_plot_regionprops_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></p>
  <div class="sphx-glr-thumbnail-title">Measure region properties</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows an illustration of the computation of the Euler number [1]_ in 2D and 3D obj..."><img alt="" src="../_images/sphx_glr_plot_euler_number_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_euler_number.html#sphx-glr-auto-examples-segmentation-plot-euler-number-py"><span class="std std-ref">Euler number</span></a></p>
  <div class="sphx-glr-thumbnail-title">Euler number</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="When trying out different segmentation methods, how do you know which one is best? If you have ..."><img alt="" src="../_images/sphx_glr_plot_metrics_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_metrics.html#sphx-glr-auto-examples-segmentation-plot-metrics-py"><span class="std std-ref">Evaluating segmentation metrics</span></a></p>
  <div class="sphx-glr-thumbnail-title">Evaluating segmentation metrics</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example, we analyze a microscopy image of human cells. We use data provided by Jason Mo..."><img alt="" src="../_images/sphx_glr_plot_human_mitosis_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_human_mitosis.html#sphx-glr-auto-examples-applications-plot-human-mitosis-py"><span class="std std-ref">Segment human cells (in mitosis)</span></a></p>
  <div class="sphx-glr-thumbnail-title">Segment human cells (in mitosis)</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example, we identify and track the solid-liquid (S-L) interface in a nickel-based alloy..."><img alt="" src="../_images/sphx_glr_plot_solidification_tracking_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_solidification_tracking.html#sphx-glr-auto-examples-applications-plot-solidification-tracking-py"><span class="std std-ref">Track solidification of a metallic alloy</span></a></p>
  <div class="sphx-glr-thumbnail-title">Track solidification of a metallic alloy</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.manders_coloc_coeff">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">manders_coloc_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image1_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_colocalization.py#L99-L178"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.manders_coloc_coeff" title="Link to this definition">#</a></dt>
<dd><p>Manders’ colocalization coefficient between two channels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image0</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Image of channel A. All pixel values should be non-negative.</p>
</dd>
<dt><strong>image1_mask</strong><span class="classifier">(M, N) ndarray of dtype bool</span></dt><dd><p>Binary mask with segmented regions of interest in channel B.
Must have same dimensions as <em class="xref py py-obj">image0</em>.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">(M, N) ndarray of dtype bool, optional</span></dt><dd><p>Only <em class="xref py py-obj">image0</em> pixel values within this region of interest mask are
included in the calculation.
Must have same dimensions as <em class="xref py py-obj">image0</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mcc</strong><span class="classifier">float</span></dt><dd><p>Manders’ colocalization coefficient.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Manders’ Colocalization Coefficient (MCC) is the fraction of total
intensity of a certain channel (channel A) that is within the segmented
region of a second channel (channel B) <a class="reference internal" href="#rf1b54f0e8577-1" id="id11">[1]</a>. It ranges from 0 for no
colocalisation to 1 for complete colocalization. It is also referred to
as M1 and M2.</p>
<p>MCC is commonly used to measure the colocalization of a particular protein
in a subceullar compartment. Typically a segmentation mask for channel B
is generated by setting a threshold that the pixel values must be above
to be included in the MCC calculation. In this implementation,
the channel B mask is provided as the argument <em class="xref py py-obj">image1_mask</em>, allowing
the exact segmentation method to be decided by the user beforehand.</p>
<p>The implemented equation is:</p>
<div class="math notranslate nohighlight">
\[r = \frac{\sum A_{i,coloc}}{\sum A_i}\]</div>
<dl class="simple">
<dt>where</dt><dd><p><span class="math notranslate nohighlight">\(A_i\)</span> is the value of the <span class="math notranslate nohighlight">\(i^{th}\)</span> pixel in <em class="xref py py-obj">image0</em>
<span class="math notranslate nohighlight">\(A_{i,coloc} = A_i\)</span> if <span class="math notranslate nohighlight">\(Bmask_i &gt; 0\)</span>
<span class="math notranslate nohighlight">\(Bmask_i\)</span> is the value of the <span class="math notranslate nohighlight">\(i^{th}\)</span> pixel in
<em class="xref py py-obj">mask</em></p>
</dd>
</dl>
<p>MCC is sensitive to noise, with diffuse signal in the first channel
inflating its value. Images should be processed to remove out of focus and
background light before the MCC is calculated <a class="reference internal" href="#rf1b54f0e8577-2" id="id12">[2]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rf1b54f0e8577-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">1</a><span class="fn-bracket">]</span></span>
<p>Manders, E.M.M., Verbeek, F.J. and Aten, J.A. (1993), Measurement of
co-localization of objects in dual-colour confocal images. Journal
of Microscopy, 169: 375-382.
<a class="reference external" href="https://doi.org/10.1111/j.1365-2818.1993.tb03313.x">https://doi.org/10.1111/j.1365-2818.1993.tb03313.x</a>
<a class="reference external" href="https://imagej.net/media/manders.pdf">https://imagej.net/media/manders.pdf</a></p>
</div>
<div class="citation" id="rf1b54f0e8577-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">2</a><span class="fn-bracket">]</span></span>
<p>Dunn, K. W., Kamocka, M. M., &amp; McDonald, J. H. (2011). A practical
guide to evaluating colocalization in biological microscopy.
American journal of physiology. Cell physiology, 300(4), C723–C742.
<a class="reference external" href="https://doi.org/10.1152/ajpcell.00462.2010">https://doi.org/10.1152/ajpcell.00462.2010</a></p>
</div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In this example, we demonstrate the use of different metrics to assess the colocalization of tw..."><img alt="" src="../_images/sphx_glr_plot_colocalization_metrics_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_colocalization_metrics.html#sphx-glr-auto-examples-applications-plot-colocalization-metrics-py"><span class="std std-ref">Colocalization metrics</span></a></p>
  <div class="sphx-glr-thumbnail-title">Colocalization metrics</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.manders_overlap_coeff">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">manders_overlap_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_colocalization.py#L181-L263"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.manders_overlap_coeff" title="Link to this definition">#</a></dt>
<dd><p>Manders’ overlap coefficient</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image0</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Image of channel A. All pixel values should be non-negative.</p>
</dd>
<dt><strong>image1</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Image of channel B. All pixel values should be non-negative.
Must have same dimensions as <em class="xref py py-obj">image0</em></p>
</dd>
<dt><strong>mask</strong><span class="classifier">(M, N) ndarray of dtype bool, optional</span></dt><dd><p>Only <em class="xref py py-obj">image0</em> and <em class="xref py py-obj">image1</em> pixel values within this region of interest
mask are included in the calculation.
Must have ♣same dimensions as <em class="xref py py-obj">image0</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>moc: float</dt><dd><p>Manders’ Overlap Coefficient of pixel intensities between the two
images.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Manders’ Overlap Coefficient (MOC) is given by the equation <a class="reference internal" href="#r2208c1a5d6e1-1" id="id15">[1]</a>:</p>
<div class="math notranslate nohighlight">
\[r = \frac{\sum A_i B_i}{\sqrt{\sum A_i^2 \sum B_i^2}}\]</div>
<dl class="simple">
<dt>where</dt><dd><p><span class="math notranslate nohighlight">\(A_i\)</span> is the value of the <span class="math notranslate nohighlight">\(i^{th}\)</span> pixel in <em class="xref py py-obj">image0</em>
<span class="math notranslate nohighlight">\(B_i\)</span> is the value of the <span class="math notranslate nohighlight">\(i^{th}\)</span> pixel in <em class="xref py py-obj">image1</em></p>
</dd>
</dl>
<p>It ranges between 0 for no colocalization and 1 for complete colocalization
of all pixels.</p>
<p>MOC does not take into account pixel intensities, just the fraction of
pixels that have positive values for both channels[R2208c1a5d6e1-2]_ <a class="reference internal" href="#r2208c1a5d6e1-3" id="id16">[3]</a>. Its usefulness
has been criticized as it changes in response to differences in both
co-occurence and correlation and so a particular MOC value could indicate
a wide range of colocalization patterns <a class="reference internal" href="#r2208c1a5d6e1-4" id="id17">[4]</a> <a class="reference internal" href="#r2208c1a5d6e1-5" id="id18">[5]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r2208c1a5d6e1-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">1</a><span class="fn-bracket">]</span></span>
<p>Manders, E.M.M., Verbeek, F.J. and Aten, J.A. (1993), Measurement of
co-localization of objects in dual-colour confocal images. Journal
of Microscopy, 169: 375-382.
<a class="reference external" href="https://doi.org/10.1111/j.1365-2818.1993.tb03313.x">https://doi.org/10.1111/j.1365-2818.1993.tb03313.x</a>
<a class="reference external" href="https://imagej.net/media/manders.pdf">https://imagej.net/media/manders.pdf</a></p>
</div>
<div class="citation" id="r2208c1a5d6e1-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Dunn, K. W., Kamocka, M. M., &amp; McDonald, J. H. (2011). A practical
guide to evaluating colocalization in biological microscopy.
American journal of physiology. Cell physiology, 300(4), C723–C742.
<a class="reference external" href="https://doi.org/10.1152/ajpcell.00462.2010">https://doi.org/10.1152/ajpcell.00462.2010</a></p>
</div>
<div class="citation" id="r2208c1a5d6e1-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id16">3</a><span class="fn-bracket">]</span></span>
<p>Bolte, S. and Cordelières, F.P. (2006), A guided tour into
subcellular colocalization analysis in light microscopy. Journal of
Microscopy, 224: 213-232.
<a class="reference external" href="https://doi.org/10.1111/j.1365-2818.2006.01">https://doi.org/10.1111/j.1365-2818.2006.01</a></p>
</div>
<div class="citation" id="r2208c1a5d6e1-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">4</a><span class="fn-bracket">]</span></span>
<p>Adler J, Parmryd I. (2010), Quantifying colocalization by
correlation: the Pearson correlation coefficient is
superior to the Mander’s overlap coefficient. Cytometry A.
Aug;77(8):733-42.https://doi.org/10.1002/cyto.a.20896</p>
</div>
<div class="citation" id="r2208c1a5d6e1-5" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">5</a><span class="fn-bracket">]</span></span>
<p>Adler, J, Parmryd, I. Quantifying colocalization: The case for
discarding the Manders overlap coefficient. Cytometry. 2021; 99:
910– 920. <a class="reference external" href="https://doi.org/10.1002/cyto.a.24336">https://doi.org/10.1002/cyto.a.24336</a></p>
</div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.marching_cubes">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">marching_cubes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">volume</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1.0,</span> <span class="pre">1.0,</span> <span class="pre">1.0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'descent'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_degenerate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lewiner'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_marching_cubes_lewiner.py#L9-L134"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.marching_cubes" title="Link to this definition">#</a></dt>
<dd><p>Marching cubes algorithm to find surfaces in 3d volumetric data.</p>
<p>In contrast with Lorensen et al. approach <a class="reference internal" href="#rcddcc8f5d58b-2" id="id24">[2]</a>, Lewiner et
al. algorithm is faster, resolves ambiguities, and guarantees
topologically correct results. Therefore, this algorithm generally
a better choice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>volume</strong><span class="classifier">(M, N, P) array</span></dt><dd><p>Input data volume to find isosurfaces. Will internally be
converted to float32 if necessary.</p>
</dd>
<dt><strong>level</strong><span class="classifier">float, optional</span></dt><dd><p>Contour value to search for isosurfaces in <em class="xref py py-obj">volume</em>. If not
given or None, the average of the min and max of vol is used.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">length-3 tuple of floats, optional</span></dt><dd><p>Voxel spacing in spatial dimensions corresponding to numpy array
indexing dimensions (M, N, P) as in <em class="xref py py-obj">volume</em>.</p>
</dd>
<dt><strong>gradient_direction</strong><span class="classifier">string, optional</span></dt><dd><p>Controls if the mesh was generated from an isosurface with gradient
descent toward objects of interest (the default), or the opposite,
considering the <em>left-hand</em> rule.
The two options are:
* descent : Object was greater than exterior
* ascent : Exterior was greater than object</p>
</dd>
<dt><strong>step_size</strong><span class="classifier">int, optional</span></dt><dd><p>Step size in voxels. Default 1. Larger steps yield faster but
coarser results. The result will always be topologically correct
though.</p>
</dd>
<dt><strong>allow_degenerate</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to allow degenerate (i.e. zero-area) triangles in the
end-result. Default True. If False, degenerate triangles are
removed, at the cost of making the algorithm slower.</p>
</dd>
<dt><strong>method: {‘lewiner’, ‘lorensen’}, optional</strong></dt><dd><p>Whether the method of Lewiner et al. or Lorensen et al. will be used.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">(M, N, P) array, optional</span></dt><dd><p>Boolean array. The marching cube algorithm will be computed only on
True elements. This will save computational time when interfaces
are located within certain region of the volume M, N, P-e.g. the top
half of the cube-and also allow to compute finite surfaces-i.e. open
surfaces that do not end at the border of the cube.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>verts</strong><span class="classifier">(V, 3) array</span></dt><dd><p>Spatial coordinates for V unique mesh vertices. Coordinate order
matches input <em class="xref py py-obj">volume</em> (M, N, P). If <code class="docutils literal notranslate"><span class="pre">allow_degenerate</span></code> is set to
True, then the presence of degenerate triangles in the mesh can make
this array have duplicate vertices.</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(F, 3) array</span></dt><dd><p>Define triangular faces via referencing vertex indices from <code class="docutils literal notranslate"><span class="pre">verts</span></code>.
This algorithm specifically outputs triangles, so each face has
exactly three indices.</p>
</dd>
<dt><strong>normals</strong><span class="classifier">(V, 3) array</span></dt><dd><p>The normal direction at each vertex, as calculated from the
data.</p>
</dd>
<dt><strong>values</strong><span class="classifier">(V, ) array</span></dt><dd><p>Gives a measure for the maximum value of the data in the local region
near each vertex. This can be used by visualization tools to apply
a colormap to the mesh.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.mesh_surface_area</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.measure.find_contours" title="skimage.measure.find_contours"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.find_contours</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The algorithm <a class="reference internal" href="#rcddcc8f5d58b-1" id="id25">[1]</a> is an improved version of Chernyaev’s Marching
Cubes 33 algorithm. It is an efficient algorithm that relies on
heavy use of lookup tables to handle the many different cases,
keeping the algorithm relatively easy. This implementation is
written in Cython, ported from Lewiner’s C++ implementation.</p>
<p>To quantify the area of an isosurface generated by this algorithm, pass
verts and faces to <a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.mesh_surface_area</span></code></a>.</p>
<p>Regarding visualization of algorithm output, to contour a volume
named <em class="xref py py-obj">myvolume</em> about the level 0.0, using the <code class="docutils literal notranslate"><span class="pre">mayavi</span></code> package:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt;</span>
<span class="go">&gt;&gt; from mayavi import mlab</span>
<span class="go">&gt;&gt; verts, faces, _, _ = marching_cubes(myvolume, 0.0)</span>
<span class="go">&gt;&gt; mlab.triangular_mesh([vert[0] for vert in verts],</span>
<span class="go">                        [vert[1] for vert in verts],</span>
<span class="go">                        [vert[2] for vert in verts],</span>
<span class="go">                        faces)</span>
<span class="go">&gt;&gt; mlab.show()</span>
</pre></div>
</div>
<p>Similarly using the <code class="docutils literal notranslate"><span class="pre">visvis</span></code> package:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt;</span>
<span class="go">&gt;&gt; import visvis as vv</span>
<span class="go">&gt;&gt; verts, faces, normals, values = marching_cubes(myvolume, 0.0)</span>
<span class="go">&gt;&gt; vv.mesh(np.fliplr(verts), faces, normals, values)</span>
<span class="go">&gt;&gt; vv.use().Run()</span>
</pre></div>
</div>
<p>To reduce the number of triangles in the mesh for better performance,
see this <a class="reference external" href="https://docs.enthought.com/mayavi/mayavi/auto/example_julia_set_decimation.html#example-julia-set-decimation">example</a>
using the <code class="docutils literal notranslate"><span class="pre">mayavi</span></code> package.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rcddcc8f5d58b-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id25">1</a><span class="fn-bracket">]</span></span>
<p>Thomas Lewiner, Helio Lopes, Antonio Wilson Vieira and Geovan
Tavares. Efficient implementation of Marching Cubes’ cases with
topological guarantees. Journal of Graphics Tools 8(2)
pp. 1-15 (december 2003).
<a class="reference external" href="https://doi.org/10.1080/10867651.2003.10487582">DOI:10.1080/10867651.2003.10487582</a></p>
</div>
<div class="citation" id="rcddcc8f5d58b-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id24">2</a><span class="fn-bracket">]</span></span>
<p>Lorensen, William and Harvey E. Cline. Marching Cubes: A High
Resolution 3D Surface Construction Algorithm. Computer Graphics
(SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170).
<a class="reference external" href="https://doi.org/10.1145/37401.37422">DOI:10.1145/37401.37422</a></p>
</div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="Marching cubes is an algorithm to extract a 2D surface mesh from a 3D volume. This can be conce..."><img alt="" src="../_images/sphx_glr_plot_marching_cubes_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_marching_cubes.html#sphx-glr-auto-examples-edges-plot-marching-cubes-py"><span class="std std-ref">Marching Cubes</span></a></p>
  <div class="sphx-glr-thumbnail-title">Marching Cubes</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.mesh_surface_area">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">mesh_surface_area</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">faces</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_marching_cubes_lewiner.py#L262-L299"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.mesh_surface_area" title="Link to this definition">#</a></dt>
<dd><p>Compute surface area, given vertices and triangular faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>verts</strong><span class="classifier">(V, 3) array of floats</span></dt><dd><p>Array containing (x, y, z) coordinates for V unique mesh vertices.</p>
</dd>
<dt><strong>faces</strong><span class="classifier">(F, 3) array of ints</span></dt><dd><p>List of length-3 lists of integers, referencing vertex coordinates as
provided in <em class="xref py py-obj">verts</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>area</strong><span class="classifier">float</span></dt><dd><p>Surface area of mesh. Units now [coordinate units] ** 2.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.marching_cubes</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The arguments expected by this function are the first two outputs from
<a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.marching_cubes</span></code></a>. For unit correct output, ensure correct
<em class="xref py py-obj">spacing</em> was passed to <a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.measure.marching_cubes</span></code></a>.</p>
<p>This algorithm works properly only if the <code class="docutils literal notranslate"><span class="pre">faces</span></code> provided are all
triangles.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.moments">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_moments.py#L154-L198"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.moments" title="Link to this definition">#</a></dt>
<dd><p>Calculate all raw image moments up to a certain order.</p>
<dl class="simple">
<dt>The following properties can be calculated from raw image moments:</dt><dd><ul class="simple">
<li><p>Area as: <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">0]</span></code>.</p></li>
<li><p>Centroid as: {<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p></li>
</ul>
</dd>
</dl>
<p>Note that raw moments are neither translation, scale nor rotation
invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">nD double or uint8 array</span></dt><dd><p>Rasterized shape as image.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
<dt><strong>spacing: tuple of float, shape (ndim, )</strong></dt><dd><p>The pixel spacing along each axis of the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>m</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>) array</span></dt><dd><p>Raw image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r3012f4679c28-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</div>
<div class="citation" id="r3012f4679c28-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>B. Jähne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</div>
<div class="citation" id="r3012f4679c28-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</div>
<div class="citation" id="r3012f4679c28-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">moments</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span>
<span class="go">(14.5, 14.5)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.moments_central">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments_central</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_moments.py#L201-L269"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.moments_central" title="Link to this definition">#</a></dt>
<dd><p>Calculate all central image moments up to a certain order.</p>
<p>The center coordinates (cr, cc) can be calculated from the raw moments as:
{<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p>
<p>Note that central moments are translation invariant but not scale and
rotation invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">nD double or uint8 array</span></dt><dd><p>Rasterized shape as image.</p>
</dd>
<dt><strong>center</strong><span class="classifier">tuple of float, optional</span></dt><dd><p>Coordinates of the image centroid. This will be computed if it
is not provided.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The maximum order of moments computed.</p>
</dd>
<dt><strong>spacing: tuple of float, shape (ndim, )</strong></dt><dd><p>The pixel spacing along each axis of the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>mu</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>) array</span></dt><dd><p>Central image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="re30db7550969-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</div>
<div class="citation" id="re30db7550969-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>B. Jähne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</div>
<div class="citation" id="re30db7550969-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</div>
<div class="citation" id="re30db7550969-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">moments</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_central</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">centroid</span><span class="p">)</span>
<span class="go">array([[16.,  0., 20.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.],</span>
<span class="go">       [20.,  0., 25.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.moments_coords">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_moments.py#L10-L48"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.moments_coords" title="Link to this definition">#</a></dt>
<dd><p>Calculate all raw image moments up to a certain order.</p>
<dl class="simple">
<dt>The following properties can be calculated from raw image moments:</dt><dd><ul class="simple">
<li><p>Area as: <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">0]</span></code>.</p></li>
<li><p>Centroid as: {<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p></li>
</ul>
</dd>
</dl>
<p>Note that raw moments are neither translation, scale nor rotation
invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) double or uint8 array</span></dt><dd><p>Array of N points that describe an image of D dimensionality in
Cartesian space.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>M</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, …) array</span></dt><dd><p>Raw image moments. (D dimensions)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r1906bd878ddc-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Johannes Kilian. Simple Image Analysis By Moments. Durham
University, version 0.2, Durham, 2001.</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">18</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">moments_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span>
<span class="go">(14.5, 15.5)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.moments_coords_central">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments_coords_central</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_moments.py#L51-L151"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.moments_coords_central" title="Link to this definition">#</a></dt>
<dd><p>Calculate all central image moments up to a certain order.</p>
<dl class="simple">
<dt>The following properties can be calculated from raw image moments:</dt><dd><ul class="simple">
<li><p>Area as: <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">0]</span></code>.</p></li>
<li><p>Centroid as: {<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p></li>
</ul>
</dd>
</dl>
<p>Note that raw moments are neither translation, scale nor rotation
invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) double or uint8 array</span></dt><dd><p>Array of N points that describe an image of D dimensionality in
Cartesian space. A tuple of coordinates as returned by
<code class="docutils literal notranslate"><span class="pre">np.nonzero</span></code> is also accepted as input.</p>
</dd>
<dt><strong>center</strong><span class="classifier">tuple of float, optional</span></dt><dd><p>Coordinates of the image centroid. This will be computed if it
is not provided.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>Mc</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, …) array</span></dt><dd><p>Central image moments. (D dimensions)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rdba8c2d58a27-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Johannes Kilian. Simple Image Analysis By Moments. Durham
University, version 0.2, Durham, 2001.</p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">18</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_coords_central</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
<span class="go">array([[16.,  0., 20.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.],</span>
<span class="go">       [20.,  0., 25.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
<p>As seen above, for symmetric objects, odd-order moments (columns 1 and 3,
rows 1 and 3) are zero when centered on the centroid, or center of mass,
of the object (the default). If we break the symmetry by adding a new
point, this no longer holds:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">coords</span><span class="p">,</span> <span class="p">[[</span><span class="mi">17</span><span class="p">,</span> <span class="mi">17</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">moments_coords_central</span><span class="p">(</span><span class="n">coords2</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">decimals</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">array([[17.  ,  0.  , 22.12, -2.49],</span>
<span class="go">       [ 0.  ,  3.53,  1.73,  7.4 ],</span>
<span class="go">       [25.88,  6.02, 36.63,  8.83],</span>
<span class="go">       [ 4.15, 19.17, 14.8 , 39.6 ]])</span>
</pre></div>
</div>
<p>Image moments and central image moments are equivalent (by definition)
when the center is (0, 0):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">moments_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span>
<span class="gp">... </span>            <span class="n">moments_coords_central</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.moments_hu">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments_hu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_moments.py#L330-L371"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.moments_hu" title="Link to this definition">#</a></dt>
<dd><p>Calculate Hu’s set of image moments (2D-only).</p>
<p>Note that this set of moments is proved to be translation, scale and
rotation invariant.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nu</strong><span class="classifier">(M, M) array</span></dt><dd><p>Normalized central image moments, where M must be &gt;= 4.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nu</strong><span class="classifier">(7,) array</span></dt><dd><p>Hu’s set of image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r8f5f4137a534-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>M. K. Hu, “Visual Pattern Recognition by Moment Invariants”,
IRE Trans. Info. Theory, vol. IT-8, pp. 179-187, 1962</p>
</div>
<div class="citation" id="r8f5f4137a534-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</div>
<div class="citation" id="r8f5f4137a534-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>B. Jähne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</div>
<div class="citation" id="r8f5f4137a534-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</div>
<div class="citation" id="r8f5f4137a534-5" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mu</span> <span class="o">=</span> <span class="n">moments_central</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nu</span> <span class="o">=</span> <span class="n">moments_normalized</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_hu</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
<span class="go">array([0.74537037, 0.35116598, 0.10404918, 0.04064421, 0.00264312,</span>
<span class="go">       0.02408546, 0.        ])</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.moments_normalized">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments_normalized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_moments.py#L272-L327"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.moments_normalized" title="Link to this definition">#</a></dt>
<dd><p>Calculate all normalized central image moments up to a certain order.</p>
<p>Note that normalized central moments are translation and scale invariant
but not rotation invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mu</strong><span class="classifier">(M,[ …,] M) array</span></dt><dd><p>Central image moments, where M must be greater than or equal
to <code class="docutils literal notranslate"><span class="pre">order</span></code>.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>nu</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>,[ …,] <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>) array</span></dt><dd><p>Normalized central image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rc5867b15e1bf-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</div>
<div class="citation" id="rc5867b15e1bf-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>B. Jähne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</div>
<div class="citation" id="rc5867b15e1bf-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</div>
<div class="citation" id="rc5867b15e1bf-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">moments</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mu</span> <span class="o">=</span> <span class="n">moments_central</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">centroid</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_normalized</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="go">array([[       nan,        nan, 0.078125  , 0.        ],</span>
<span class="go">       [       nan, 0.        , 0.        , 0.        ],</span>
<span class="go">       [0.078125  , 0.        , 0.00610352, 0.        ],</span>
<span class="go">       [0.        , 0.        , 0.        , 0.        ]])</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.pearson_corr_coeff">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">pearson_corr_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_colocalization.py#L13-L96"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.pearson_corr_coeff" title="Link to this definition">#</a></dt>
<dd><p>Calculate Pearson’s Correlation Coefficient between pixel intensities
in channels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image0</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Image of channel A.</p>
</dd>
<dt><strong>image1</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Image of channel 2 to be correlated with channel B.
Must have same dimensions as <em class="xref py py-obj">image0</em>.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">(M, N) ndarray of dtype bool, optional</span></dt><dd><p>Only <em class="xref py py-obj">image0</em> and <em class="xref py py-obj">image1</em> pixels within this region of interest mask
are included in the calculation. Must have same dimensions as <em class="xref py py-obj">image0</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pcc</strong><span class="classifier">float</span></dt><dd><p>Pearson’s correlation coefficient of the pixel intensities between
the two images, within the mask if provided.</p>
</dd>
<dt><strong>p-value</strong><span class="classifier">float</span></dt><dd><p>Two-tailed p-value.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Pearson’s Correlation Coefficient (PCC) measures the linear correlation
between the pixel intensities of the two images. Its value ranges from -1
for perfect linear anti-correlation to +1 for perfect linear correlation.
The calculation of the p-value assumes that the intensities of pixels in
each input image are normally distributed.</p>
<p>Scipy’s implementation of Pearson’s correlation coefficient is used. Please
refer to it for further information and caveats <a class="reference internal" href="#r1b5fe5cd6bb2-1" id="id47">[1]</a>.</p>
<div class="math notranslate nohighlight">
\[r = \frac{\sum (A_i - m_A_i) (B_i - m_B_i)}
{\sqrt{\sum (A_i - m_A_i)^2 \sum (B_i - m_B_i)^2}}\]</div>
<dl class="simple">
<dt>where</dt><dd><p><span class="math notranslate nohighlight">\(A_i\)</span> is the value of the <span class="math notranslate nohighlight">\(i^{th}\)</span> pixel in <em class="xref py py-obj">image0</em>
<span class="math notranslate nohighlight">\(B_i\)</span> is the value of the <span class="math notranslate nohighlight">\(i^{th}\)</span> pixel in <em class="xref py py-obj">image1</em>,
<span class="math notranslate nohighlight">\(m_A_i\)</span> is the mean of the pixel values in <em class="xref py py-obj">image0</em>
<span class="math notranslate nohighlight">\(m_B_i\)</span> is the mean of the pixel values in <em class="xref py py-obj">image1</em></p>
</dd>
</dl>
<p>A low PCC value does not necessarily mean that there is no correlation
between the two channel intensities, just that there is no linear
correlation. You may wish to plot the pixel intensities of each of the two
channels in a 2D scatterplot and use Spearman’s rank correlation if a
non-linear correlation is visually identified <a class="reference internal" href="#r1b5fe5cd6bb2-2" id="id48">[2]</a>. Also consider if you
are interested in correlation or co-occurence, in which case a method
involving segmentation masks (e.g. MCC or intersection coefficient) may be
more suitable <a class="reference internal" href="#r1b5fe5cd6bb2-3" id="id49">[3]</a> <a class="reference internal" href="#r1b5fe5cd6bb2-4" id="id50">[4]</a>.</p>
<p>Providing the mask of only relevant sections of the image (e.g., cells, or
particular cellular compartments) and removing noise is important as the
PCC is sensitive to these measures <a class="reference internal" href="#r1b5fe5cd6bb2-3" id="id51">[3]</a> <a class="reference internal" href="#r1b5fe5cd6bb2-4" id="id52">[4]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r1b5fe5cd6bb2-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id47">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.pearsonr.html</a>  # noqa</p>
</div>
<div class="citation" id="r1b5fe5cd6bb2-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id48">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.spearmanr.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.spearmanr.html</a>  # noqa</p>
</div>
<div class="citation" id="r1b5fe5cd6bb2-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id49">1</a>,<a role="doc-backlink" href="#id51">2</a>)</span>
<p>Dunn, K. W., Kamocka, M. M., &amp; McDonald, J. H. (2011). A practical
guide to evaluating colocalization in biological microscopy.
American journal of physiology. Cell physiology, 300(4), C723–C742.
<a class="reference external" href="https://doi.org/10.1152/ajpcell.00462.2010">https://doi.org/10.1152/ajpcell.00462.2010</a></p>
</div>
<div class="citation" id="r1b5fe5cd6bb2-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id50">1</a>,<a role="doc-backlink" href="#id52">2</a>)</span>
<p>Bolte, S. and Cordelières, F.P. (2006), A guided tour into
subcellular colocalization analysis in light microscopy. Journal of
Microscopy, 224: 213-232.
<a class="reference external" href="https://doi.org/10.1111/j.1365-2818.2006.01706.x">https://doi.org/10.1111/j.1365-2818.2006.01706.x</a></p>
</div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In this example, we demonstrate the use of different metrics to assess the colocalization of tw..."><img alt="" src="../_images/sphx_glr_plot_colocalization_metrics_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_colocalization_metrics.html#sphx-glr-auto-examples-applications-plot-colocalization-metrics-py"><span class="std std-ref">Colocalization metrics</span></a></p>
  <div class="sphx-glr-thumbnail-title">Colocalization metrics</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.perimeter">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">perimeter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighborhood</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_regionprops_utils.py#L187-L250"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.perimeter" title="Link to this definition">#</a></dt>
<dd><p>Calculate total perimeter of all objects in binary image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>2D binary image.</p>
</dd>
<dt><strong>neighborhood</strong><span class="classifier">4 or 8, optional</span></dt><dd><p>Neighborhood connectivity for border pixel determination. It is used to
compute the contour. A higher neighborhood widens the border on which
the perimeter is computed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perimeter</strong><span class="classifier">float</span></dt><dd><p>Total perimeter of all objects in binary image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r5745cfa18943-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>K. Benkrid, D. Crookes. Design and FPGA Implementation of
a Perimeter Estimator. The Queen’s University of Belfast.
<a class="reference external" href="http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc">http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">label</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># coins image (binary)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_coins</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">110</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># total perimeter of all objects in the image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perimeter</span><span class="p">(</span><span class="n">img_coins</span><span class="p">,</span> <span class="n">neighborhood</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  
<span class="go">7796.867...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perimeter</span><span class="p">(</span><span class="n">img_coins</span><span class="p">,</span> <span class="n">neighborhood</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>  
<span class="go">8806.268...</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In this example, we show the error on measuring perimeters, comparing classic approximations an..."><img alt="" src="../_images/sphx_glr_plot_perimeters_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_perimeters.html#sphx-glr-auto-examples-segmentation-plot-perimeters-py"><span class="std std-ref">Measure perimeters with different estimators</span></a></p>
  <div class="sphx-glr-thumbnail-title">Measure perimeters with different estimators</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.perimeter_crofton">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">perimeter_crofton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_regionprops_utils.py#L253-L329"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.perimeter_crofton" title="Link to this definition">#</a></dt>
<dd><p>Calculate total Crofton perimeter of all objects in binary image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>2D image. If image is not binary, all values strictly greater than zero
are considered as the object.</p>
</dd>
<dt><strong>directions</strong><span class="classifier">2 or 4, optional</span></dt><dd><p>Number of directions used to approximate the Crofton perimeter. By
default, 4 is used: it should be more accurate than 2.
Computation time is the same in both cases.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perimeter</strong><span class="classifier">float</span></dt><dd><p>Total perimeter of all objects in binary image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This measure is based on Crofton formula [1], which is a measure from
integral geometry. It is defined for general curve length evaluation via
a double integral along all directions. In a discrete
space, 2 or 4 directions give a quite good approximation, 4 being more
accurate than 2 for more complex shapes.</p>
<p>Similar to <a class="reference internal" href="#skimage.measure.perimeter" title="skimage.measure.perimeter"><code class="xref py py-func docutils literal notranslate"><span class="pre">perimeter()</span></code></a>, this function returns an
approximation of the perimeter in continuous space.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r08d850c42e9e-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Crofton_formula">https://en.wikipedia.org/wiki/Crofton_formula</a></p>
</div>
<div class="citation" id="r08d850c42e9e-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>S. Rivollier. Analyse d’image geometrique et morphometrique par
diagrammes de forme et voisinages adaptatifs generaux. PhD thesis,
2010.
Ecole Nationale Superieure des Mines de Saint-Etienne.
<a class="reference external" href="https://tel.archives-ouvertes.fr/tel-00560838">https://tel.archives-ouvertes.fr/tel-00560838</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">label</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># coins image (binary)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_coins</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">110</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># total perimeter of all objects in the image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perimeter_crofton</span><span class="p">(</span><span class="n">img_coins</span><span class="p">,</span> <span class="n">directions</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">8144.578...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perimeter_crofton</span><span class="p">(</span><span class="n">img_coins</span><span class="p">,</span> <span class="n">directions</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  
<span class="go">7837.077...</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In this example, we show the error on measuring perimeters, comparing classic approximations an..."><img alt="" src="../_images/sphx_glr_plot_perimeters_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_perimeters.html#sphx-glr-auto-examples-segmentation-plot-perimeters-py"><span class="std std-ref">Measure perimeters with different estimators</span></a></p>
  <div class="sphx-glr-thumbnail-title">Measure perimeters with different estimators</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.points_in_poly">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">points_in_poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verts</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/pnpoly.py#L46-L67"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.points_in_poly" title="Link to this definition">#</a></dt>
<dd><p>Test whether points lie inside a polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Input points, <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code>.</p>
</dd>
<dt><strong>verts</strong><span class="classifier">(M, 2) array</span></dt><dd><p>Vertices of the polygon, sorted either clockwise or anti-clockwise.
The first point may (but does not need to be) duplicated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mask</strong><span class="classifier">(N,) array of bool</span></dt><dd><p>True if corresponding point is inside the polygon.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.grid_points_in_poly" title="skimage.measure.grid_points_in_poly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_points_in_poly</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.profile_line">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">profile_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linewidth=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode='reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval=0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_func=&lt;function</span> <span class="pre">mean&gt;</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/profile.py#L7-L120"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.profile_line" title="Link to this definition">#</a></dt>
<dd><p>Return the intensity profile of an image measured along a scan line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray, shape (M, N[, C])</span></dt><dd><p>The image, either grayscale (2D array) or multichannel
(3D array, where the final axis contains the channel
information).</p>
</dd>
<dt><strong>src</strong><span class="classifier">array_like, shape (2, )</span></dt><dd><p>The coordinates of the start point of the scan line.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">array_like, shape (2, )</span></dt><dd><p>The coordinates of the end point of the scan
line. The destination point is <em>included</em> in the profile, in
contrast to standard numpy indexing.</p>
</dd>
<dt><strong>linewidth</strong><span class="classifier">int, optional</span></dt><dd><p>Width of the scan, perpendicular to the line</p>
</dd>
<dt><strong>order</strong><span class="classifier">int in {0, 1, 2, 3, 4, 5}, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <a class="reference internal" href="skimage.transform.html#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘constant’, ‘nearest’, ‘reflect’, ‘mirror’, ‘wrap’}, optional</span></dt><dd><p>How to compute any values falling outside of the image.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>If <em class="xref py py-obj">mode</em> is ‘constant’, what constant value to use outside the image.</p>
</dd>
<dt><strong>reduce_func</strong><span class="classifier">callable, optional</span></dt><dd><p>Function used to calculate the aggregation of pixel values
perpendicular to the profile_line direction when <em class="xref py py-obj">linewidth</em> &gt; 1.
If set to None the unreduced array will be returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>return_value</strong><span class="classifier">array</span></dt><dd><p>The intensity profile along the scan line. The length of the profile
is the ceil of the computed length of the scan line.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span>
<span class="go">array([[0, 0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 1, 2, 2, 2],</span>
<span class="go">       [1, 1, 1, 2, 2, 2],</span>
<span class="go">       [1, 1, 1, 2, 2, 2],</span>
<span class="go">       [0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">array([1., 1., 2., 2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">cval</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([1., 1., 1., 2., 2., 2., 2.])</span>
</pre></div>
</div>
<p>The destination point is included in the profile, in contrast to
standard numpy indexing.
For example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>  <span class="c1"># The final point is out of bounds</span>
<span class="go">array([1., 1., 1., 2., 2., 2., 2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>  <span class="c1"># This accesses the full first row</span>
<span class="go">array([1., 1., 1., 2., 2., 2.])</span>
</pre></div>
</div>
<p>For different reduce_func inputs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
<span class="go">array([0.66666667, 0.66666667, 0.66666667, 1.33333333])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">)</span>
<span class="go">array([2, 2, 2, 4])</span>
</pre></div>
</div>
<p>The unreduced array will be returned when <em class="xref py py-obj">reduce_func</em> is None or when
<em class="xref py py-obj">reduce_func</em> acts on each pixel value individually.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">reduce_func</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">array([[1, 1, 2],</span>
<span class="go">       [1, 1, 2],</span>
<span class="go">       [1, 1, 2],</span>
<span class="go">       [0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">)</span>
<span class="go">array([[1.        , 1.        , 0.        ],</span>
<span class="go">       [1.        , 1.        , 0.        ],</span>
<span class="go">       [1.        , 1.        , 0.        ],</span>
<span class="go">       [1.41421356, 1.41421356, 0.        ]])</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.ransac">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">ransac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_class</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residual_threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_data_valid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_model_valid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_trials</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_sample_num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_residuals_sum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_probability</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_inliers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L675-L952"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.ransac" title="Link to this definition">#</a></dt>
<dd><p>Fit a model to data with the RANSAC (random sample consensus) algorithm.</p>
<p>RANSAC is an iterative algorithm for the robust estimation of parameters
from a subset of inliers from the complete data set. Each iteration
performs the following tasks:</p>
<ol class="arabic simple">
<li><p>Select <em class="xref py py-obj">min_samples</em> random samples from the original data and check
whether the set of data is valid (see <em class="xref py py-obj">is_data_valid</em>).</p></li>
<li><p>Estimate a model to the random subset
(<em class="xref py py-obj">model_cls.estimate(*data[random_subset]</em>) and check whether the
estimated model is valid (see <em class="xref py py-obj">is_model_valid</em>).</p></li>
<li><p>Classify all data as inliers or outliers by calculating the residuals
to the estimated model (<em class="xref py py-obj">model_cls.residuals(*data)</em>) - all data samples
with residuals smaller than the <em class="xref py py-obj">residual_threshold</em> are considered as
inliers.</p></li>
<li><p>Save estimated model as best model if number of inlier samples is
maximal. In case the current estimated model has the same number of
inliers, it is only considered as the best model if it has less sum of
residuals.</p></li>
</ol>
<p>These steps are performed either a maximum number of times or until one of
the special stop criteria are met. The final model is estimated using all
inlier samples of the previously determined best model.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">[list, tuple of] (N, …) array</span></dt><dd><p>Data set to which the model is fitted, where N is the number of data
points and the remaining dimension are depending on model requirements.
If the model class requires multiple input data arrays (e.g. source and
destination coordinates of  <code class="docutils literal notranslate"><span class="pre">skimage.transform.AffineTransform</span></code>),
they can be optionally passed as tuple or list. Note, that in this case
the functions <code class="docutils literal notranslate"><span class="pre">estimate(*data)</span></code>, <code class="docutils literal notranslate"><span class="pre">residuals(*data)</span></code>,
<code class="docutils literal notranslate"><span class="pre">is_model_valid(model,</span> <span class="pre">*random_data)</span></code> and
<code class="docutils literal notranslate"><span class="pre">is_data_valid(*random_data)</span></code> must all take each data array as
separate arguments.</p>
</dd>
<dt><strong>model_class</strong><span class="classifier">object</span></dt><dd><p>Object with the following object methods:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">success</span> <span class="pre">=</span> <span class="pre">estimate(*data)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">residuals(*data)</span></code></p></li>
</ul>
</div></blockquote>
<p>where <em class="xref py py-obj">success</em> indicates whether the model estimation succeeded
(<em class="xref py py-obj">True</em> or <em class="xref py py-obj">None</em> for success, <em class="xref py py-obj">False</em> for failure).</p>
</dd>
<dt><strong>min_samples</strong><span class="classifier">int in range (0, N)</span></dt><dd><p>The minimum number of data points to fit a model to.</p>
</dd>
<dt><strong>residual_threshold</strong><span class="classifier">float larger than 0</span></dt><dd><p>Maximum distance for a data point to be classified as an inlier.</p>
</dd>
<dt><strong>is_data_valid</strong><span class="classifier">function, optional</span></dt><dd><p>This function is called with the randomly selected data before the
model is fitted to it: <em class="xref py py-obj">is_data_valid(*random_data)</em>.</p>
</dd>
<dt><strong>is_model_valid</strong><span class="classifier">function, optional</span></dt><dd><p>This function is called with the estimated model and the randomly
selected data: <em class="xref py py-obj">is_model_valid(model, *random_data)</em>, .</p>
</dd>
<dt><strong>max_trials</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of iterations for random sample selection.</p>
</dd>
<dt><strong>stop_sample_num</strong><span class="classifier">int, optional</span></dt><dd><p>Stop iteration if at least this number of inliers are found.</p>
</dd>
<dt><strong>stop_residuals_sum</strong><span class="classifier">float, optional</span></dt><dd><p>Stop iteration if sum of residuals is less than or equal to this
threshold.</p>
</dd>
<dt><strong>stop_probability</strong><span class="classifier">float in range [0, 1], optional</span></dt><dd><p>RANSAC iteration stops if at least one outlier-free set of the
training data is sampled with <code class="docutils literal notranslate"><span class="pre">probability</span> <span class="pre">&gt;=</span> <span class="pre">stop_probability</span></code>,
depending on the current best model’s inlier ratio and the number
of trials. This requires to generate at least N samples (trials):</p>
<blockquote>
<div><p>N &gt;= log(1 - probability) / log(1 - e**m)</p>
</div></blockquote>
<p>where the probability (confidence) is typically set to a high value
such as 0.99, e is the current fraction of inliers w.r.t. the
total number of samples, and m is the min_samples value.</p>
</dd>
<dt><strong>rng</strong><span class="classifier">{<a class="reference external" href="https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.Generator" title="(in NumPy v1.26)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.random.Generator</span></code></a>, int}, optional</span></dt><dd><p>Pseudo-random number generator.
By default, a PCG64 generator is used (see <a class="reference external" href="https://numpy.org/doc/stable/reference/random/generator.html#numpy.random.default_rng" title="(in NumPy v1.26)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.random.default_rng()</span></code></a>).
If <em class="xref py py-obj">rng</em> is an int, it is used to seed the generator.</p>
</dd>
<dt><strong>initial_inliers</strong><span class="classifier">array-like of bool, shape (N,), optional</span></dt><dd><p>Initial samples selection for model estimation</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>model</strong><span class="classifier">object</span></dt><dd><p>Best model with largest consensus set.</p>
</dd>
<dt><strong>inliers</strong><span class="classifier">(N, ) array</span></dt><dd><p>Boolean mask of inliers classified as <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>random_state</strong><span class="classifier">DEPRECATED</span></dt><dd><p>Deprecated in favor of <em class="xref py py-obj">rng</em>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 0.21.</span></p>
</div>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="radbaf2717b1f-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>“RANSAC”, Wikipedia, <a class="reference external" href="https://en.wikipedia.org/wiki/RANSAC">https://en.wikipedia.org/wiki/RANSAC</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<p>Generate ellipse data without tilt and add noise:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">xc</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">yc</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="mi">203560</span><span class="p">)</span>  <span class="c1"># do not copy this value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">+=</span> <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Add some faulty data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="mi">120</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="mi">130</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">140</span><span class="p">,</span> <span class="mi">130</span><span class="p">)</span>
</pre></div>
</div>
<p>Estimate ellipse model using all available data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">EllipseModel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>  
<span class="go">array([ 72.,  75.,  77.,  14.,   1.])</span>
</pre></div>
</div>
<p>Estimate ellipse model using RANSAC:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ransac_model</span><span class="p">,</span> <span class="n">inliers</span> <span class="o">=</span> <span class="n">ransac</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">EllipseModel</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">max_trials</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ransac_model</span><span class="o">.</span><span class="n">params</span><span class="p">))</span>  
<span class="go">array([20., 30., 10.,  6.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inliers</span>  
<span class="go">array([False, False, False, False,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">inliers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">40</span>
<span class="go">True</span>
</pre></div>
</div>
<p>RANSAC can be used to robustly estimate a geometric
transformation. In this section, we also show how to use a
proportion of the total samples, rather than an absolute number.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">SimilarityTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model0</span> <span class="o">=</span> <span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                             <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">model0</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ratio</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># use half of the samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ratio</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="p">,</span> <span class="n">inliers</span> <span class="o">=</span> <span class="n">ransac</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">SimilarityTransform</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">min_samples</span><span class="p">,</span>
<span class="gp">... </span>    <span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">initial_inliers</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">inliers</span>  
<span class="go">array([False, False, False,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True,  True,  True,  True,  True,</span>
<span class="go">        True,  True,  True,  True,  True])</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates how to robustly estimate epipolar geometry &lt;https://en.wikipedia.org/..."><img alt="" src="../_images/sphx_glr_plot_fundamental_matrix_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_fundamental_matrix.html#sphx-glr-auto-examples-transform-plot-fundamental-matrix-py"><span class="std std-ref">Fundamental matrix estimation</span></a></p>
  <div class="sphx-glr-thumbnail-title">Fundamental matrix estimation</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example we see how to robustly fit a line model to faulty data using the RANSAC (random..."><img alt="" src="../_images/sphx_glr_plot_ransac_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_ransac.html#sphx-glr-auto-examples-transform-plot-ransac-py"><span class="std std-ref">Robust line model estimation using RANSAC</span></a></p>
  <div class="sphx-glr-thumbnail-title">Robust line model estimation using RANSAC</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this simplified example we first generate two synthetic images as if they were taken from di..."><img alt="" src="../_images/sphx_glr_plot_matching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_matching.html#sphx-glr-auto-examples-transform-plot-matching-py"><span class="std std-ref">Robust matching using RANSAC</span></a></p>
  <div class="sphx-glr-thumbnail-title">Robust matching using RANSAC</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates how a set of images can be assembled under the hypothesis of rigid bo..."><img alt="" src="../_images/sphx_glr_plot_stitching_thumb.png" />
<p><a class="reference internal" href="../auto_examples/registration/plot_stitching.html#sphx-glr-auto-examples-registration-plot-stitching-py"><span class="std std-ref">Assemble images with simple image stitching</span></a></p>
  <div class="sphx-glr-thumbnail-title">Assemble images with simple image stitching</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.regionprops">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">regionprops</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity_image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_properties</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_regionprops.py#L1048-L1331"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.regionprops" title="Link to this definition">#</a></dt>
<dd><p>Measure properties of labeled image regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>label_image</strong><span class="classifier">(M, N[, P]) ndarray</span></dt><dd><p>Labeled input image. Labels with value 0 are ignored.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.14.1: </span>Previously, <code class="docutils literal notranslate"><span class="pre">label_image</span></code> was processed by <code class="docutils literal notranslate"><span class="pre">numpy.squeeze</span></code> and
so any number of singleton dimensions was allowed. This resulted in
inconsistent handling of images with singleton dimensions. To
recover the old behaviour, use
<code class="docutils literal notranslate"><span class="pre">regionprops(np.squeeze(label_image),</span> <span class="pre">...)</span></code>.</p>
</div>
</dd>
<dt><strong>intensity_image</strong><span class="classifier">(M, N[, P][, C]) ndarray, optional</span></dt><dd><p>Intensity (i.e., input) image with same size as labeled image, plus
optionally an extra dimension for multichannel data. Currently,
this extra channel dimension, if present, must be the last axis.
Default is None.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18.0: </span>The ability to provide an extra dimension for channels was added.</p>
</div>
</dd>
<dt><strong>cache</strong><span class="classifier">bool, optional</span></dt><dd><p>Determine whether to cache calculated properties. The computation is
much faster for cached properties, whereas the memory consumption
increases.</p>
</dd>
<dt><strong>extra_properties</strong><span class="classifier">Iterable of callables</span></dt><dd><p>Add extra property computation functions that are not included with
skimage. The name of the property is derived from the function name,
the dtype is inferred by calling the function on a small sample.
If the name of an extra property clashes with the name of an existing
property the extra property will not be visible and a UserWarning is
issued. A property computation function must take a region mask as its
first argument. If the property requires an intensity image, it must
accept the intensity image as the second argument.</p>
</dd>
<dt><strong>spacing: tuple of float, shape (ndim, )</strong></dt><dd><p>The pixel spacing along each axis of the image.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">array-like of int, shape <em class="xref py py-obj">(label_image.ndim,)</em>, optional</span></dt><dd><p>Coordinates of the origin (“top-left” corner) of the label image.
Normally this is ([0, ]0, 0), but it might be different if one wants
to obtain regionprops of subvolumes within a larger volume.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>properties</strong><span class="classifier">list of RegionProperties</span></dt><dd><p>Each item describes one labeled region, and can be accessed using the
attributes listed below.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.measure.label" title="skimage.measure.label"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The following properties can be accessed as attributes or keys:</p>
<dl>
<dt><strong>area</strong><span class="classifier">float</span></dt><dd><p>Area of the region i.e. number of pixels of the region scaled by pixel-area.</p>
</dd>
<dt><strong>area_bbox</strong><span class="classifier">float</span></dt><dd><p>Area of the bounding box i.e. number of pixels of bounding box scaled by pixel-area.</p>
</dd>
<dt><strong>area_convex</strong><span class="classifier">float</span></dt><dd><p>Area of the convex hull image, which is the smallest convex
polygon that encloses the region.</p>
</dd>
<dt><strong>area_filled</strong><span class="classifier">float</span></dt><dd><p>Area of the region with all the holes filled in.</p>
</dd>
<dt><strong>axis_major_length</strong><span class="classifier">float</span></dt><dd><p>The length of the major axis of the ellipse that has the same
normalized second central moments as the region.</p>
</dd>
<dt><strong>axis_minor_length</strong><span class="classifier">float</span></dt><dd><p>The length of the minor axis of the ellipse that has the same
normalized second central moments as the region.</p>
</dd>
<dt><strong>bbox</strong><span class="classifier">tuple</span></dt><dd><p>Bounding box <code class="docutils literal notranslate"><span class="pre">(min_row,</span> <span class="pre">min_col,</span> <span class="pre">max_row,</span> <span class="pre">max_col)</span></code>.
Pixels belonging to the bounding box are in the half-open interval
<code class="docutils literal notranslate"><span class="pre">[min_row;</span> <span class="pre">max_row)</span></code> and <code class="docutils literal notranslate"><span class="pre">[min_col;</span> <span class="pre">max_col)</span></code>.</p>
</dd>
<dt><strong>centroid</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code>.</p>
</dd>
<dt><strong>centroid_local</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code>, relative to region bounding
box.</p>
</dd>
<dt><strong>centroid_weighted</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> weighted with intensity
image.</p>
</dd>
<dt><strong>centroid_weighted_local</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code>, relative to region bounding
box, weighted with intensity image.</p>
</dd>
<dt><strong>coords_scaled</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Coordinate list <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)``of</span> <span class="pre">the</span> <span class="pre">region</span> <span class="pre">scaled</span> <span class="pre">by</span> <span class="pre">``spacing</span></code>.</p>
</dd>
<dt><strong>coords</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Coordinate list <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> of the region.</p>
</dd>
<dt><strong>eccentricity</strong><span class="classifier">float</span></dt><dd><p>Eccentricity of the ellipse that has the same second-moments as the
region. The eccentricity is the ratio of the focal distance
(distance between focal points) over the major axis length.
The value is in the interval [0, 1).
When it is 0, the ellipse becomes a circle.</p>
</dd>
<dt><strong>equivalent_diameter_area</strong><span class="classifier">float</span></dt><dd><p>The diameter of a circle with the same area as the region.</p>
</dd>
<dt><strong>euler_number</strong><span class="classifier">int</span></dt><dd><p>Euler characteristic of the set of non-zero pixels.
Computed as number of connected components subtracted by number of
holes (input.ndim connectivity). In 3D, number of connected
components plus number of holes subtracted by number of tunnels.</p>
</dd>
<dt><strong>extent</strong><span class="classifier">float</span></dt><dd><p>Ratio of pixels in the region to pixels in the total bounding box.
Computed as <code class="docutils literal notranslate"><span class="pre">area</span> <span class="pre">/</span> <span class="pre">(rows</span> <span class="pre">*</span> <span class="pre">cols)</span></code></p>
</dd>
<dt><strong>feret_diameter_max</strong><span class="classifier">float</span></dt><dd><p>Maximum Feret’s diameter computed as the longest distance between
points around a region’s convex hull contour as determined by
<code class="docutils literal notranslate"><span class="pre">find_contours</span></code>. <a class="reference internal" href="#r4a29d8446b4f-5" id="id61">[5]</a></p>
</dd>
<dt><strong>image</strong><span class="classifier">(H, J) ndarray</span></dt><dd><p>Sliced binary region image which has the same size as bounding box.</p>
</dd>
<dt><strong>image_convex</strong><span class="classifier">(H, J) ndarray</span></dt><dd><p>Binary convex hull image which has the same size as bounding box.</p>
</dd>
<dt><strong>image_filled</strong><span class="classifier">(H, J) ndarray</span></dt><dd><p>Binary region image with filled holes which has the same size as
bounding box.</p>
</dd>
<dt><strong>image_intensity</strong><span class="classifier">ndarray</span></dt><dd><p>Image inside region bounding box.</p>
</dd>
<dt><strong>inertia_tensor</strong><span class="classifier">ndarray</span></dt><dd><p>Inertia tensor of the region for the rotation around its mass.</p>
</dd>
<dt><strong>inertia_tensor_eigvals</strong><span class="classifier">tuple</span></dt><dd><p>The eigenvalues of the inertia tensor in decreasing order.</p>
</dd>
<dt><strong>intensity_max</strong><span class="classifier">float</span></dt><dd><p>Value with the greatest intensity in the region.</p>
</dd>
<dt><strong>intensity_mean</strong><span class="classifier">float</span></dt><dd><p>Value with the mean intensity in the region.</p>
</dd>
<dt><strong>intensity_min</strong><span class="classifier">float</span></dt><dd><p>Value with the least intensity in the region.</p>
</dd>
<dt><strong>label</strong><span class="classifier">int</span></dt><dd><p>The label in the labeled input image.</p>
</dd>
<dt><strong>moments</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Spatial moments up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="n">row</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="n">col</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <em class="xref py py-obj">row</em>, <em class="xref py py-obj">col</em> coordinates of the region.</p>
</dd>
<dt><strong>moments_central</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Central moments (translation invariant) up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mu_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">row_c</span><span class="p">)</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">col_c</span><span class="p">)</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <em class="xref py py-obj">row</em>, <em class="xref py py-obj">col</em> coordinates of the region,
and <em class="xref py py-obj">row_c</em> and <em class="xref py py-obj">col_c</em> are the coordinates of the region’s centroid.</p>
</dd>
<dt><strong>moments_hu</strong><span class="classifier">tuple</span></dt><dd><p>Hu moments (translation, scale and rotation invariant).</p>
</dd>
<dt><strong>moments_normalized</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Normalized moments (translation and scale invariant) up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nu_ij</span> <span class="o">=</span> <span class="n">mu_ij</span> <span class="o">/</span> <span class="n">m_00</span><span class="o">^</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>where <em class="xref py py-obj">m_00</em> is the zeroth spatial moment.</p>
</dd>
<dt><strong>moments_weighted</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Spatial moments of intensity image up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wm_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="n">row</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="n">col</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <em class="xref py py-obj">row</em>, <em class="xref py py-obj">col</em> coordinates of the region.</p>
</dd>
<dt><strong>moments_weighted_central</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Central moments (translation invariant) of intensity image up to
3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wmu_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">row_c</span><span class="p">)</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">col_c</span><span class="p">)</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <em class="xref py py-obj">row</em>, <em class="xref py py-obj">col</em> coordinates of the region,
and <em class="xref py py-obj">row_c</em> and <em class="xref py py-obj">col_c</em> are the coordinates of the region’s weighted
centroid.</p>
</dd>
<dt><strong>moments_weighted_hu</strong><span class="classifier">tuple</span></dt><dd><p>Hu moments (translation, scale and rotation invariant) of intensity
image.</p>
</dd>
<dt><strong>moments_weighted_normalized</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Normalized moments (translation and scale invariant) of intensity
image up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wnu_ij</span> <span class="o">=</span> <span class="n">wmu_ij</span> <span class="o">/</span> <span class="n">wm_00</span><span class="o">^</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">wm_00</span></code> is the zeroth spatial moment (intensity-weighted area).</p>
</dd>
<dt><strong>num_pixels</strong><span class="classifier">int</span></dt><dd><p>Number of foreground pixels.</p>
</dd>
<dt><strong>orientation</strong><span class="classifier">float</span></dt><dd><p>Angle between the 0th axis (rows) and the major
axis of the ellipse that has the same second moments as the region,
ranging from <em class="xref py py-obj">-pi/2</em> to <em class="xref py py-obj">pi/2</em> counter-clockwise.</p>
</dd>
<dt><strong>perimeter</strong><span class="classifier">float</span></dt><dd><p>Perimeter of object which approximates the contour as a line
through the centers of border pixels using a 4-connectivity.</p>
</dd>
<dt><strong>perimeter_crofton</strong><span class="classifier">float</span></dt><dd><p>Perimeter of object approximated by the Crofton formula in 4
directions.</p>
</dd>
<dt><strong>slice</strong><span class="classifier">tuple of slices</span></dt><dd><p>A slice to extract the object from the source image.</p>
</dd>
<dt><strong>solidity</strong><span class="classifier">float</span></dt><dd><p>Ratio of pixels in the region to pixels of the convex hull image.</p>
</dd>
</dl>
<p>Each region also supports iteration, so that you can do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">region</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">region</span><span class="p">[</span><span class="n">prop</span><span class="p">])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r4a29d8446b4f-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</div>
<div class="citation" id="r4a29d8446b4f-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p>B. Jähne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</div>
<div class="citation" id="r4a29d8446b4f-3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</div>
<div class="citation" id="r4a29d8446b4f-4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</div>
<div class="citation" id="r4a29d8446b4f-5" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id61">5</a><span class="fn-bracket">]</span></span>
<p>W. Pabst, E. Gregorová. Characterization of particles and particle
systems, pp. 27-28. ICT Prague, 2007.
<a class="reference external" href="https://old.vscht.cz/sil/keramika/Characterization_of_particles/CPPS%20_English%20version_.pdf">https://old.vscht.cz/sil/keramika/Characterization_of_particles/CPPS%20_English%20version_.pdf</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">label</span><span class="p">,</span> <span class="n">regionprops</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">110</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_img</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">label_img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># centroid of first labeled object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>
<span class="go">(22.72987986048314, 81.91228523446583)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># centroid of first labeled object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;centroid&#39;</span><span class="p">]</span>
<span class="go">(22.72987986048314, 81.91228523446583)</span>
</pre></div>
</div>
<p>Add custom measurements by passing functions as <code class="docutils literal notranslate"><span class="pre">extra_properties</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">label</span><span class="p">,</span> <span class="n">regionprops</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">110</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_img</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pixelcount</span><span class="p">(</span><span class="n">regionmask</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">regionmask</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">label_img</span><span class="p">,</span> <span class="n">extra_properties</span><span class="o">=</span><span class="p">(</span><span class="n">pixelcount</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pixelcount</span>
<span class="go">7741</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;pixelcount&#39;</span><span class="p">]</span>
<span class="go">42</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to segment an image with image labelling. The following steps are applie..."><img alt="" src="../_images/sphx_glr_plot_label_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_label.html#sphx-glr-auto-examples-segmentation-plot-label-py"><span class="std std-ref">Label image regions</span></a></p>
  <div class="sphx-glr-thumbnail-title">Label image regions</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima..."><img alt="" src="../_images/sphx_glr_plot_regionprops_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></p>
  <div class="sphx-glr-thumbnail-title">Measure region properties</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.regionprops_table">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">regionprops_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity_image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">properties</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('label',</span> <span class="pre">'bbox')</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_properties</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_regionprops.py#L883-L1045"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.regionprops_table" title="Link to this definition">#</a></dt>
<dd><p>Compute image properties and return them as a pandas-compatible table.</p>
<p>The table is a dictionary mapping column names to value arrays. See Notes
section below for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.16.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>label_image</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Labeled input image. Labels with value 0 are ignored.</p>
</dd>
<dt><strong>intensity_image</strong><span class="classifier">(M, N[, P][, C]) ndarray, optional</span></dt><dd><p>Intensity (i.e., input) image with same size as labeled image, plus
optionally an extra dimension for multichannel data. Currently,
this extra channel dimension, if present, must be the last axis.
Default is None.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18.0: </span>The ability to provide an extra dimension for channels was added.</p>
</div>
</dd>
<dt><strong>properties</strong><span class="classifier">tuple or list of str, optional</span></dt><dd><p>Properties that will be included in the resulting dictionary
For a list of available properties, please see <a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><code class="xref py py-func docutils literal notranslate"><span class="pre">regionprops()</span></code></a>.
Users should remember to add “label” to keep track of region
identities.</p>
</dd>
<dt><strong>cache</strong><span class="classifier">bool, optional</span></dt><dd><p>Determine whether to cache calculated properties. The computation is
much faster for cached properties, whereas the memory consumption
increases.</p>
</dd>
<dt><strong>separator</strong><span class="classifier">str, optional</span></dt><dd><p>For non-scalar properties not listed in OBJECT_COLUMNS, each element
will appear in its own column, with the index of that element separated
from the property name by this separator. For example, the inertia
tensor of a 2D region will appear in four columns:
<code class="docutils literal notranslate"><span class="pre">inertia_tensor-0-0</span></code>, <code class="docutils literal notranslate"><span class="pre">inertia_tensor-0-1</span></code>, <code class="docutils literal notranslate"><span class="pre">inertia_tensor-1-0</span></code>,
and <code class="docutils literal notranslate"><span class="pre">inertia_tensor-1-1</span></code> (where the separator is <code class="docutils literal notranslate"><span class="pre">-</span></code>).</p>
<p>Object columns are those that cannot be split in this way because the
number of columns would change depending on the object. For example,
<code class="docutils literal notranslate"><span class="pre">image</span></code> and <code class="docutils literal notranslate"><span class="pre">coords</span></code>.</p>
</dd>
<dt><strong>extra_properties</strong><span class="classifier">Iterable of callables</span></dt><dd><p>Add extra property computation functions that are not included with
skimage. The name of the property is derived from the function name,
the dtype is inferred by calling the function on a small sample.
If the name of an extra property clashes with the name of an existing
property the extra property will not be visible and a UserWarning is
issued. A property computation function must take a region mask as its
first argument. If the property requires an intensity image, it must
accept the intensity image as the second argument.</p>
</dd>
<dt><strong>spacing: tuple of float, shape (ndim, )</strong></dt><dd><p>The pixel spacing along each axis of the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out_dict</strong><span class="classifier">dict</span></dt><dd><p>Dictionary mapping property names to an array of values of that
property, one value per region. This dictionary can be used as input to
pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> to map property names to columns in the frame and
regions to rows. If the image has no regions,
the arrays will have length 0, but the correct type.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Each column contains either a scalar property, an object property, or an
element in a multidimensional array.</p>
<p>Properties with scalar values for each region, such as “eccentricity”, will
appear as a float or int array with that property name as key.</p>
<p>Multidimensional properties <em>of fixed size</em> for a given image dimension,
such as “centroid” (every centroid will have three elements in a 3D image,
no matter the region size), will be split into that many columns, with the
name {property_name}{separator}{element_num} (for 1D properties),
{property_name}{separator}{elem_num0}{separator}{elem_num1} (for 2D
properties), and so on.</p>
<p>For multidimensional properties that don’t have a fixed size, such as
“image” (the image of a region varies in size depending on the region
size), an object array will be used, with the corresponding property name
as the key.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span><span class="p">,</span> <span class="n">measure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_image</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">image</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops_table</span><span class="p">(</span><span class="n">label_image</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;inertia_tensor&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="s1">&#39;inertia_tensor_eigvals&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span>  
<span class="go">{&#39;label&#39;: array([ 1,  2, ...]), ...</span>
<span class="go"> &#39;inertia_tensor-0-0&#39;: array([  4.012...e+03,   8.51..., ...]), ...</span>
<span class="go"> ...,</span>
<span class="go"> &#39;inertia_tensor_eigvals-1&#39;: array([  2.67...e+02,   2.83..., ...])}</span>
</pre></div>
</div>
<p>The resulting dictionary can be directly passed to pandas, if installed, to
obtain a clean DataFrame:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">props</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>  
<span class="go">   label  inertia_tensor-0-0  ...  inertia_tensor_eigvals-1</span>
<span class="go">0      1         4012.909888  ...                267.065503</span>
<span class="go">1      2            8.514739  ...                  2.834806</span>
<span class="go">2      3            0.666667  ...                  0.000000</span>
<span class="go">3      4            0.000000  ...                  0.000000</span>
<span class="go">4      5            0.222222  ...                  0.111111</span>
</pre></div>
</div>
<p>[5 rows x 7 columns]</p>
<p>If we want to measure a feature that does not come as a built-in
property, we can define custom functions and pass them as
<code class="docutils literal notranslate"><span class="pre">extra_properties</span></code>. For example, we can create a custom function
that measures the intensity quartiles in a region:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span><span class="p">,</span> <span class="n">measure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">quartiles</span><span class="p">(</span><span class="n">regionmask</span><span class="p">,</span> <span class="n">intensity</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">intensity</span><span class="p">[</span><span class="n">regionmask</span><span class="p">],</span> <span class="n">q</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_image</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">image</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops_table</span><span class="p">(</span><span class="n">label_image</span><span class="p">,</span> <span class="n">intensity_image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="n">properties</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,),</span>
<span class="gp">... </span>                                  <span class="n">extra_properties</span><span class="o">=</span><span class="p">(</span><span class="n">quartiles</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">props</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span> 
<span class="go">       label  quartiles-0  quartiles-1  quartiles-2</span>
<span class="go">0      1       117.00        123.0        130.0</span>
<span class="go">1      2       111.25        112.0        114.0</span>
<span class="go">2      3       111.00        111.0        111.0</span>
<span class="go">3      4       111.00        111.5        112.5</span>
<span class="go">4      5       112.50        113.0        114.0</span>
</pre></div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This toy example shows how to compute the size of every labelled region in a series of 10 image..."><img alt="" src="../_images/sphx_glr_plot_regionprops_table_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops_table.html#sphx-glr-auto-examples-segmentation-plot-regionprops-table-py"><span class="std std-ref">Explore and visualize region properties with pandas</span></a></p>
  <div class="sphx-glr-thumbnail-title">Explore and visualize region properties with pandas</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima..."><img alt="" src="../_images/sphx_glr_plot_regionprops_thumb.png" />
<p><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></p>
  <div class="sphx-glr-thumbnail-title">Measure region properties</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example, we identify and track the solid-liquid (S-L) interface in a nickel-based alloy..."><img alt="" src="../_images/sphx_glr_plot_solidification_tracking_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_solidification_tracking.html#sphx-glr-auto-examples-applications-plot-solidification-tracking-py"><span class="std std-ref">Track solidification of a metallic alloy</span></a></p>
  <div class="sphx-glr-thumbnail-title">Track solidification of a metallic alloy</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example reproduces a well-established workflow in bioimage data analysis for measuring the..."><img alt="" src="../_images/sphx_glr_plot_fluorescence_nuclear_envelope_thumb.png" />
<p><a class="reference internal" href="../auto_examples/applications/plot_fluorescence_nuclear_envelope.html#sphx-glr-auto-examples-applications-plot-fluorescence-nuclear-envelope-py"><span class="std std-ref">Measure fluorescence intensity at the nuclear envelope</span></a></p>
  <div class="sphx-glr-thumbnail-title">Measure fluorescence intensity at the nuclear envelope</div>
</div></div></dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.shannon_entropy">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">shannon_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/entropy.py#L5-L41"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.shannon_entropy" title="Link to this definition">#</a></dt>
<dd><p>Calculate the Shannon entropy of an image.</p>
<p>The Shannon entropy is defined as S = -sum(pk * log(pk)),
where pk are frequency/probability of pixels of value k.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>base</strong><span class="classifier">float, optional</span></dt><dd><p>The logarithmic base to use.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>entropy</strong><span class="classifier">float</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The returned value is measured in bits or shannon (Sh) for base=2, natural
unit (nat) for base=np.e and hartley (Hart) for base=10.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rd3de3b6e4b40-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">https://en.wikipedia.org/wiki/Entropy_(information_theory)</a></p>
</div>
<div class="citation" id="rd3de3b6e4b40-2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wiktionary.org/wiki/Shannon_entropy">https://en.wiktionary.org/wiki/Shannon_entropy</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">shannon_entropy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shannon_entropy</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="go">7.231695011055706</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="skimage.measure.subdivide_polygon">
<span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">subdivide_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_ends</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/_polygon.py#L109-L168"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.subdivide_polygon" title="Link to this definition">#</a></dt>
<dd><p>Subdivision of polygonal curves using B-Splines.</p>
<p>Note that the resulting curve is always within the convex hull of the
original polygon. Circular polygons stay closed after subdivision.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Coordinate array.</p>
</dd>
<dt><strong>degree</strong><span class="classifier">{1, 2, 3, 4, 5, 6, 7}, optional</span></dt><dd><p>Degree of B-Spline. Default is 2.</p>
</dd>
<dt><strong>preserve_ends</strong><span class="classifier">bool, optional</span></dt><dd><p>Preserve first and last coordinate of non-circular polygon. Default is
False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(M, 2) array</span></dt><dd><p>Subdivided coordinate array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r13f3ce062a97-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf">http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf</a></p>
</div>
</div>
<div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to approximate (Douglas-Peucker algorithm) and subdivide (B-Splines) pol..."><img alt="" src="../_images/sphx_glr_plot_polygon_thumb.png" />
<p><a class="reference internal" href="../auto_examples/edges/plot_polygon.html#sphx-glr-auto-examples-edges-plot-polygon-py"><span class="std std-ref">Approximate and subdivide polygons</span></a></p>
  <div class="sphx-glr-thumbnail-title">Approximate and subdivide polygons</div>
</div></div></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="skimage.measure.CircleModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">CircleModel</span></span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L220-L377"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.CircleModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseModel</span></code></p>
<p>Total least squares estimator for 2D circles.</p>
<p>The functional model of the circle is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">yc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>This estimator minimizes the squared distances from all points to the
circle:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">min</span><span class="p">{</span> <span class="nb">sum</span><span class="p">((</span><span class="n">r</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">x_i</span> <span class="o">-</span> <span class="n">xc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y_i</span> <span class="o">-</span> <span class="n">yc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>A minimum number of 3 points is required to solve for the parameters.</p>
<p class="rubric">Notes</p>
<p>The estimation is carried out using a 2D version of the spherical
estimation given in <a class="reference internal" href="#r623adc11879f-1" id="id70">[1]</a>.</p>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r623adc11879f-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id70">1</a><span class="fn-bracket">]</span></span>
<p>Jekel, Charles F. Obtaining non-linear orthotropic material models
for pvc-coated polyester via inverse bubble inflation.
Thesis (MEng), Stellenbosch University, 2016. Appendix A, pp. 83-87.
<a class="reference external" href="https://hdl.handle.net/10019.1/98627">https://hdl.handle.net/10019.1/98627</a></p>
</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xy</span> <span class="o">=</span> <span class="n">CircleModel</span><span class="p">()</span><span class="o">.</span><span class="n">predict_xy</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">CircleModel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">(2.0, 3.0, 4.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">residuals</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="go">array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,</span>
<span class="go">       0., 0., 0., 0., 0., 0., 0., 0.])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">tuple</span></dt><dd><p>Circle model parameters in the following order <em class="xref py py-obj">xc</em>, <em class="xref py py-obj">yc</em>, <em class="xref py py-obj">r</em>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.measure.CircleModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L25-L26"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.CircleModel.__init__" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.measure.CircleModel.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L267-L325"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.CircleModel.estimate" title="Link to this definition">#</a></dt>
<dd><p>Estimate circle model from data using total least squares.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(N, 2) array</span></dt><dd><p>N points with <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> coordinates, respectively.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.measure.CircleModel.predict_xy">
<span class="sig-name descname"><span class="pre">predict_xy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L353-L377"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.CircleModel.predict_xy" title="Link to this definition">#</a></dt>
<dd><p>Predict x- and y-coordinates using the estimated model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">array</span></dt><dd><p>Angles in circle in radians. Angles start to count from positive
x-axis to positive y-axis in a right-handed system.</p>
</dd>
<dt><strong>params</strong><span class="classifier">(3, ) array, optional</span></dt><dd><p>Optional custom parameter set.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xy</strong><span class="classifier">(…, 2) array</span></dt><dd><p>Predicted x- and y-coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.measure.CircleModel.residuals">
<span class="sig-name descname"><span class="pre">residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L327-L351"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.CircleModel.residuals" title="Link to this definition">#</a></dt>
<dd><p>Determine residuals of data to model.</p>
<p>For each point the shortest distance to the circle is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(N, 2) array</span></dt><dd><p>N points with <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> coordinates, respectively.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N, ) array</span></dt><dd><p>Residual for each data point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="skimage.measure.EllipseModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">EllipseModel</span></span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L380-L642"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.EllipseModel" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseModel</span></code></p>
<p>Total least squares estimator for 2D ellipses.</p>
<p>The functional model of the ellipse is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xt</span> <span class="o">=</span> <span class="n">xc</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">yt</span> <span class="o">=</span> <span class="n">yc</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">xt</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">yt</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">(xt,</span> <span class="pre">yt)</span></code> is the closest point on the ellipse to <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code>. Thus
d is the shortest distance from the point to the ellipse.</p>
<p>The estimator is based on a least squares minimization. The optimal
solution is computed directly, no iterations are required. This leads
to a simple, stable and robust fitting method.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">params</span></code> attribute contains the parameters in the following order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">theta</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xy</span> <span class="o">=</span> <span class="n">EllipseModel</span><span class="p">()</span><span class="o">.</span><span class="n">predict_xy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span>
<span class="gp">... </span>                               <span class="n">params</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">30</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ellipse</span> <span class="o">=</span> <span class="n">EllipseModel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ellipse</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ellipse</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([10.  , 15.  ,  8.  ,  4.  ,  0.52])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">ellipse</span><span class="o">.</span><span class="n">residuals</span><span class="p">(</span><span class="n">xy</span><span class="p">)),</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,</span>
<span class="go">       0., 0., 0., 0., 0., 0., 0., 0.])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">tuple</span></dt><dd><p>Ellipse model parameters in the following order <em class="xref py py-obj">xc</em>, <em class="xref py py-obj">yc</em>, <em class="xref py py-obj">a</em>, <em class="xref py py-obj">b</em>,
<em class="xref py py-obj">theta</em>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.measure.EllipseModel.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L25-L26"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.EllipseModel.__init__" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.measure.EllipseModel.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L421-L547"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.EllipseModel.estimate" title="Link to this definition">#</a></dt>
<dd><p>Estimate ellipse model from data using total least squares.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(N, 2) array</span></dt><dd><p>N points with <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> coordinates, respectively.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="rb82f40f15f1b-1" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p>Halir, R.; Flusser, J. “Numerically stable direct least squares
fitting of ellipses”. In Proc. 6th International Conference in
Central Europe on Computer Graphics and Visualization.
WSCG (Vol. 98, pp. 125-132).</p>
</div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.measure.EllipseModel.predict_xy">
<span class="sig-name descname"><span class="pre">predict_xy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L611-L642"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.EllipseModel.predict_xy" title="Link to this definition">#</a></dt>
<dd><p>Predict x- and y-coordinates using the estimated model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">array</span></dt><dd><p>Angles in circle in radians. Angles start to count from positive
x-axis to positive y-axis in a right-handed system.</p>
</dd>
<dt><strong>params</strong><span class="classifier">(5, ) array, optional</span></dt><dd><p>Optional custom parameter set.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>xy</strong><span class="classifier">(…, 2) array</span></dt><dd><p>Predicted x- and y-coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.measure.EllipseModel.residuals">
<span class="sig-name descname"><span class="pre">residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L549-L609"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.EllipseModel.residuals" title="Link to this definition">#</a></dt>
<dd><p>Determine residuals of data to model.</p>
<p>For each point the shortest distance to the ellipse is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(N, 2) array</span></dt><dd><p>N points with <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> coordinates, respectively.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N, ) array</span></dt><dd><p>Residual for each data point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="skimage.measure.LineModelND">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">skimage.measure.</span></span><span class="sig-name descname"><span class="pre">LineModelND</span></span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L29-L217"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.LineModelND" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseModel</span></code></p>
<p>Total least squares estimator for N-dimensional lines.</p>
<p>In contrast to ordinary least squares line estimation, this estimator
minimizes the orthogonal distances of points to the estimated line.</p>
<p>Lines are defined by a point (origin) and a unit vector (direction)
according to the following vector equation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">origin</span> <span class="o">+</span> <span class="k">lambda</span> <span class="o">*</span> <span class="n">direction</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lm</span> <span class="o">=</span> <span class="n">LineModelND</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lm</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">(array([1.5 , 5.25]), array([0.5547 , 0.83205]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">lm</span><span class="o">.</span><span class="n">residuals</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="go">array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,</span>
<span class="go">       0., 0., 0., 0., 0., 0., 0., 0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">predict_y</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="mi">5</span><span class="p">]),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([4.5  , 4.562, 4.625, 4.688, 4.75 ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lm</span><span class="o">.</span><span class="n">predict_x</span><span class="p">(</span><span class="n">y</span><span class="p">[:</span><span class="mi">5</span><span class="p">]),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([1.   , 1.042, 1.083, 1.125, 1.167])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">tuple</span></dt><dd><p>Line model parameters in the following order <em class="xref py py-obj">origin</em>, <em class="xref py py-obj">direction</em>.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="skimage.measure.LineModelND.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L25-L26"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.LineModelND.__init__" title="Link to this definition">#</a></dt>
<dd><div class="sphx-glr-thumbnails"><div class="sphx-glr-thumbcontainer" tooltip="In this example we see how to robustly fit a line model to faulty data using the RANSAC (random..."><img alt="" src="../_images/sphx_glr_plot_ransac_thumb.png" />
<p><a class="reference internal" href="../auto_examples/transform/plot_ransac.html#sphx-glr-auto-examples-transform-plot-ransac-py"><span class="std std-ref">Robust line model estimation using RANSAC</span></a></p>
  <div class="sphx-glr-thumbnail-title">Robust line model estimation using RANSAC</div>
</div></div></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.measure.LineModelND.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L65-L100"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.LineModelND.estimate" title="Link to this definition">#</a></dt>
<dd><p>Estimate line model from data.</p>
<p>This minimizes the sum of shortest (orthogonal) distances
from the given data points to the estimated line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(N, dim) array</span></dt><dd><p>N points in a space of dimensionality dim &gt;= 2.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.measure.LineModelND.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L133-L171"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.LineModelND.predict" title="Link to this definition">#</a></dt>
<dd><p>Predict intersection of the estimated line model with a hyperplane
orthogonal to a given axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">(n, 1) array</span></dt><dd><p>Coordinates along an axis.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>Axis orthogonal to the hyperplane intersecting the line.</p>
</dd>
<dt><strong>params</strong><span class="classifier">(2, ) array, optional</span></dt><dd><p>Optional custom parameter set in the form (<em class="xref py py-obj">origin</em>, <em class="xref py py-obj">direction</em>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(n, m) array</span></dt><dd><p>Predicted coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If the line is parallel to the given axis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.measure.LineModelND.predict_x">
<span class="sig-name descname"><span class="pre">predict_x</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L173-L194"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.LineModelND.predict_x" title="Link to this definition">#</a></dt>
<dd><p>Predict x-coordinates for 2D lines using the estimated model.</p>
<p>Alias for:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">predict</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>y</strong><span class="classifier">array</span></dt><dd><p>y-coordinates.</p>
</dd>
<dt><strong>params</strong><span class="classifier">(2, ) array, optional</span></dt><dd><p>Optional custom parameter set in the form (<em class="xref py py-obj">origin</em>, <em class="xref py py-obj">direction</em>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array</span></dt><dd><p>Predicted x-coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.measure.LineModelND.predict_y">
<span class="sig-name descname"><span class="pre">predict_y</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L196-L217"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.LineModelND.predict_y" title="Link to this definition">#</a></dt>
<dd><p>Predict y-coordinates for 2D lines using the estimated model.</p>
<p>Alias for:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x</strong><span class="classifier">array</span></dt><dd><p>x-coordinates.</p>
</dd>
<dt><strong>params</strong><span class="classifier">(2, ) array, optional</span></dt><dd><p>Optional custom parameter set in the form (<em class="xref py py-obj">origin</em>, <em class="xref py py-obj">direction</em>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>y</strong><span class="classifier">array</span></dt><dd><p>Predicted y-coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="skimage.measure.LineModelND.residuals">
<span class="sig-name descname"><span class="pre">residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.22.0/skimage/measure/fit.py#L102-L131"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#skimage.measure.LineModelND.residuals" title="Link to this definition">#</a></dt>
<dd><p>Determine residuals of data to model.</p>
<p>For each point, the shortest (orthogonal) distance to the line is
returned. It is obtained by projecting the data onto the line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">(N, dim) array</span></dt><dd><p>N points in a space of dimension dim.</p>
</dd>
<dt><strong>params</strong><span class="classifier">(2, ) array, optional</span></dt><dd><p>Optional custom parameter set in the form (<em class="xref py py-obj">origin</em>, <em class="xref py py-obj">direction</em>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N, ) array</span></dt><dd><p>Residual for each data point.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


                </article>
              
              
              
              
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.approximate_polygon"><code class="docutils literal notranslate"><span class="pre">approximate_polygon()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.block_reduce"><code class="docutils literal notranslate"><span class="pre">block_reduce()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.blur_effect"><code class="docutils literal notranslate"><span class="pre">blur_effect()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.centroid"><code class="docutils literal notranslate"><span class="pre">centroid()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.euler_number"><code class="docutils literal notranslate"><span class="pre">euler_number()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.find_contours"><code class="docutils literal notranslate"><span class="pre">find_contours()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.grid_points_in_poly"><code class="docutils literal notranslate"><span class="pre">grid_points_in_poly()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.inertia_tensor"><code class="docutils literal notranslate"><span class="pre">inertia_tensor()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.inertia_tensor_eigvals"><code class="docutils literal notranslate"><span class="pre">inertia_tensor_eigvals()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.intersection_coeff"><code class="docutils literal notranslate"><span class="pre">intersection_coeff()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.label"><code class="docutils literal notranslate"><span class="pre">label()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.manders_coloc_coeff"><code class="docutils literal notranslate"><span class="pre">manders_coloc_coeff()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.manders_overlap_coeff"><code class="docutils literal notranslate"><span class="pre">manders_overlap_coeff()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.marching_cubes"><code class="docutils literal notranslate"><span class="pre">marching_cubes()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.mesh_surface_area"><code class="docutils literal notranslate"><span class="pre">mesh_surface_area()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.moments"><code class="docutils literal notranslate"><span class="pre">moments()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.moments_central"><code class="docutils literal notranslate"><span class="pre">moments_central()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.moments_coords"><code class="docutils literal notranslate"><span class="pre">moments_coords()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.moments_coords_central"><code class="docutils literal notranslate"><span class="pre">moments_coords_central()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.moments_hu"><code class="docutils literal notranslate"><span class="pre">moments_hu()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.moments_normalized"><code class="docutils literal notranslate"><span class="pre">moments_normalized()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.pearson_corr_coeff"><code class="docutils literal notranslate"><span class="pre">pearson_corr_coeff()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.perimeter"><code class="docutils literal notranslate"><span class="pre">perimeter()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.perimeter_crofton"><code class="docutils literal notranslate"><span class="pre">perimeter_crofton()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.points_in_poly"><code class="docutils literal notranslate"><span class="pre">points_in_poly()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.profile_line"><code class="docutils literal notranslate"><span class="pre">profile_line()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.ransac"><code class="docutils literal notranslate"><span class="pre">ransac()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.regionprops"><code class="docutils literal notranslate"><span class="pre">regionprops()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.regionprops_table"><code class="docutils literal notranslate"><span class="pre">regionprops_table()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.shannon_entropy"><code class="docutils literal notranslate"><span class="pre">shannon_entropy()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.subdivide_polygon"><code class="docutils literal notranslate"><span class="pre">subdivide_polygon()</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.CircleModel"><code class="docutils literal notranslate"><span class="pre">CircleModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.CircleModel.__init__"><code class="docutils literal notranslate"><span class="pre">CircleModel.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.CircleModel.estimate"><code class="docutils literal notranslate"><span class="pre">CircleModel.estimate()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.CircleModel.predict_xy"><code class="docutils literal notranslate"><span class="pre">CircleModel.predict_xy()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.CircleModel.residuals"><code class="docutils literal notranslate"><span class="pre">CircleModel.residuals()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.EllipseModel"><code class="docutils literal notranslate"><span class="pre">EllipseModel</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.EllipseModel.__init__"><code class="docutils literal notranslate"><span class="pre">EllipseModel.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.EllipseModel.estimate"><code class="docutils literal notranslate"><span class="pre">EllipseModel.estimate()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.EllipseModel.predict_xy"><code class="docutils literal notranslate"><span class="pre">EllipseModel.predict_xy()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.EllipseModel.residuals"><code class="docutils literal notranslate"><span class="pre">EllipseModel.residuals()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.LineModelND"><code class="docutils literal notranslate"><span class="pre">LineModelND</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.LineModelND.__init__"><code class="docutils literal notranslate"><span class="pre">LineModelND.__init__()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.LineModelND.estimate"><code class="docutils literal notranslate"><span class="pre">LineModelND.estimate()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.LineModelND.predict"><code class="docutils literal notranslate"><span class="pre">LineModelND.predict()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.LineModelND.predict_x"><code class="docutils literal notranslate"><span class="pre">LineModelND.predict_x()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.LineModelND.predict_y"><code class="docutils literal notranslate"><span class="pre">LineModelND.predict_y()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#skimage.measure.LineModelND.residuals"><code class="docutils literal notranslate"><span class="pre">LineModelND.residuals()</span></code></a></li>
</ul>
</li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">
  <div class="tocsection sourcelink">
    <a href="../_sources/api/skimage.measure.rst.txt">
      <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=ac02cc09edc035673794"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
  <p class="copyright">
    
      © Copyright 2013-2023, the scikit-image team.
      <br/>
    
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.14.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>