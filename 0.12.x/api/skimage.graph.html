


<!DOCTYPE html>
<html lang="en">
<head>
        <title>Module: graph &mdash; skimage v0.12.2 docs</title>
    
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../_static/css/custom.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
    
    <script src="http://code.jquery.com/jquery-latest.js"></script>
    <script src="../_static/js/bootstrap.min.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.12.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <link rel="top" title="skimage v0.12.2 docs" href="../index.html" />
        <link rel="up" title="API Reference" href="api.html" />
        <link rel="next" title="Module: io" href="skimage.io.html" />
        <link rel="prev" title="Module: future.graph" href="skimage.future.graph.html" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="shortcut icon" href="../_static/favicon.ico">
</head>
<body class="container">
    <a href="http://scikit-image.org" class="logo"><img src="../_static/img/logo.png" alt=""></a>
    <div class="clearfix"></div>
    <div class="navbar">
        <div class="navbar-inner">
            <ul class="nav">
                <li><a href="/">Home</a></li>
<li><a href="/docs/stable/install.html">Download</a></li>
<li><a href="/docs/dev/auto_examples">Gallery</a></li>
<li><a href="/docs/dev">Documentation</a></li>
<li><a href="https://github.com/scikit-image/scikit-image">
    <img src="../_static/GitHub-Mark-32px.png"
        style="height: 15px; width: 15px;
               display: inline; float: none;
               padding-bottom: 3px;">
    Source</a>
</li>
            </ul>
            <form class="navbar-form pull-right" action="../search.html" method="get">
                <input type="text" class="search span3" name="q" placeholder="Search documentation ...">
                <input type="hidden" name="check_keywords" value="yes" >
                <input type="hidden" name="area" value="default" >
            </form>
        </div>
    </div>
    <div class="row">
        <div class="span9">
            
  <div class="section" id="module-skimage.graph">
<span id="module-graph"></span><h1>Module: <code class="xref py py-mod docutils literal"><span class="pre">graph</span></code><a class="headerlink" href="#module-skimage.graph" title="Permalink to this headline">¶</a></h1>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#skimage.graph.route_through_array" title="skimage.graph.route_through_array"><code class="xref py py-obj docutils literal"><span class="pre">skimage.graph.route_through_array</span></code></a>(array,&nbsp;...)</td>
<td>Simple example of how to use the MCP and MCP_Geometric classes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.graph.shortest_path" title="skimage.graph.shortest_path"><code class="xref py py-obj docutils literal"><span class="pre">skimage.graph.shortest_path</span></code></a>(arr[,&nbsp;reach,&nbsp;...])</td>
<td>Find the shortest path through an n-d array from one side to another.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.graph.MCP" title="skimage.graph.MCP"><code class="xref py py-obj docutils literal"><span class="pre">skimage.graph.MCP</span></code></a>(costs[,&nbsp;offsets,&nbsp;...])</td>
<td>A class for finding the minimum cost path through a given n-d costs array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.graph.MCP_Connect" title="skimage.graph.MCP_Connect"><code class="xref py py-obj docutils literal"><span class="pre">skimage.graph.MCP_Connect</span></code></a></td>
<td>Connect source points using the distance-weighted minimum cost function.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.graph.MCP_Flexible" title="skimage.graph.MCP_Flexible"><code class="xref py py-obj docutils literal"><span class="pre">skimage.graph.MCP_Flexible</span></code></a>(costs[,&nbsp;offsets,&nbsp;...])</td>
<td>Find minimum cost paths through an N-d costs array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.graph.MCP_Geometric" title="skimage.graph.MCP_Geometric"><code class="xref py py-obj docutils literal"><span class="pre">skimage.graph.MCP_Geometric</span></code></a>(costs[,&nbsp;...])</td>
<td>Find distance-weighted minimum cost paths through an n-d costs array.</td>
</tr>
</tbody>
</table>
<div class="section" id="route-through-array">
<h2>route_through_array<a class="headerlink" href="#route-through-array" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.graph.route_through_array">
<code class="descclassname">skimage.graph.</code><code class="descname">route_through_array</code><span class="sig-paren">(</span><em>array</em>, <em>start</em>, <em>end</em>, <em>fully_connected=True</em>, <em>geometric=True</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/graph/mcp.py#L4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.graph.route_through_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple example of how to use the MCP and MCP_Geometric classes.</p>
<p>See the MCP and MCP_Geometric class documentation for explanation of the
path-finding algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>array</strong> : ndarray</p>
<blockquote>
<div><p>Array of costs.</p>
</div></blockquote>
<p><strong>start</strong> : iterable</p>
<blockquote>
<div><p>n-d index into <cite>array</cite> defining the starting point</p>
</div></blockquote>
<p><strong>end</strong> : iterable</p>
<blockquote>
<div><p>n-d index into <cite>array</cite> defining the end point</p>
</div></blockquote>
<p><strong>fully_connected</strong> : bool (optional)</p>
<blockquote>
<div><p>If True, diagonal moves are permitted, if False, only axial moves.</p>
</div></blockquote>
<p><strong>geometric</strong> : bool (optional)</p>
<blockquote>
<div><p>If True, the MCP_Geometric class is used to calculate costs, if False,
the MCP base class is used. See the class documentation for
an explanation of the differences between MCP and MCP_Geometric.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>path</strong> : list</p>
<blockquote>
<div><p>List of n-d index tuples defining the path from <cite>start</cite> to <cite>end</cite>.</p>
</div></blockquote>
<p><strong>cost</strong> : float</p>
<blockquote class="last">
<div><p>Cost of the path. If <cite>geometric</cite> is False, the cost of the path is
the sum of the values of <cite>array</cite> along the path. If <cite>geometric</cite> is
True, a finer computation is made (see the documentation of the
MCP_Geometric class).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#skimage.graph.MCP" title="skimage.graph.MCP"><code class="xref py py-obj docutils literal"><span class="pre">MCP</span></code></a>, <a class="reference internal" href="#skimage.graph.MCP_Geometric" title="skimage.graph.MCP_Geometric"><code class="xref py py-obj docutils literal"><span class="pre">MCP_Geometric</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.graph</span> <span class="kn">import</span> <span class="n">route_through_array</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span>
<span class="go">array([[ 1,  3],</span>
<span class="go">       [10, 12]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Forbid diagonal steps</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">route_through_array</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">fully_connected</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">([(0, 0), (0, 1), (1, 1)], 9.5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Now allow diagonal steps: the path goes directly from start to end</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">route_through_array</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">([(0, 0), (1, 1)], 9.1923881554251192)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Cost is the sum of array values along the path (16 = 1 + 3 + 12)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">route_through_array</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">fully_connected</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
<span class="gp">... </span><span class="n">geometric</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">([(0, 0), (0, 1), (1, 1)], 16.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Larger array where we display the path that is selected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">((</span><span class="mi">36</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span>
<span class="go">array([[ 0,  1,  2,  3,  4,  5],</span>
<span class="go">       [ 6,  7,  8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15, 16, 17],</span>
<span class="go">       [18, 19, 20, 21, 22, 23],</span>
<span class="go">       [24, 25, 26, 27, 28, 29],</span>
<span class="go">       [30, 31, 32, 33, 34, 35]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Find the path with lowest cost</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">route_through_array</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span>
<span class="go">array([[1, 1, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1],</span>
<span class="go">       [0, 0, 0, 0, 0, 1],</span>
<span class="go">       [0, 0, 0, 0, 0, 1],</span>
<span class="go">       [0, 0, 0, 0, 0, 1],</span>
<span class="go">       [0, 0, 0, 0, 0, 1]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="shortest-path">
<h2>shortest_path<a class="headerlink" href="#shortest-path" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.graph.shortest_path">
<code class="descclassname">skimage.graph.</code><code class="descname">shortest_path</code><span class="sig-paren">(</span><em>arr</em>, <em>reach=1</em>, <em>axis=-1</em>, <em>output_indexlist=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.12.2/skimage/graph/spath.py#L5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.graph.shortest_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the shortest path through an n-d array from one side to another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>arr</strong> : ndarray of float64</p>
<p><strong>reach</strong> : int, optional</p>
<blockquote>
<div><p>By default (<code class="docutils literal"><span class="pre">reach</span> <span class="pre">=</span> <span class="pre">1</span></code>), the shortest path can only move
one row up or down for every step it moves forward (i.e.,
the path gradient is limited to 1). <cite>reach</cite> defines the
number of elements that can be skipped along each non-axis
dimension at each step.</p>
</div></blockquote>
<p><strong>axis</strong> : int, optional</p>
<blockquote>
<div><p>The axis along which the path must always move forward (default -1)</p>
</div></blockquote>
<p><strong>output_indexlist: bool, optional</strong></p>
<blockquote>
<div><p>See return value <cite>p</cite> for explanation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : iterable of int</p>
<blockquote>
<div><p>For each step along <cite>axis</cite>, the coordinate of the shortest path.
If <cite>output_indexlist</cite> is True, then the path is returned as a list of
n-d tuples that index into <cite>arr</cite>. If False, then the path is returned
as an array listing the coordinates of the path along the non-axis
dimensions for each step along the axis dimension. That is,
<cite>p.shape == (arr.shape[axis], arr.ndim-1)</cite> except that p is squeezed
before returning so if <cite>arr.ndim == 2</cite>, then
<cite>p.shape == (arr.shape[axis],)</cite></p>
</div></blockquote>
<p><strong>cost</strong> : float</p>
<blockquote class="last">
<div><p>Cost of path.  This is the absolute sum of all the
differences along the path.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="mcp">
<h2><a class="reference internal" href="#skimage.graph.MCP" title="skimage.graph.MCP"><code class="xref py py-class docutils literal"><span class="pre">MCP</span></code></a><a class="headerlink" href="#mcp" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.graph.MCP">
<em class="property">class </em><code class="descclassname">skimage.graph.</code><code class="descname">MCP</code><span class="sig-paren">(</span><em>costs</em>, <em>offsets=None</em>, <em>fully_connected=True</em>, <em>sampling=None</em><span class="sig-paren">)</span><a class="headerlink" href="#skimage.graph.MCP" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>A class for finding the minimum cost path through a given n-d costs array.</p>
<p>Given an n-d costs array, this class can be used to find the minimum-cost
path through that array from any set of points to any other set of points.
Basic usage is to initialize the class and call find_costs() with a one
or more starting indices (and an optional list of end indices). After
that, call traceback() one or more times to find the path from any given
end-position to the closest starting index. New paths through the same
costs array can be found by calling find_costs() repeatedly.</p>
<p>The cost of a path is calculated simply as the sum of the values of the
<cite>costs</cite> array at each point on the path. The class MCP_Geometric, on the
other hand, accounts for the fact that diagonal vs. axial moves are of
different lengths, and weights the path cost accordingly.</p>
<p>Array elements with infinite or negative costs will simply be ignored, as
will paths whose cumulative cost overflows to infinite.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>costs</strong> : ndarray</p>
<p><strong>offsets</strong> : iterable, optional</p>
<blockquote>
<div><p>A list of offset tuples: each offset specifies a valid move from a
given n-d position.
If not provided, offsets corresponding to a singly- or fully-connected
n-d neighborhood will be constructed with make_offsets(), using the
<cite>fully_connected</cite> parameter value.</p>
</div></blockquote>
<p><strong>fully_connected</strong> : bool, optional</p>
<blockquote>
<div><p>If no <cite>offsets</cite> are provided, this determines the connectivity of the
generated neighborhood. If true, the path may go along diagonals
between elements of the <cite>costs</cite> array; otherwise only axial moves are
permitted.</p>
</div></blockquote>
<p><strong>sampling</strong> : tuple, optional</p>
<blockquote class="last">
<div><p>For each dimension, specifies the distance between two cells/voxels.
If not given or None, the distance is assumed unit.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="3%" />
<col width="97%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>offsets</td>
<td>(ndarray) Equivalent to the <cite>offsets</cite> provided to the constructor, or if none were so provided, the offsets created for the requested n-d neighborhood. These are useful for interpreting the <cite>traceback</cite> array returned by the find_costs() method.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.graph.MCP.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>costs</em>, <em>offsets=None</em>, <em>fully_connected=True</em>, <em>sampling=None</em><span class="sig-paren">)</span><a class="headerlink" href="#skimage.graph.MCP.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>See class documentation.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.MCP.find_costs">
<code class="descname">find_costs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skimage.graph.MCP.find_costs" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the minimum-cost path from the given starting points.</p>
<p>This method finds the minimum-cost path to the specified ending
indices from any one of the specified starting indices. If no end
positions are given, then the minimum-cost path to every position in
the costs array will be found.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>starts</strong> : iterable</p>
<blockquote>
<div><p>A list of n-d starting indices (where n is the dimension of the
<cite>costs</cite> array). The minimum cost path to the closest/cheapest
starting point will be found.</p>
</div></blockquote>
<p><strong>ends</strong> : iterable, optional</p>
<blockquote>
<div><p>A list of n-d ending indices.</p>
</div></blockquote>
<p><strong>find_all_ends</strong> : bool, optional</p>
<blockquote>
<div><p>If &#8216;True&#8217; (default), the minimum-cost-path to every specified
end-position will be found; otherwise the algorithm will stop when
a a path is found to any end-position. (If no <cite>ends</cite> were
specified, then this parameter has no effect.)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cumulative_costs</strong> : ndarray</p>
<blockquote>
<div><p>Same shape as the <cite>costs</cite> array; this array records the minimum
cost path from the nearest/cheapest starting index to each index
considered. (If <cite>ends</cite> were specified, not all elements in the
array will necessarily be considered: positions not evaluated will
have a cumulative cost of inf. If <cite>find_all_ends</cite> is &#8216;False&#8217;, only
one of the specified end-positions will have a finite cumulative
cost.)</p>
</div></blockquote>
<p><strong>traceback</strong> : ndarray</p>
<blockquote class="last">
<div><p>Same shape as the <cite>costs</cite> array; this array contains the offset to
any given index from its predecessor index. The offset indices
index into the <cite>offsets</cite> attribute, which is a array of n-d
offsets. In the 2-d case, if offsets[traceback[x, y]] is (-1, -1),
that means that the predecessor of [x, y] in the minimum cost path
to some start position is [x+1, y+1]. Note that if the
offset_index is -1, then the given index was not considered.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.MCP.goal_reached">
<code class="descname">goal_reached</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skimage.graph.MCP.goal_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>int goal_reached(int index, float cumcost)
This method is called each iteration after popping an index
from the heap, before examining the neighbours.</p>
<p>This method can be overloaded to modify the behavior of the MCP
algorithm. An example might be to stop the algorithm when a
certain cumulative cost is reached, or when the front is a
certain distance away from the seed point.</p>
<p>This method should return 1 if the algorithm should not check
the current point&#8217;s neighbours and 2 if the algorithm is now
done.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.MCP.traceback">
<code class="descname">traceback</code><span class="sig-paren">(</span><em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#skimage.graph.MCP.traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace a minimum cost path through the pre-calculated traceback array.</p>
<p>This convenience function reconstructs the the minimum cost path to a
given end position from one of the starting indices provided to
find_costs(), which must have been called previously. This function
can be called as many times as desired after find_costs() has been
run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>end</strong> : iterable</p>
<blockquote>
<div><p>An n-d index into the <cite>costs</cite> array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>traceback</strong> : list of n-d tuples</p>
<blockquote class="last">
<div><p>A list of indices into the <cite>costs</cite> array, starting with one of
the start positions passed to find_costs(), and ending with the
given <cite>end</cite> index. These indices specify the minimum-cost path
from any given start index to the <cite>end</cite> index. (The total cost
of that path can be read out from the <cite>cumulative_costs</cite> array
returned by find_costs().)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mcp-connect">
<h2><a class="reference internal" href="#skimage.graph.MCP_Connect" title="skimage.graph.MCP_Connect"><code class="xref py py-class docutils literal"><span class="pre">MCP_Connect</span></code></a><a class="headerlink" href="#mcp-connect" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.graph.MCP_Connect">
<em class="property">class </em><code class="descclassname">skimage.graph.</code><code class="descname">MCP_Connect</code><a class="headerlink" href="#skimage.graph.MCP_Connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">skimage.graph._mcp.MCP</span></code></p>
<p>Connect source points using the distance-weighted minimum cost function.</p>
<p>A front is grown from each seed point simultaneously, while the
origin of the front is tracked as well. When two fronts meet,
create_connection() is called. This method must be overloaded to
deal with the found edges in a way that is appropriate for the
application.</p>
<dl class="method">
<dt id="skimage.graph.MCP_Connect.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skimage.graph.MCP_Connect.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.MCP_Connect.create_connection">
<code class="descname">create_connection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#skimage.graph.MCP_Connect.create_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>create_connection id1, id2, pos1, pos2, cost1, cost2)</p>
<p>Overload this method to keep track of the connections that are
found during MCP processing. Note that a connection with the
same ids can be found multiple times (but with different
positions and costs).</p>
<p>At the time that this method is called, both points are &#8220;frozen&#8221;
and will not be visited again by the MCP algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>id1</strong> : int</p>
<blockquote>
<div><p>The seed point id where the first neighbor originated from.</p>
</div></blockquote>
<p><strong>id2</strong> : int</p>
<blockquote>
<div><p>The seed point id where the second neighbor originated from.</p>
</div></blockquote>
<p><strong>pos1</strong> : tuple</p>
<blockquote>
<div><p>The index of of the first neighbour in the connection.</p>
</div></blockquote>
<p><strong>pos2</strong> : tuple</p>
<blockquote>
<div><p>The index of of the second neighbour in the connection.</p>
</div></blockquote>
<p><strong>cost1</strong> : float</p>
<blockquote>
<div><p>The cumulative cost at <cite>pos1</cite>.</p>
</div></blockquote>
<p><strong>cost2</strong> : float</p>
<blockquote class="last">
<div><p>The cumulative costs at <cite>pos2</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mcp-flexible">
<h2><a class="reference internal" href="#skimage.graph.MCP_Flexible" title="skimage.graph.MCP_Flexible"><code class="xref py py-class docutils literal"><span class="pre">MCP_Flexible</span></code></a><a class="headerlink" href="#mcp-flexible" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.graph.MCP_Flexible">
<em class="property">class </em><code class="descclassname">skimage.graph.</code><code class="descname">MCP_Flexible</code><span class="sig-paren">(</span><em>costs</em>, <em>offsets=None</em>, <em>fully_connected=True</em><span class="sig-paren">)</span><a class="headerlink" href="#skimage.graph.MCP_Flexible" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">skimage.graph._mcp.MCP</span></code></p>
<p>Find minimum cost paths through an N-d costs array.</p>
<p>See the documentation for MCP for full details. This class differs from
MCP in that several methods can be overloaded (from pure Python) to
modify the behavior of the algorithm and/or create custom algorithms
based on MCP. Note that goal_reached can also be overloaded in the
MCP class.</p>
<dl class="method">
<dt id="skimage.graph.MCP_Flexible.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>costs</em>, <em>offsets=None</em>, <em>fully_connected=True</em>, <em>sampling=None</em><span class="sig-paren">)</span><a class="headerlink" href="#skimage.graph.MCP_Flexible.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>See class documentation.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.MCP_Flexible.examine_neighbor">
<code class="descname">examine_neighbor</code><span class="sig-paren">(</span><em>index</em>, <em>new_index</em>, <em>offset_length</em><span class="sig-paren">)</span><a class="headerlink" href="#skimage.graph.MCP_Flexible.examine_neighbor" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called once for every pair of neighboring nodes,
as soon as both nodes are frozen.</p>
<p>This method can be overloaded to obtain information about
neightboring nodes, and/or to modify the behavior of the MCP
algorithm. One example is the MCP_Connect class, which checks
for meeting fronts using this hook.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.MCP_Flexible.travel_cost">
<code class="descname">travel_cost</code><span class="sig-paren">(</span><em>old_cost</em>, <em>new_cost</em>, <em>offset_length</em><span class="sig-paren">)</span><a class="headerlink" href="#skimage.graph.MCP_Flexible.travel_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>This method calculates the travel cost for going from the
current node to the next. The default implementation returns
new_cost. Overload this method to adapt the behaviour of the
algorithm.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.MCP_Flexible.update_node">
<code class="descname">update_node</code><span class="sig-paren">(</span><em>index</em>, <em>new_index</em>, <em>offset_length</em><span class="sig-paren">)</span><a class="headerlink" href="#skimage.graph.MCP_Flexible.update_node" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a node is updated, right after
new_index is pushed onto the heap and the traceback map is
updated.</p>
<p>This method can be overloaded to keep track of other arrays
that are used by a specific implementation of the algorithm.
For instance the MCP_Connect class uses it to update an id map.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mcp-geometric">
<h2><a class="reference internal" href="#skimage.graph.MCP_Geometric" title="skimage.graph.MCP_Geometric"><code class="xref py py-class docutils literal"><span class="pre">MCP_Geometric</span></code></a><a class="headerlink" href="#mcp-geometric" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.graph.MCP_Geometric">
<em class="property">class </em><code class="descclassname">skimage.graph.</code><code class="descname">MCP_Geometric</code><span class="sig-paren">(</span><em>costs</em>, <em>offsets=None</em>, <em>fully_connected=True</em><span class="sig-paren">)</span><a class="headerlink" href="#skimage.graph.MCP_Geometric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">skimage.graph._mcp.MCP</span></code></p>
<p>Find distance-weighted minimum cost paths through an n-d costs array.</p>
<p>See the documentation for MCP for full details. This class differs from
MCP in that the cost of a path is not simply the sum of the costs along
that path.</p>
<p>This class instead assumes that the costs array contains at each position
the &#8220;cost&#8221; of a unit distance of travel through that position. For
example, a move (in 2-d) from (1, 1) to (1, 2) is assumed to originate in
the center of the pixel (1, 1) and terminate in the center of (1, 2). The
entire move is of distance 1, half through (1, 1) and half through (1, 2);
thus the cost of that move is <cite>(1/2)*costs[1,1] + (1/2)*costs[1,2]</cite>.</p>
<p>On the other hand, a move from (1, 1) to (2, 2) is along the diagonal and
is sqrt(2) in length. Half of this move is within the pixel (1, 1) and the
other half in (2, 2), so the cost of this move is calculated as
<cite>(sqrt(2)/2)*costs[1,1] + (sqrt(2)/2)*costs[2,2]</cite>.</p>
<p>These calculations don&#8217;t make a lot of sense with offsets of magnitude
greater than 1. Use the <cite>sampling</cite> argument in order to deal with
anisotropic data.</p>
<dl class="method">
<dt id="skimage.graph.MCP_Geometric.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>costs</em>, <em>offsets=None</em>, <em>fully_connected=True</em>, <em>sampling=None</em><span class="sig-paren">)</span><a class="headerlink" href="#skimage.graph.MCP_Geometric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>See class documentation.</p>
</dd></dl>

</dd></dl>

</div>
</div>


        </div>
        <div class="span3"><h4 class="sidebar-box-heading">Navigation</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <li><a href="../index.html">Documentation Home</a></li>
    </ul>
</div>
    <h4 class="sidebar-box-heading">Previous topic</h4>
    <div class="well sidebar-box">
        <ul class="nav nav-list">
            <li><a href="skimage.future.graph.html" title="previous chapter">Module: <code class="docutils literal"><span class="pre">future.graph</span></code></a></li>
        </ul>
    </div>
    <h4 class="sidebar-box-heading">Next topic</h4>
    <div class="well sidebar-box">
        <ul class="nav nav-list">
            <li><a href="skimage.io.html" title="next chapter">Module: <code class="docutils literal"><span class="pre">io</span></code></a></li>
        </ul>
    </div>
        <h4 class="sidebar-box-heading">Contents</h4>
        <div class="well sidebar-box toc">
            <ul class="nav nav-list">
<li><a class="reference internal" href="#">Module: <code class="docutils literal"><span class="pre">graph</span></code></a><ul class="nav nav-list">
<li><a class="reference internal" href="#route-through-array">route_through_array</a></li>
<li><a class="reference internal" href="#shortest-path">shortest_path</a></li>
<li><a class="reference internal" href="#mcp"><code class="docutils literal"><span class="pre">MCP</span></code></a></li>
<li><a class="reference internal" href="#mcp-connect"><code class="docutils literal"><span class="pre">MCP_Connect</span></code></a></li>
<li><a class="reference internal" href="#mcp-flexible"><code class="docutils literal"><span class="pre">MCP_Flexible</span></code></a></li>
<li><a class="reference internal" href="#mcp-geometric"><code class="docutils literal"><span class="pre">MCP_Geometric</span></code></a></li>
</ul>
</li>
</ul>

        </div>

<h4 class="sidebar-box-heading">Versions</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <script src="../../dev/_static/docversions.js"></script>
        <script type="text/javascript">
            insert_version_links();
        </script>
    </ul>
</div>
        </div>
    </div>
    <div class="well footer">
        <small>
            &copy; Copyright the scikit-image development team.
            Created using <a href="http://getbootstrap.com/">Bootstrap</a> and <a href="http://sphinx-doc.org/">Sphinx</a>.
        </small>
    </div>
</body>
</html>


<!-- Piwik -->
<script type="text/javascript">
  var _paq = _paq || [];
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//piwik.sciunto.org/piwik/";
    _paq.push(['setTrackerUrl', u+'piwik.php']);
    _paq.push(['setSiteId', 2]);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<noscript><p><img src="//piwik.sciunto.org/piwik/piwik.php?idsite=2" style="border:0;" alt="" /></p></noscript>
<!-- End Piwik Code -->