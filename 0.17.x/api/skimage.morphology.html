
<!DOCTYPE html>
<html lang="en">
<head>
        <title>Module: morphology &mdash; skimage v0.17.2 docs</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../_static/css/custom.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
        <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
        <link rel="stylesheet" href="../_static/gallery-binder.css" type="text/css" />
        <link rel="stylesheet" href="../_static/gallery-dataframe.css" type="text/css" />
    
    <script src="https://code.jquery.com/jquery-latest.js"></script>
    <script src="../_static/js/bootstrap.min.js"></script>
    <script src="../_static/js/togglebutton.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.17.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <link rel="index" title="Index" href="../genindex.html" />
        <link rel="search" title="Search" href="../search.html" />
        <link rel="top" title="skimage v0.17.2 docs" href="../index.html" />
        <link rel="up" title="API Reference for skimage 0.17.2" href="api.html" />
        <link rel="next" title="Module: registration" href="skimage.registration.html" />
        <link rel="prev" title="Module: metrics" href="skimage.metrics.html" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="shortcut icon" href="../_static/favicon.ico">
</head>
<body class="container">
    <a href="https://scikit-image.org" class="logo"><img src="../_static/img/logo.png" alt=""></a>
    <div class="clearfix"></div>
    <div class="navbar">
        <div class="navbar-inner">
            <ul class="nav">
                <li><a href="/docs/stable/install.html">Download</a></li>
<li><a href="../auto_examples/index.html">Gallery</a></li>
<li><a href="../index.html">Documentation</a></li>
<li><a href="/community_guidelines.html">Community Guidelines</a></li>

<li><a href="https://github.com/scikit-image/scikit-image">
    <img src="../_static/GitHub-Mark-32px.png"
        style="height: 15px; width: 15px;
               display: inline; float: none;
               padding-bottom: 3px;">
    Source</a>
</li>
            </ul>
        </div>
    </div>
    <div class="row">
        <div class="span3"><div style="padding-bottom: 3em">
  <form class="navbar-form pull-right" action="../search.html" method="get">
    <input type="text" class="search span3" name="q" placeholder="Search documentation ...">
    <input type="hidden" name="check_keywords" value="yes" >
    <input type="hidden" name="area" value="default" >
  </form>
</div><!-- 
        <h4 class="sidebar-box-heading">Contents</h4>
        <div class="well sidebar-box toc">
            <ul class="nav nav-list">
<li><a class="reference internal" href="#">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">morphology</span></code></a><ul class="nav nav-list">
<li><a class="reference internal" href="#area-closing">area_closing</a></li>
<li><a class="reference internal" href="#area-opening">area_opening</a></li>
<li><a class="reference internal" href="#ball">ball</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-ball">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.ball</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#binary-closing">binary_closing</a></li>
<li><a class="reference internal" href="#binary-dilation">binary_dilation</a></li>
<li><a class="reference internal" href="#binary-erosion">binary_erosion</a></li>
<li><a class="reference internal" href="#binary-opening">binary_opening</a></li>
<li><a class="reference internal" href="#black-tophat">black_tophat</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-black-tophat">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.black_tophat</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#closing">closing</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-closing">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.closing</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#convex-hull-image">convex_hull_image</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-convex-hull-image">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.convex_hull_image</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#convex-hull-object">convex_hull_object</a></li>
<li><a class="reference internal" href="#cube">cube</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-cube">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.cube</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#diameter-closing">diameter_closing</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-diameter-closing">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.diameter_closing</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#diameter-opening">diameter_opening</a></li>
<li><a class="reference internal" href="#diamond">diamond</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-diamond">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.diamond</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#dilation">dilation</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-dilation">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.dilation</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#disk">disk</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-disk">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.disk</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#erosion">erosion</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-erosion">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.erosion</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#flood">flood</a></li>
<li><a class="reference internal" href="#flood-fill">flood_fill</a></li>
<li><a class="reference internal" href="#h-maxima">h_maxima</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-h-maxima">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.h_maxima</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#h-minima">h_minima</a></li>
<li><a class="reference internal" href="#label">label</a></li>
<li><a class="reference internal" href="#local-maxima">local_maxima</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-local-maxima">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.local_maxima</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#local-minima">local_minima</a></li>
<li><a class="reference internal" href="#max-tree">max_tree</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-max-tree">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.max_tree</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#max-tree-local-maxima">max_tree_local_maxima</a></li>
<li><a class="reference internal" href="#medial-axis">medial_axis</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-medial-axis">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.medial_axis</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#octagon">octagon</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-octagon">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.octagon</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#octahedron">octahedron</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-octahedron">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.octahedron</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#opening">opening</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-opening">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.opening</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#reconstruction">reconstruction</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-reconstruction">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.reconstruction</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#rectangle">rectangle</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-rectangle">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.rectangle</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#remove-small-holes">remove_small_holes</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-remove-small-holes">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_holes</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#remove-small-objects">remove_small_objects</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-remove-small-objects">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_objects</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#skeletonize">skeletonize</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-skeletonize">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.skeletonize</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#skeletonize-3d">skeletonize_3d</a></li>
<li><a class="reference internal" href="#square">square</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-square">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.square</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#star">star</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-star">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.star</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#thin">thin</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-thin">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.thin</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#watershed">watershed</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-watershed">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.watershed</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#white-tophat">white_tophat</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-morphology-white-tophat">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.white_tophat</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>


 --><div class="well">
    <strong>Docs for 0.17.2<br></strong>

    <a id="other">All versions</a>

    <ul id="versionList" style="display: none;">
        <script src="../../dev/_static/docversions.js"></script>
        <script type="text/javascript">
            insert_version_links();
        </script>
    </ul>

 </div>

<script type="text/javascript">
	$("#other").click(function() {
		$("#versionList").toggle();
	});
</script>
        </div>
        <div class="span9" class="body" role="main">
            
  <div class="section" id="module-skimage.morphology">
<span id="module-morphology"></span><h1>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">morphology</span></code><a class="headerlink" href="#module-skimage.morphology" title="Permalink to this headline">¶</a></h1>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.area_closing" title="skimage.morphology.area_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_closing</span></code></a>(image[, …])</p></td>
<td><p>Perform an area closing of the image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.area_opening" title="skimage.morphology.area_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_opening</span></code></a>(image[, …])</p></td>
<td><p>Perform an area opening of the image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.ball" title="skimage.morphology.ball"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.ball</span></code></a>(radius[, dtype])</p></td>
<td><p>Generates a ball-shaped structuring element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.binary_closing" title="skimage.morphology.binary_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.binary_closing</span></code></a>(image[, …])</p></td>
<td><p>Return fast binary morphological closing of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.binary_dilation" title="skimage.morphology.binary_dilation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.binary_dilation</span></code></a>(image[, …])</p></td>
<td><p>Return fast binary morphological dilation of an image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.binary_erosion" title="skimage.morphology.binary_erosion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.binary_erosion</span></code></a>(image[, …])</p></td>
<td><p>Return fast binary morphological erosion of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.binary_opening" title="skimage.morphology.binary_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.binary_opening</span></code></a>(image[, …])</p></td>
<td><p>Return fast binary morphological opening of an image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.black_tophat" title="skimage.morphology.black_tophat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.black_tophat</span></code></a>(image[, …])</p></td>
<td><p>Return black top hat of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.closing" title="skimage.morphology.closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.closing</span></code></a>(image[, selem, out])</p></td>
<td><p>Return greyscale morphological closing of an image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.convex_hull_image" title="skimage.morphology.convex_hull_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.convex_hull_image</span></code></a>(image)</p></td>
<td><p>Compute the convex hull image of a binary image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.convex_hull_object" title="skimage.morphology.convex_hull_object"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.convex_hull_object</span></code></a>(image)</p></td>
<td><p>Compute the convex hull image of individual objects in a binary image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.cube" title="skimage.morphology.cube"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.cube</span></code></a>(width[, dtype])</p></td>
<td><p>Generates a cube-shaped structuring element.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.diameter_closing" title="skimage.morphology.diameter_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_closing</span></code></a>(image[, …])</p></td>
<td><p>Perform a diameter closing of the image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.diameter_opening" title="skimage.morphology.diameter_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_opening</span></code></a>(image[, …])</p></td>
<td><p>Perform a diameter opening of the image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.diamond" title="skimage.morphology.diamond"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diamond</span></code></a>(radius[, dtype])</p></td>
<td><p>Generates a flat, diamond-shaped structuring element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.dilation" title="skimage.morphology.dilation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.dilation</span></code></a>(image[, selem, …])</p></td>
<td><p>Return greyscale morphological dilation of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.disk" title="skimage.morphology.disk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.disk</span></code></a>(radius[, dtype])</p></td>
<td><p>Generates a flat, disk-shaped structuring element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.erosion" title="skimage.morphology.erosion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.erosion</span></code></a>(image[, selem, …])</p></td>
<td><p>Return greyscale morphological erosion of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.flood" title="skimage.morphology.flood"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.flood</span></code></a>(image, seed_point, \*)</p></td>
<td><p>Mask corresponding to a flood fill.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.flood_fill" title="skimage.morphology.flood_fill"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.flood_fill</span></code></a>(image, …[, …])</p></td>
<td><p>Perform flood filling on an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.h_maxima" title="skimage.morphology.h_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.h_maxima</span></code></a>(image, h[, selem])</p></td>
<td><p>Determine all maxima of the image with height &gt;= h.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.h_minima" title="skimage.morphology.h_minima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.h_minima</span></code></a>(image, h[, selem])</p></td>
<td><p>Determine all minima of the image with depth &gt;= h.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.label" title="skimage.morphology.label"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.label</span></code></a>(input[, neighbors, …])</p></td>
<td><p>Label connected regions of an integer array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.local_maxima" title="skimage.morphology.local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.local_maxima</span></code></a>(image[, …])</p></td>
<td><p>Find local maxima of n-dimensional array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.local_minima" title="skimage.morphology.local_minima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.local_minima</span></code></a>(image[, …])</p></td>
<td><p>Find local minima of n-dimensional array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.max_tree</span></code></a>(image[, …])</p></td>
<td><p>Build the max tree from an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.max_tree_local_maxima" title="skimage.morphology.max_tree_local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.max_tree_local_maxima</span></code></a>(image)</p></td>
<td><p>Determine all local maxima of the image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.medial_axis</span></code></a>(image[, …])</p></td>
<td><p>Compute the medial axis transform of a binary image</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.octagon" title="skimage.morphology.octagon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.octagon</span></code></a>(m, n[, dtype])</p></td>
<td><p>Generates an octagon shaped structuring element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.octahedron" title="skimage.morphology.octahedron"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.octahedron</span></code></a>(radius[, dtype])</p></td>
<td><p>Generates a octahedron-shaped structuring element.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.opening" title="skimage.morphology.opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.opening</span></code></a>(image[, selem, out])</p></td>
<td><p>Return greyscale morphological opening of an image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.reconstruction" title="skimage.morphology.reconstruction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.reconstruction</span></code></a>(seed, mask)</p></td>
<td><p>Perform a morphological reconstruction of an image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.rectangle" title="skimage.morphology.rectangle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.rectangle</span></code></a>(width, height)</p></td>
<td><p>Generates a flat, rectangular-shaped structuring element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.remove_small_holes" title="skimage.morphology.remove_small_holes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_holes</span></code></a>(ar[, …])</p></td>
<td><p>Remove contiguous holes smaller than the specified size.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.remove_small_objects" title="skimage.morphology.remove_small_objects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_objects</span></code></a>(ar)</p></td>
<td><p>Remove objects smaller than the specified size.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.skeletonize</span></code></a>(image, \*[, …])</p></td>
<td><p>Compute the skeleton of a binary image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.skeletonize_3d" title="skimage.morphology.skeletonize_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.skeletonize_3d</span></code></a>(image)</p></td>
<td><p>Compute the skeleton of a binary image.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.square" title="skimage.morphology.square"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.square</span></code></a>(width[, dtype])</p></td>
<td><p>Generates a flat, square-shaped structuring element.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.star" title="skimage.morphology.star"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.star</span></code></a>(a[, dtype])</p></td>
<td><p>Generates a star shaped structuring element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.thin" title="skimage.morphology.thin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.thin</span></code></a>(image[, max_iter])</p></td>
<td><p>Perform morphological thinning of a binary image.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#skimage.morphology.watershed" title="skimage.morphology.watershed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.watershed</span></code></a>(image[, …])</p></td>
<td><p><strong>Deprecated function</strong>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#skimage.morphology.white_tophat" title="skimage.morphology.white_tophat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.white_tophat</span></code></a>(image[, …])</p></td>
<td><p>Return white top hat of an image.</p></td>
</tr>
</tbody>
</table>
<div class="section" id="area-closing">
<h2>area_closing<a class="headerlink" href="#area-closing" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.area_closing">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">area_closing</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">area_threshold=64</em>, <em class="sig-param">connectivity=1</em>, <em class="sig-param">parent=None</em>, <em class="sig-param">tree_traverser=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/max_tree.py#L349"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.area_closing" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an area closing of the image.</p>
<p>Area closing removes all dark structures of an image with
a surface smaller than area_threshold.
The output image is larger than or equal to the input image
for every pixel and all local minima have at least a surface of
area_threshold pixels.</p>
<p>Area closings are similar to morphological closings, but
they do not use a fixed structuring element, but rather a deformable
one, with surface = area_threshold.</p>
<p>In the binary case, area closings are equivalent to
remove_small_holes; this operator is thus extended to gray-level images.</p>
<p>Technically, this operator is based on the max-tree representation of
the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the area_closing is to be calculated.
This image can be of any type.</p>
</dd>
<dt><strong>area_threshold</strong><span class="classifier">unsigned int</span></dt><dd><p>The size parameter (number of pixels). The default value is arbitrarily
chosen to be 64.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">unsigned int, optional</span></dt><dd><p>The neighborhood connectivity. The integer represents the maximum
number of orthogonal steps to reach a neighbor. In 2D, it is 1 for
a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p>
</dd>
<dt><strong>parent</strong><span class="classifier">ndarray, int64, optional</span></dt><dd><p>Parent image representing the max tree of the inverted image. The
value of each pixel is the index of its parent in the ravelled array.
See Note for further details.</p>
</dd>
<dt><strong>tree_traverser</strong><span class="classifier">1D array, int64, optional</span></dt><dd><p>The ordered pixel indices (referring to the ravelled array). The pixels
are ordered such that every pixel is preceded by its parent (except for
the root which has no parent).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>Output image of the same shape and type as input image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.area_opening" title="skimage.morphology.area_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_opening</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.diameter_opening" title="skimage.morphology.diameter_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_opening</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.diameter_closing" title="skimage.morphology.diameter_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_closing</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.max_tree</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.remove_small_objects" title="skimage.morphology.remove_small_objects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_objects</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.remove_small_holes" title="skimage.morphology.remove_small_holes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_holes</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If a max-tree representation (parent and tree_traverser) are given to the
function, they must be calculated from the inverted image for this
function, i.e.:
&gt;&gt;&gt; P, S = max_tree(invert(f))
&gt;&gt;&gt; closed = diameter_closing(f, 3, parent=P, tree_traverser=S)</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rce2615f30276-1"><span class="brackets">1</span></dt>
<dd><p>Vincent L., Proc. “Grayscale area openings and closings,
their efficient implementation and applications”,
EURASIP Workshop on Mathematical Morphology and its
Applications to Signal Processing, Barcelona, Spain, pp.22-27,
May 1993.</p>
</dd>
<dt class="label" id="rce2615f30276-2"><span class="brackets">2</span></dt>
<dd><p>Soille, P., “Morphological Image Analysis: Principles and
Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.
<a class="reference external" href="https://doi.org/10.1007/978-3-662-05088-0">DOI:10.1007/978-3-662-05088-0</a></p>
</dd>
<dt class="label" id="rce2615f30276-3"><span class="brackets">3</span></dt>
<dd><p>Salembier, P., Oliveras, A., &amp; Garrido, L. (1998). Antiextensive
Connected Operators for Image and Sequence Processing.
IEEE Transactions on Image Processing, 7(4), 555-570.
<a class="reference external" href="https://doi.org/10.1109/83.663500">DOI:10.1109/83.663500</a></p>
</dd>
<dt class="label" id="rce2615f30276-4"><span class="brackets">4</span></dt>
<dd><p>Najman, L., &amp; Couprie, M. (2006). Building the component tree in
quasi-linear time. IEEE Transactions on Image Processing, 15(11),
3531-3539.
<a class="reference external" href="https://doi.org/10.1109/TIP.2006.877518">DOI:10.1109/TIP.2006.877518</a></p>
</dd>
<dt class="label" id="rce2615f30276-5"><span class="brackets">5</span></dt>
<dd><p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of
Component Tree Computation Algorithms. IEEE Transactions on Image
Processing, 23(9), 3885-3895.
<a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>We create an image (quadratic function with a minimum in the center and
4 additional local minima.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">+</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">160</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">140</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate the area closing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">closed</span> <span class="o">=</span> <span class="n">area_closing</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>All small minima are removed, and the remaining minima have at least
a size of 8.</p>
</dd></dl>

</div>
<div class="section" id="area-opening">
<h2>area_opening<a class="headerlink" href="#area-opening" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.area_opening">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">area_opening</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">area_threshold=64</em>, <em class="sig-param">connectivity=1</em>, <em class="sig-param">parent=None</em>, <em class="sig-param">tree_traverser=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/max_tree.py#L146"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.area_opening" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an area opening of the image.</p>
<p>Area opening removes all bright structures of an image with
a surface smaller than area_threshold.
The output image is thus the largest image smaller than the input
for which all local maxima have at least a surface of
area_threshold pixels.</p>
<p>Area openings are similar to morphological openings, but
they do not use a fixed structuring element, but rather a deformable
one, with surface = area_threshold. Consequently, the area_opening
with area_threshold=1 is the identity.</p>
<p>In the binary case, area openings are equivalent to
remove_small_objects; this operator is thus extended to gray-level images.</p>
<p>Technically, this operator is based on the max-tree representation of
the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the area_opening is to be calculated.
This image can be of any type.</p>
</dd>
<dt><strong>area_threshold</strong><span class="classifier">unsigned int</span></dt><dd><p>The size parameter (number of pixels). The default value is arbitrarily
chosen to be 64.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">unsigned int, optional</span></dt><dd><p>The neighborhood connectivity. The integer represents the maximum
number of orthogonal steps to reach a neighbor. In 2D, it is 1 for
a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p>
</dd>
<dt><strong>parent</strong><span class="classifier">ndarray, int64, optional</span></dt><dd><p>Parent image representing the max tree of the image. The
value of each pixel is the index of its parent in the ravelled array.</p>
</dd>
<dt><strong>tree_traverser</strong><span class="classifier">1D array, int64, optional</span></dt><dd><p>The ordered pixel indices (referring to the ravelled array). The pixels
are ordered such that every pixel is preceded by its parent (except for
the root which has no parent).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>Output image of the same shape and type as the input image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.area_closing" title="skimage.morphology.area_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_closing</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.diameter_opening" title="skimage.morphology.diameter_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_opening</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.diameter_closing" title="skimage.morphology.diameter_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_closing</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.max_tree</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.remove_small_objects" title="skimage.morphology.remove_small_objects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_objects</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.remove_small_holes" title="skimage.morphology.remove_small_holes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_holes</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rab8157de4f2f-1"><span class="brackets">1</span></dt>
<dd><p>Vincent L., Proc. “Grayscale area openings and closings,
their efficient implementation and applications”,
EURASIP Workshop on Mathematical Morphology and its
Applications to Signal Processing, Barcelona, Spain, pp.22-27,
May 1993.</p>
</dd>
<dt class="label" id="rab8157de4f2f-2"><span class="brackets">2</span></dt>
<dd><p>Soille, P., “Morphological Image Analysis: Principles and
Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.
DOI:10.1007/978-3-662-05088-0</p>
</dd>
<dt class="label" id="rab8157de4f2f-3"><span class="brackets">3</span></dt>
<dd><p>Salembier, P., Oliveras, A., &amp; Garrido, L. (1998). Antiextensive
Connected Operators for Image and Sequence Processing.
IEEE Transactions on Image Processing, 7(4), 555-570.
DOI:10.1109/83.663500</p>
</dd>
<dt class="label" id="rab8157de4f2f-4"><span class="brackets">4</span></dt>
<dd><p>Najman, L., &amp; Couprie, M. (2006). Building the component tree in
quasi-linear time. IEEE Transactions on Image Processing, 15(11),
3531-3539.
DOI:10.1109/TIP.2006.877518</p>
</dd>
<dt class="label" id="rab8157de4f2f-5"><span class="brackets">5</span></dt>
<dd><p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of
Component Tree Computation Algorithms. IEEE Transactions on Image
Processing, 23(9), 3885-3895.
DOI:10.1109/TIP.2014.2336551</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>We create an image (quadratic function with a maximum in the center and
4 additional local maxima.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate the area opening:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">open</span> <span class="o">=</span> <span class="n">area_opening</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The peaks with a surface smaller than 8 are removed.</p>
</dd></dl>

</div>
<div class="section" id="ball">
<h2>ball<a class="headerlink" href="#ball" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.ball">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">ball</code><span class="sig-paren">(</span><em class="sig-param">radius</em>, <em class="sig-param">dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/selem.py#L221"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.ball" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a ball-shaped structuring element.</p>
<p>This is the 3D equivalent of a disk.
A pixel is within the neighborhood if the Euclidean distance between
it and the origin is no greater than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the ball-shaped structuring element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-ball">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.ball</span></code><a class="headerlink" href="#examples-using-skimage-morphology-ball" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :py:mod:`skimage.morphology` to generate structuring..."><div class="figure align-default" id="id53">
<img alt="../_images/sphx_glr_plot_structuring_elements_thumb.png" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate structuring elements</span></a></span><a class="headerlink" href="#id53" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="binary-closing">
<h2>binary_closing<a class="headerlink" href="#binary-closing" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.binary_closing">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">binary_closing</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">selem=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/misc.py#L35"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.binary_closing" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fast binary morphological closing of an image.</p>
<p>This function returns the same result as greyscale closing but performs
faster for binary images.</p>
<p>The morphological closing on an image is defined as a dilation followed by
an erosion. Closing can remove small dark spots (i.e. “pepper”) and connect
small bright cracks. This tends to “close” up (dark) gaps between (bright)
features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use a cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None,
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>closing</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological closing.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="binary-dilation">
<h2>binary_dilation<a class="headerlink" href="#binary-dilation" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.binary_dilation">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">binary_dilation</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">selem=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/misc.py#L35"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.binary_dilation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fast binary morphological dilation of an image.</p>
<p>This function returns the same result as greyscale dilation but performs
faster for binary images.</p>
<p>Morphological dilation sets a pixel at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> to the maximum over all
pixels in the neighborhood centered at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code>. Dilation enlarges bright
regions and shrinks dark regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use a cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dilated</strong><span class="classifier">ndarray of bool or uint</span></dt><dd><p>The result of the morphological dilation with values in
<code class="docutils literal notranslate"><span class="pre">[False,</span> <span class="pre">True]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="binary-erosion">
<h2>binary_erosion<a class="headerlink" href="#binary-erosion" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.binary_erosion">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">binary_erosion</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">selem=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/misc.py#L35"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.binary_erosion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fast binary morphological erosion of an image.</p>
<p>This function returns the same result as greyscale erosion but performs
faster for binary images.</p>
<p>Morphological erosion sets a pixel at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> to the minimum over all
pixels in the neighborhood centered at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code>. Erosion shrinks bright
regions and enlarges dark regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use a cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eroded</strong><span class="classifier">ndarray of bool or uint</span></dt><dd><p>The result of the morphological erosion taking values in
<code class="docutils literal notranslate"><span class="pre">[False,</span> <span class="pre">True]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="binary-opening">
<h2>binary_opening<a class="headerlink" href="#binary-opening" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.binary_opening">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">binary_opening</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">selem=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/misc.py#L35"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.binary_opening" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fast binary morphological opening of an image.</p>
<p>This function returns the same result as greyscale opening but performs
faster for binary images.</p>
<p>The morphological opening on an image is defined as an erosion followed by
a dilation. Opening can remove small bright spots (i.e. “salt”) and connect
small dark cracks. This tends to “open” up (dark) gaps between (bright)
features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use a cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opening</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological opening.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="black-tophat">
<h2>black_tophat<a class="headerlink" href="#black-tophat" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.black_tophat">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">black_tophat</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">selem=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/misc.py#L35"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.black_tophat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return black top hat of an image.</p>
<p>The black top hat of an image is defined as its morphological closing minus
the original image. This operation returns the dark spots of the image that
are smaller than the structuring element. Note that dark spots in the
original image are bright spots after the black top hat.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">array, same shape and type as <em class="xref py py-obj">image</em></span></dt><dd><p>The result of the morphological black top hat.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.white_tophat" title="skimage.morphology.white_tophat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">white_tophat</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd2d72f1c8811-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Top-hat_transform">https://en.wikipedia.org/wiki/Top-hat_transform</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Change dark peak to bright peak and subtract background</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dark_on_grey</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">black_tophat</span><span class="p">(</span><span class="n">dark_on_grey</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 1, 5, 1, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-black-tophat">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.black_tophat</span></code><a class="headerlink" href="#examples-using-skimage-morphology-black-tophat" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><div class="figure align-default" id="id54">
<img alt="../_images/sphx_glr_plot_morphology_thumb.png" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></span><a class="headerlink" href="#id54" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="closing">
<h2>closing<a class="headerlink" href="#closing" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.closing">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">closing</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">selem=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/misc.py#L35"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.closing" title="Permalink to this definition">¶</a></dt>
<dd><p>Return greyscale morphological closing of an image.</p>
<p>The morphological closing on an image is defined as a dilation followed by
an erosion. Closing can remove small dark spots (i.e. “pepper”) and connect
small bright cracks. This tends to “close” up (dark) gaps between (bright)
features.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None,
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>closing</strong><span class="classifier">array, same shape and type as <em class="xref py py-obj">image</em></span></dt><dd><p>The result of the morphological closing.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Close a gap between two bright lines</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">broken_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">closing</span><span class="p">(</span><span class="n">broken_line</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-closing">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.closing</span></code><a class="headerlink" href="#examples-using-skimage-morphology-closing" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Attribute operators (or connected operators) [1]_ is a family of contour preserving filtering o..."><div class="figure align-default" id="id55">
<img alt="../_images/sphx_glr_plot_attribute_operators_thumb.png" src="../_images/sphx_glr_plot_attribute_operators_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/filters/plot_attribute_operators.html#sphx-glr-auto-examples-filters-plot-attribute-operators-py"><span class="std std-ref">Attribute operators</span></a></span><a class="headerlink" href="#id55" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to segment an image with image labelling. The following steps are applie..."><div class="figure align-default" id="id56">
<img alt="../_images/sphx_glr_plot_label_thumb.png" src="../_images/sphx_glr_plot_label_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_label.html#sphx-glr-auto-examples-segmentation-plot-label-py"><span class="std std-ref">Label image regions</span></a></span><a class="headerlink" href="#id56" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><div class="figure align-default" id="id57">
<img alt="../_images/sphx_glr_plot_morphology_thumb.png" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></span><a class="headerlink" href="#id57" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="convex-hull-image">
<h2>convex_hull_image<a class="headerlink" href="#convex-hull-image" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.convex_hull_image">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">convex_hull_image</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">offset_coordinates=True</em>, <em class="sig-param">tolerance=1e-10</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/convex_hull.py#L21"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.convex_hull_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the convex hull image of a binary image.</p>
<p>The convex hull is the set of pixels included in the smallest convex
polygon that surround all white pixels in the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>Binary input image. This array is cast to bool before processing.</p>
</dd>
<dt><strong>offset_coordinates</strong><span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, a pixel at coordinate, e.g., (4, 7) will be represented
by coordinates (3.5, 7), (4.5, 7), (4, 6.5), and (4, 7.5). This adds
some “extent” to a pixel when computing the hull.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance when determining whether a point is inside the hull. Due
to numerical floating point errors, a tolerance of 0 can result in
some points erroneously being classified as being outside the hull.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>hull</strong><span class="classifier">(M, N) array of bool</span></dt><dd><p>Binary image with pixels in convex hull set to True.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rf22b92a8225f-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://blogs.mathworks.com/steve/2011/10/04/binary-image-convex-hull-algorithm-notes/">https://blogs.mathworks.com/steve/2011/10/04/binary-image-convex-hull-algorithm-notes/</a></p>
</dd>
</dl>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-convex-hull-image">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.convex_hull_image</span></code><a class="headerlink" href="#examples-using-skimage-morphology-convex-hull-image" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="The convex hull of a binary image is the set of pixels included in the smallest convex polygon ..."><div class="figure align-default" id="id58">
<img alt="../_images/sphx_glr_plot_convex_hull_thumb.png" src="../_images/sphx_glr_plot_convex_hull_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/edges/plot_convex_hull.html#sphx-glr-auto-examples-edges-plot-convex-hull-py"><span class="std std-ref">Convex Hull</span></a></span><a class="headerlink" href="#id58" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><div class="figure align-default" id="id59">
<img alt="../_images/sphx_glr_plot_morphology_thumb.png" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></span><a class="headerlink" href="#id59" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="convex-hull-object">
<h2>convex_hull_object<a class="headerlink" href="#convex-hull-object" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.convex_hull_object">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">convex_hull_object</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">neighbors=None</em>, <em class="sig-param">*</em>, <em class="sig-param">connectivity=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/convex_hull.py#L96"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.convex_hull_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the convex hull image of individual objects in a binary image.</p>
<p>The convex hull is the set of pixels included in the smallest convex
polygon that surround all white pixels in the input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>neighbors</strong><span class="classifier">{4, 8}, int, optional</span></dt><dd><p>Whether to use 4 or 8 adjacent pixels as neighbors.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, set to 8. <strong>Deprecated, use</strong> <code class="docutils literal notranslate"><span class="pre">connectivity</span></code> <strong>instead.</strong></p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">{1, 2}, int, optional</span></dt><dd><p>Determines the neighbors of each pixel. Adjacent elements
within a squared distance of <code class="docutils literal notranslate"><span class="pre">connectivity</span></code> from pixel center
are considered neighbors. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, set to 2:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">-</span><span class="n">connectivity</span>      <span class="mi">2</span><span class="o">-</span><span class="n">connectivity</span>
      <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>
       <span class="o">|</span>               \  <span class="o">|</span>  <span class="o">/</span>
 <span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>      <span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>
       <span class="o">|</span>               <span class="o">/</span>  <span class="o">|</span>  \
      <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>hull</strong><span class="classifier">ndarray of bool</span></dt><dd><p>Binary image with pixels inside convex hull set to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function uses <code class="docutils literal notranslate"><span class="pre">skimage.morphology.label</span></code> to define unique objects,
finds the convex hull of each using <code class="docutils literal notranslate"><span class="pre">convex_hull_image</span></code>, and combines
these regions with logical OR. Be aware the convex hulls of unconnected
objects may overlap in the result. If this is suspected, consider using
convex_hull_image separately on each object or adjust <code class="docutils literal notranslate"><span class="pre">connectivity</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="cube">
<h2>cube<a class="headerlink" href="#cube" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.cube">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">cube</code><span class="sig-paren">(</span><em class="sig-param">width</em>, <em class="sig-param">dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/selem.py#L160"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a cube-shaped structuring element.</p>
<p>This is the 3D equivalent of a square.
Every pixel along the perimeter has a chessboard distance
no greater than radius (radius=floor(width/2)) pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>The width, height and depth of the cube.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>A structuring element consisting only of ones, i.e. every
pixel belongs to the neighborhood.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-cube">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.cube</span></code><a class="headerlink" href="#examples-using-skimage-morphology-cube" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :py:mod:`skimage.morphology` to generate structuring..."><div class="figure align-default" id="id60">
<img alt="../_images/sphx_glr_plot_structuring_elements_thumb.png" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate structuring elements</span></a></span><a class="headerlink" href="#id60" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="diameter-closing">
<h2>diameter_closing<a class="headerlink" href="#diameter-closing" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.diameter_closing">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">diameter_closing</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">diameter_threshold=8</em>, <em class="sig-param">connectivity=1</em>, <em class="sig-param">parent=None</em>, <em class="sig-param">tree_traverser=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/max_tree.py#L475"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.diameter_closing" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a diameter closing of the image.</p>
<p>Diameter closing removes all dark structures of an image with
maximal extension smaller than diameter_threshold. The maximal
extension is defined as the maximal extension of the bounding box.
The operator is also called Bounding Box Closing. In practice,
the result is similar to a morphological closing, but long and thin
structures are not removed.</p>
<p>Technically, this operator is based on the max-tree representation of
the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the diameter_closing is to be calculated.
This image can be of any type.</p>
</dd>
<dt><strong>diameter_threshold</strong><span class="classifier">unsigned int</span></dt><dd><p>The maximal extension parameter (number of pixels). The default value
is 8.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">unsigned int, optional</span></dt><dd><p>The neighborhood connectivity. The integer represents the maximum
number of orthogonal steps to reach a neighbor. In 2D, it is 1 for
a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p>
</dd>
<dt><strong>parent</strong><span class="classifier">ndarray, int64, optional</span></dt><dd><p>Precomputed parent image representing the max tree of the inverted
image. This function is fast, if precomputed parent and tree_traverser
are provided. See Note for further details.</p>
</dd>
<dt><strong>tree_traverser</strong><span class="classifier">1D array, int64, optional</span></dt><dd><p>Precomputed traverser, where the pixels are ordered such that every
pixel is preceded by its parent (except for the root which has no
parent). This function is fast, if precomputed parent and
tree_traverser are provided. See Note for further details.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>Output image of the same shape and type as input image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.area_opening" title="skimage.morphology.area_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_opening</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.area_closing" title="skimage.morphology.area_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_closing</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.diameter_opening" title="skimage.morphology.diameter_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_opening</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.max_tree</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If a max-tree representation (parent and tree_traverser) are given to the
function, they must be calculated from the inverted image for this
function, i.e.:
&gt;&gt;&gt; P, S = max_tree(invert(f))
&gt;&gt;&gt; closed = diameter_closing(f, 3, parent=P, tree_traverser=S)</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0f793839edcd-1"><span class="brackets">1</span></dt>
<dd><p>Walter, T., &amp; Klein, J.-C. (2002). Automatic Detection of
Microaneurysms in Color Fundus Images of the Human Retina by Means
of the Bounding Box Closing. In A. Colosimo, P. Sirabella,
A. Giuliani (Eds.), Medical Data Analysis. Lecture Notes in Computer
Science, vol 2526, pp. 210-220. Springer Berlin Heidelberg.
<a class="reference external" href="https://doi.org/10.1007/3-540-36104-9_23">DOI:10.1007/3-540-36104-9_23</a></p>
</dd>
<dt class="label" id="r0f793839edcd-2"><span class="brackets">2</span></dt>
<dd><p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of
Component Tree Computation Algorithms. IEEE Transactions on Image
Processing, 23(9), 3885-3895.
<a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>We create an image (quadratic function with a minimum in the center and
4 additional local minima.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">+</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">160</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">140</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate the diameter closing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">closed</span> <span class="o">=</span> <span class="n">diameter_closing</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>All small minima with a maximal extension of 2 or less are removed.
The remaining minima have all a maximal extension of at least 3.</p>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-diameter-closing">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.diameter_closing</span></code><a class="headerlink" href="#examples-using-skimage-morphology-diameter-closing" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Attribute operators (or connected operators) [1]_ is a family of contour preserving filtering o..."><div class="figure align-default" id="id61">
<img alt="../_images/sphx_glr_plot_attribute_operators_thumb.png" src="../_images/sphx_glr_plot_attribute_operators_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/filters/plot_attribute_operators.html#sphx-glr-auto-examples-filters-plot-attribute-operators-py"><span class="std std-ref">Attribute operators</span></a></span><a class="headerlink" href="#id61" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="diameter-opening">
<h2>diameter_opening<a class="headerlink" href="#diameter-opening" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.diameter_opening">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">diameter_opening</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">diameter_threshold=8</em>, <em class="sig-param">connectivity=1</em>, <em class="sig-param">parent=None</em>, <em class="sig-param">tree_traverser=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/max_tree.py#L257"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.diameter_opening" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a diameter opening of the image.</p>
<p>Diameter opening removes all bright structures of an image with
maximal extension smaller than diameter_threshold. The maximal
extension is defined as the maximal extension of the bounding box.
The operator is also called Bounding Box Opening. In practice,
the result is similar to a morphological opening, but long and thin
structures are not removed.</p>
<p>Technically, this operator is based on the max-tree representation of
the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the area_opening is to be calculated.
This image can be of any type.</p>
</dd>
<dt><strong>diameter_threshold</strong><span class="classifier">unsigned int</span></dt><dd><p>The maximal extension parameter (number of pixels). The default value
is 8.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">unsigned int, optional</span></dt><dd><p>The neighborhood connectivity. The integer represents the maximum
number of orthogonal steps to reach a neighbor. In 2D, it is 1 for
a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p>
</dd>
<dt><strong>parent</strong><span class="classifier">ndarray, int64, optional</span></dt><dd><p>Parent image representing the max tree of the image. The
value of each pixel is the index of its parent in the ravelled array.</p>
</dd>
<dt><strong>tree_traverser</strong><span class="classifier">1D array, int64, optional</span></dt><dd><p>The ordered pixel indices (referring to the ravelled array). The pixels
are ordered such that every pixel is preceded by its parent (except for
the root which has no parent).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>Output image of the same shape and type as the input image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.area_opening" title="skimage.morphology.area_opening"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_opening</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.area_closing" title="skimage.morphology.area_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.area_closing</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.diameter_closing" title="skimage.morphology.diameter_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.diameter_closing</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.max_tree</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rff2b90016d8e-1"><span class="brackets">1</span></dt>
<dd><p>Walter, T., &amp; Klein, J.-C. (2002). Automatic Detection of
Microaneurysms in Color Fundus Images of the Human Retina by Means
of the Bounding Box Closing. In A. Colosimo, P. Sirabella,
A. Giuliani (Eds.), Medical Data Analysis. Lecture Notes in Computer
Science, vol 2526, pp. 210-220. Springer Berlin Heidelberg.
<a class="reference external" href="https://doi.org/10.1007/3-540-36104-9_23">DOI:10.1007/3-540-36104-9_23</a></p>
</dd>
<dt class="label" id="rff2b90016d8e-2"><span class="brackets">2</span></dt>
<dd><p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of
Component Tree Computation Algorithms. IEEE Transactions on Image
Processing, 23(9), 3885-3895.
<a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>We create an image (quadratic function with a maximum in the center and
4 additional local maxima.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">80</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">9</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate the diameter opening:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">open</span> <span class="o">=</span> <span class="n">diameter_opening</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The peaks with a maximal extension of 2 or less are removed.
The remaining peaks have all a maximal extension of at least 3.</p>
</dd></dl>

</div>
<div class="section" id="diamond">
<h2>diamond<a class="headerlink" href="#diamond" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.diamond">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">diamond</code><span class="sig-paren">(</span><em class="sig-param">radius</em>, <em class="sig-param">dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/selem.py#L60"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.diamond" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a flat, diamond-shaped structuring element.</p>
<p>A pixel is part of the neighborhood (i.e. labeled 1) if
the city block/Manhattan distance between it and the center of
the neighborhood is no greater than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the diamond-shaped structuring element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-diamond">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.diamond</span></code><a class="headerlink" href="#examples-using-skimage-morphology-diamond" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :py:mod:`skimage.morphology` to generate structuring..."><div class="figure align-default" id="id62">
<img alt="../_images/sphx_glr_plot_structuring_elements_thumb.png" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate structuring elements</span></a></span><a class="headerlink" href="#id62" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="dilation">
<h2>dilation<a class="headerlink" href="#dilation" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.dilation">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">dilation</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">selem=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">shift_x=False</em>, <em class="sig-param">shift_y=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/misc.py#L35"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.dilation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return greyscale morphological dilation of an image.</p>
<p>Morphological dilation sets a pixel at (i,j) to the maximum over all pixels
in the neighborhood centered at (i,j). Dilation enlarges bright regions
and shrinks dark regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None, is
passed, a new array will be allocated.</p>
</dd>
<dt><strong>shift_x, shift_y</strong><span class="classifier">bool, optional</span></dt><dd><p>shift structuring element about center point. This only affects
eccentric structuring elements (i.e. selem with even numbered sides).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>dilated</strong><span class="classifier">uint8 array, same shape and type as <em class="xref py py-obj">image</em></span></dt><dd><p>The result of the morphological dilation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For <em class="xref py py-obj">uint8</em> (and <em class="xref py py-obj">uint16</em> up to a certain bit-depth) data, the lower
algorithm complexity makes the <a class="reference internal" href="skimage.filters.rank.html#skimage.filters.rank.maximum" title="skimage.filters.rank.maximum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.filters.rank.maximum</span></code></a> function more
efficient for larger images and structuring elements.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Dilation enlarges bright regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bright_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dilation</span><span class="p">(</span><span class="n">bright_pixel</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 1, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-dilation">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.dilation</span></code><a class="headerlink" href="#examples-using-skimage-morphology-dilation" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><div class="figure align-default" id="id63">
<img alt="../_images/sphx_glr_plot_morphology_thumb.png" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></span><a class="headerlink" href="#id63" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Rank filters are non-linear filters using the local gray-level ordering to compute the filtered..."><div class="figure align-default" id="id64">
<img alt="../_images/sphx_glr_plot_rank_filters_thumb.png" src="../_images/sphx_glr_plot_rank_filters_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_rank_filters.html#sphx-glr-auto-examples-applications-plot-rank-filters-py"><span class="std std-ref">Rank filters</span></a></span><a class="headerlink" href="#id64" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="disk">
<h2>disk<a class="headerlink" href="#disk" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.disk">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">disk</code><span class="sig-paren">(</span><em class="sig-param">radius</em>, <em class="sig-param">dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/selem.py#L90"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.disk" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a flat, disk-shaped structuring element.</p>
<p>A pixel is within the neighborhood if the Euclidean distance between
it and the origin is no greater than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the disk-shaped structuring element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-disk">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.disk</span></code><a class="headerlink" href="#examples-using-skimage-morphology-disk" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :py:mod:`skimage.morphology` to generate structuring..."><div class="figure align-default" id="id65">
<img alt="../_images/sphx_glr_plot_structuring_elements_thumb.png" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate structuring elements</span></a></span><a class="headerlink" href="#id65" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example enhances an image with low contrast, using a method called *local histogram equali..."><div class="figure align-default" id="id66">
<img alt="../_images/sphx_glr_plot_local_equalize_thumb.png" src="../_images/sphx_glr_plot_local_equalize_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/color_exposure/plot_local_equalize.html#sphx-glr-auto-examples-color-exposure-plot-local-equalize-py"><span class="std std-ref">Local Histogram Equalization</span></a></span><a class="headerlink" href="#id66" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to remove small objects from grayscale images. The top-hat transform [1]..."><div class="figure align-default" id="id67">
<img alt="../_images/sphx_glr_plot_tophat_thumb.png" src="../_images/sphx_glr_plot_tophat_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/filters/plot_tophat.html#sphx-glr-auto-examples-filters-plot-tophat-py"><span class="std std-ref">Removing small objects in grayscale images with a top hat filter</span></a></span><a class="headerlink" href="#id67" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example compares the following mean filters of the rank filter package:"><div class="figure align-default" id="id68">
<img alt="../_images/sphx_glr_plot_rank_mean_thumb.png" src="../_images/sphx_glr_plot_rank_mean_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/filters/plot_rank_mean.html#sphx-glr-auto-examples-filters-plot-rank-mean-py"><span class="std std-ref">Mean filters</span></a></span><a class="headerlink" href="#id68" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In information theory, information entropy is the log-base-2 of the number of possible outcomes..."><div class="figure align-default" id="id69">
<img alt="../_images/sphx_glr_plot_entropy_thumb.png" src="../_images/sphx_glr_plot_entropy_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/filters/plot_entropy.html#sphx-glr-auto-examples-filters-plot-entropy-py"><span class="std std-ref">Entropy</span></a></span><a class="headerlink" href="#id69" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Histogram matching can be used for object detection in images [1]_. This example extracts a sin..."><div class="figure align-default" id="id70">
<img alt="../_images/sphx_glr_plot_windowed_histogram_thumb.png" src="../_images/sphx_glr_plot_windowed_histogram_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/features_detection/plot_windowed_histogram.html#sphx-glr-auto-examples-features-detection-plot-windowed-histogram-py"><span class="std std-ref">Sliding window histogram</span></a></span><a class="headerlink" href="#id70" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example is about comparing the segmentations obtained using the plain SLIC method [1]_ and..."><div class="figure align-default" id="id71">
<img alt="../_images/sphx_glr_plot_mask_slic_thumb.png" src="../_images/sphx_glr_plot_mask_slic_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_mask_slic.html#sphx-glr-auto-examples-segmentation-plot-mask-slic-py"><span class="std std-ref">maskSLIC Demonstration</span></a></span><a class="headerlink" href="#id71" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="The watershed is a classical algorithm used for **segmentation**, that is, for separating diffe..."><div class="figure align-default" id="id72">
<img alt="../_images/sphx_glr_plot_marked_watershed_thumb.png" src="../_images/sphx_glr_plot_marked_watershed_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_marked_watershed.html#sphx-glr-auto-examples-segmentation-plot-marked-watershed-py"><span class="std std-ref">Markers for watershed transform</span></a></span><a class="headerlink" href="#id72" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><div class="figure align-default" id="id73">
<img alt="../_images/sphx_glr_plot_morphology_thumb.png" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></span><a class="headerlink" href="#id73" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Thresholding is used to create a binary image from a grayscale image [1]_. It is the simplest w..."><div class="figure align-default" id="id74">
<img alt="../_images/sphx_glr_plot_thresholding_thumb1.png" src="../_images/sphx_glr_plot_thresholding_thumb1.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_thresholding.html#sphx-glr-auto-examples-applications-plot-thresholding-py"><span class="std std-ref">Thresholding</span></a></span><a class="headerlink" href="#id74" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Rank filters are non-linear filters using the local gray-level ordering to compute the filtered..."><div class="figure align-default" id="id75">
<img alt="../_images/sphx_glr_plot_rank_filters_thumb.png" src="../_images/sphx_glr_plot_rank_filters_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_rank_filters.html#sphx-glr-auto-examples-applications-plot-rank-filters-py"><span class="std std-ref">Rank filters</span></a></span><a class="headerlink" href="#id75" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="erosion">
<h2>erosion<a class="headerlink" href="#erosion" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.erosion">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">erosion</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">selem=None</em>, <em class="sig-param">out=None</em>, <em class="sig-param">shift_x=False</em>, <em class="sig-param">shift_y=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/misc.py#L35"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.erosion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return greyscale morphological erosion of an image.</p>
<p>Morphological erosion sets a pixel at (i,j) to the minimum over all pixels
in the neighborhood centered at (i,j). Erosion shrinks bright regions and
enlarges dark regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarrays, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
<dt><strong>shift_x, shift_y</strong><span class="classifier">bool, optional</span></dt><dd><p>shift structuring element about center point. This only affects
eccentric structuring elements (i.e. selem with even numbered sides).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>eroded</strong><span class="classifier">array, same shape as <em class="xref py py-obj">image</em></span></dt><dd><p>The result of the morphological erosion.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For <code class="docutils literal notranslate"><span class="pre">uint8</span></code> (and <code class="docutils literal notranslate"><span class="pre">uint16</span></code> up to a certain bit-depth) data, the
lower algorithm complexity makes the <a class="reference internal" href="skimage.filters.rank.html#skimage.filters.rank.minimum" title="skimage.filters.rank.minimum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.filters.rank.minimum</span></code></a>
function more efficient for larger images and structuring elements.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Erosion shrinks bright regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bright_square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">erosion</span><span class="p">(</span><span class="n">bright_square</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-erosion">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.erosion</span></code><a class="headerlink" href="#examples-using-skimage-morphology-erosion" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><div class="figure align-default" id="id76">
<img alt="../_images/sphx_glr_plot_morphology_thumb.png" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></span><a class="headerlink" href="#id76" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="flood">
<h2>flood<a class="headerlink" href="#flood" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.flood">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">flood</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">seed_point</em>, <em class="sig-param">*</em>, <em class="sig-param">selem=None</em>, <em class="sig-param">connectivity=None</em>, <em class="sig-param">tolerance=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/_flood_fill.py#L124"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.flood" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask corresponding to a flood fill.</p>
<p>Starting at a specific <em class="xref py py-obj">seed_point</em>, connected points equal or within
<em class="xref py py-obj">tolerance</em> of the seed value are found.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>An n-dimensional array.</p>
</dd>
<dt><strong>seed_point</strong><span class="classifier">tuple or int</span></dt><dd><p>The point in <em class="xref py py-obj">image</em> used as the starting point for the flood fill.  If
the image is 1D, this point may be given as an integer.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>A structuring element used to determine the neighborhood of each
evaluated pixel. It must contain only 1’s and 0’s, have the same number
of dimensions as <em class="xref py py-obj">image</em>. If not given, all adjacent pixels are
considered as part of the neighborhood (fully connected).</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>A number used to determine the neighborhood of each evaluated pixel.
Adjacent pixels whose squared distance from the center is larger or
equal to <em class="xref py py-obj">connectivity</em> are considered neighbors. Ignored if
<code class="xref py py-obj docutils literal notranslate"><span class="pre">selem</span></code> is not None.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float or int, optional</span></dt><dd><p>If None (default), adjacent values must be strictly equal to the
initial value of <em class="xref py py-obj">image</em> at <em class="xref py py-obj">seed_point</em>.  This is fastest.  If a value
is given, a comparison will be done at every point and if within
tolerance of the initial value will also be filled (inclusive).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mask</strong><span class="classifier">ndarray</span></dt><dd><p>A Boolean array with the same shape as <em class="xref py py-obj">image</em> is returned, with True
values for areas connected to and equal (or within tolerance of) the
seed point.  All other values are False.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The conceptual analogy of this operation is the ‘paint bucket’ tool in many
raster graphics programs.  This function returns just the mask
representing the fill.</p>
<p>If indices are desired rather than masks for memory reasons, the user can
simply run <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.nonzero.html#numpy.nonzero" title="(in NumPy v1.9)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.nonzero</span></code></a> on the result, save the indices, and discard
this mask.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">flood</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 1, 1, 0, 2, 2, 0],</span>
<span class="go">       [0, 1, 1, 0, 2, 2, 0],</span>
<span class="go">       [1, 0, 0, 0, 0, 0, 3]])</span>
</pre></div>
</div>
<p>Fill connected ones with 5, with full connectivity (diagonals included):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">flood</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [5, 0, 0, 0, 0, 0, 3]])</span>
</pre></div>
</div>
<p>Fill connected ones with 5, excluding diagonal points (connectivity 1):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">flood</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [1, 0, 0, 0, 0, 0, 3]])</span>
</pre></div>
</div>
<p>Fill with a tolerance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">flood</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_flooded</span>
<span class="go">array([[5, 5, 5, 5, 5, 5, 5],</span>
<span class="go">       [5, 5, 5, 5, 2, 2, 5],</span>
<span class="go">       [5, 5, 5, 5, 2, 2, 5],</span>
<span class="go">       [5, 5, 5, 5, 5, 5, 3]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="flood-fill">
<h2>flood_fill<a class="headerlink" href="#flood-fill" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.flood_fill">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">flood_fill</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">seed_point</em>, <em class="sig-param">new_value</em>, <em class="sig-param">*</em>, <em class="sig-param">selem=None</em>, <em class="sig-param">connectivity=None</em>, <em class="sig-param">tolerance=None</em>, <em class="sig-param">in_place=False</em>, <em class="sig-param">inplace=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/_flood_fill.py#L15"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.flood_fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform flood filling on an image.</p>
<p>Starting at a specific <em class="xref py py-obj">seed_point</em>, connected points equal or within
<em class="xref py py-obj">tolerance</em> of the seed value are found, then set to <em class="xref py py-obj">new_value</em>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>An n-dimensional array.</p>
</dd>
<dt><strong>seed_point</strong><span class="classifier">tuple or int</span></dt><dd><p>The point in <em class="xref py py-obj">image</em> used as the starting point for the flood fill.  If
the image is 1D, this point may be given as an integer.</p>
</dd>
<dt><strong>new_value</strong><span class="classifier"><em class="xref py py-obj">image</em> type</span></dt><dd><p>New value to set the entire fill.  This must be chosen in agreement
with the dtype of <em class="xref py py-obj">image</em>.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>A structuring element used to determine the neighborhood of each
evaluated pixel. It must contain only 1’s and 0’s, have the same number
of dimensions as <em class="xref py py-obj">image</em>. If not given, all adjacent pixels are
considered as part of the neighborhood (fully connected).</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>A number used to determine the neighborhood of each evaluated pixel.
Adjacent pixels whose squared distance from the center is less than or
equal to <em class="xref py py-obj">connectivity</em> are considered neighbors. Ignored if <code class="xref py py-obj docutils literal notranslate"><span class="pre">selem</span></code> is
not None.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float or int, optional</span></dt><dd><p>If None (default), adjacent values must be strictly equal to the
value of <em class="xref py py-obj">image</em> at <em class="xref py py-obj">seed_point</em> to be filled.  This is fastest.
If a tolerance is provided, adjacent points with values within plus or
minus tolerance from the seed point are filled (inclusive).</p>
</dd>
<dt><strong>in_place</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, flood filling is applied to <em class="xref py py-obj">image</em> in place.  If False, the
flood filled result is returned without modifying the input <em class="xref py py-obj">image</em>
(default).</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, optional</span></dt><dd><p>This parameter is deprecated and will be removed in version 0.19.0
in favor of in_place. If True, flood filling is applied to <em class="xref py py-obj">image</em>
inplace. If False, the flood filled result is returned without
modifying the input <em class="xref py py-obj">image</em> (default).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filled</strong><span class="classifier">ndarray</span></dt><dd><p>An array with the same shape as <em class="xref py py-obj">image</em> is returned, with values in
areas connected to and equal (or within tolerance of) the seed point
replaced with <em class="xref py py-obj">new_value</em>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The conceptual analogy of this operation is the ‘paint bucket’ tool in many
raster graphics programs.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">flood_fill</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 1, 1, 0, 2, 2, 0],</span>
<span class="go">       [0, 1, 1, 0, 2, 2, 0],</span>
<span class="go">       [1, 0, 0, 0, 0, 0, 3]])</span>
</pre></div>
</div>
<p>Fill connected ones with 5, with full connectivity (diagonals included):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flood_fill</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [5, 0, 0, 0, 0, 0, 3]])</span>
</pre></div>
</div>
<p>Fill connected ones with 5, excluding diagonal points (connectivity 1):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flood_fill</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">5</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [0, 5, 5, 0, 2, 2, 0],</span>
<span class="go">       [1, 0, 0, 0, 0, 0, 3]])</span>
</pre></div>
</div>
<p>Fill with a tolerance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flood_fill</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">5</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[5, 5, 5, 5, 5, 5, 5],</span>
<span class="go">       [5, 5, 5, 5, 2, 2, 5],</span>
<span class="go">       [5, 5, 5, 5, 2, 2, 5],</span>
<span class="go">       [5, 5, 5, 5, 5, 5, 3]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="h-maxima">
<h2>h_maxima<a class="headerlink" href="#h-maxima" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.h_maxima">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">h_maxima</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">h</em>, <em class="sig-param">selem=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/extrema.py#L48"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.h_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine all maxima of the image with height &gt;= h.</p>
<p>The local maxima are defined as connected sets of pixels with equal
grey level strictly greater than the grey level of all pixels in direct
neighborhood of the set.</p>
<p>A local maximum M of height h is a local maximum for which
there is at least one path joining M with a higher maximum on which the
minimal value is f(M) - h (i.e. the values along the path are not
decreasing by more than h with respect to the maximum’s value) and no
path for which the minimal value is greater.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the maxima are to be calculated.</p>
</dd>
<dt><strong>h</strong><span class="classifier">unsigned integer</span></dt><dd><p>The minimal height of all extracted maxima.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an n-D array of 1’s and 0’s.
Default is the ball of radius 1 according to the maximum norm
(i.e. a 3x3 square for 2D images, a 3x3x3 cube for 3D images, etc.)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>h_max</strong><span class="classifier">ndarray</span></dt><dd><p>The maxima of height &gt;= h. The resulting image is a binary image, where
pixels belonging to the selected maxima take value 1, the others
take value 0.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.extrema.h_minima</span></code></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.extrema.local_maxima</span></code></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.extrema.local_minima</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="reab74d5f60e7-1"><span class="brackets">1</span></dt>
<dd><p>Soille, P., “Morphological Image Analysis: Principles and
Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">extrema</span>
</pre></div>
</div>
<p>We create an image (quadratic function with a maximum in the center and
4 additional constant maxima.
The heights of the maxima are: 1, 21, 41, 61, 81</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate all maxima with a height of at least 40:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">maxima</span> <span class="o">=</span> <span class="n">extrema</span><span class="o">.</span><span class="n">h_maxima</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting image will contain 3 local maxima.</p>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-h-maxima">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.h_maxima</span></code><a class="headerlink" href="#examples-using-skimage-morphology-h-maxima" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="We detect local maxima in a galaxy image. The image is corrupted by noise, generating many loca..."><div class="figure align-default" id="id77">
<img alt="../_images/sphx_glr_plot_extrema_thumb.png" src="../_images/sphx_glr_plot_extrema_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_extrema.html#sphx-glr-auto-examples-segmentation-plot-extrema-py"><span class="std std-ref">Extrema</span></a></span><a class="headerlink" href="#id77" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="h-minima">
<h2>h_minima<a class="headerlink" href="#h-minima" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.h_minima">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">h_minima</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">h</em>, <em class="sig-param">selem=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/extrema.py#L173"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.h_minima" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine all minima of the image with depth &gt;= h.</p>
<p>The local minima are defined as connected sets of pixels with equal
grey level strictly smaller than the grey levels of all pixels in direct
neighborhood of the set.</p>
<p>A local minimum M of depth h is a local minimum for which
there is at least one path joining M with a deeper minimum on which the
maximal value is f(M) + h (i.e. the values along the path are not
increasing by more than h with respect to the minimum’s value) and no
path for which the maximal value is smaller.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the minima are to be calculated.</p>
</dd>
<dt><strong>h</strong><span class="classifier">unsigned integer</span></dt><dd><p>The minimal depth of all extracted minima.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an n-D array of 1’s and 0’s.
Default is the ball of radius 1 according to the maximum norm
(i.e. a 3x3 square for 2D images, a 3x3x3 cube for 3D images, etc.)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>h_min</strong><span class="classifier">ndarray</span></dt><dd><p>The minima of depth &gt;= h. The resulting image is a binary image, where
pixels belonging to the selected minima take value 1, the other pixels
take value 0.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.extrema.h_maxima</span></code></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.extrema.local_maxima</span></code></dt><dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.extrema.local_minima</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb2b2b247b9a8-1"><span class="brackets">1</span></dt>
<dd><p>Soille, P., “Morphological Image Analysis: Principles and
Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">extrema</span>
</pre></div>
</div>
<p>We create an image (quadratic function with a minimum in the center and
4 additional constant maxima.
The depth of the minima are: 1, 21, 41, 61, 81</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">+</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">160</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">140</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate all minima with a depth of at least 40:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minima</span> <span class="o">=</span> <span class="n">extrema</span><span class="o">.</span><span class="n">h_minima</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting image will contain 3 local minima.</p>
</dd></dl>

</div>
<div class="section" id="label">
<h2>label<a class="headerlink" href="#label" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.label">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">label</code><span class="sig-paren">(</span><em class="sig-param">input</em>, <em class="sig-param">neighbors=None</em>, <em class="sig-param">background=None</em>, <em class="sig-param">return_num=False</em>, <em class="sig-param">connectivity=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/measure/_label.py#L4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Label connected regions of an integer array.</p>
<p>Two pixels are connected when they are neighbors and have the same value.
In 2D, they can be neighbors either in a 1- or 2-connected sense.
The value refers to the maximum number of orthogonal hops to consider a
pixel/voxel a neighbor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">-</span><span class="n">connectivity</span>     <span class="mi">2</span><span class="o">-</span><span class="n">connectivity</span>     <span class="n">diagonal</span> <span class="n">connection</span> <span class="n">close</span><span class="o">-</span><span class="n">up</span>

     <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>             <span class="p">[</span> <span class="p">]</span>
      <span class="o">|</span>               \  <span class="o">|</span>  <span class="o">/</span>                 <span class="o">|</span>  <span class="o">&lt;-</span> <span class="n">hop</span> <span class="mi">2</span>
<span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>      <span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>        <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>
      <span class="o">|</span>               <span class="o">/</span>  <span class="o">|</span>  \             <span class="n">hop</span> <span class="mi">1</span>
     <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input</strong><span class="classifier">ndarray of dtype int</span></dt><dd><p>Image to label.</p>
</dd>
<dt><strong>neighbors</strong><span class="classifier">{4, 8}, int, optional</span></dt><dd><p>Whether to use 4- or 8-“connectivity”.
In 3D, 4-“connectivity” means connected pixels have to share face,
whereas with 8-“connectivity”, they have to share only edge or vertex.
<strong>Deprecated, use</strong> <code class="docutils literal notranslate"><span class="pre">connectivity</span></code> <strong>instead.</strong></p>
</dd>
<dt><strong>background</strong><span class="classifier">int, optional</span></dt><dd><p>Consider all pixels with this value as background pixels, and label
them as 0. By default, 0-valued pixels are considered as background
pixels.</p>
</dd>
<dt><strong>return_num</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to return the number of assigned labels.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of orthogonal hops to consider a pixel/voxel
as a neighbor.
Accepted values are ranging from  1 to input.ndim. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a full
connectivity of <code class="docutils literal notranslate"><span class="pre">input.ndim</span></code> is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">ndarray of dtype int</span></dt><dd><p>Labeled array, where all connected regions are assigned the
same integer value.</p>
</dd>
<dt><strong>num</strong><span class="classifier">int, optional</span></dt><dd><p>Number of labels, which equals the maximum label index and is only
returned if return_num is <em class="xref py py-obj">True</em>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">regionprops</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rfdcb8fe18c0f-1"><span class="brackets">1</span></dt>
<dd><p>Christophe Fiorio and Jens Gustedt, “Two linear time Union-Find
strategies for image processing”, Theoretical Computer Science
154 (1996), pp. 165-181.</p>
</dd>
<dt class="label" id="rfdcb8fe18c0f-2"><span class="brackets">2</span></dt>
<dd><p>Kensheng Wu, Ekow Otoo and Arie Shoshani, “Optimizing connected
component labeling algorithms”, Paper LBNL-56864, 2005,
Lawrence Berkeley National Laboratory (University of California),
<a class="reference external" href="http://repositories.cdlib.org/lbnl/LBNL-56864">http://repositories.cdlib.org/lbnl/LBNL-56864</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 1 0]</span>
<span class="go"> [0 0 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 2 0]</span>
<span class="go"> [0 0 3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 1 0]</span>
<span class="go"> [0 0 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">background</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1 2 2]</span>
<span class="go"> [2 1 2]</span>
<span class="go"> [2 2 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [1 1 2]</span>
<span class="go"> [0 0 0]]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="local-maxima">
<h2>local_maxima<a class="headerlink" href="#local-maxima" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.local_maxima">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">local_maxima</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">selem=None</em>, <em class="sig-param">connectivity=None</em>, <em class="sig-param">indices=False</em>, <em class="sig-param">allow_borders=True</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/extrema.py#L266"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.local_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local maxima of n-dimensional array.</p>
<p>The local maxima are defined as connected sets of pixels with equal gray
level (plateaus) strictly greater than the gray levels of all pixels in the
neighborhood.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>An n-dimensional array.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>A structuring element used to determine the neighborhood of each
evaluated pixel (<code class="docutils literal notranslate"><span class="pre">True</span></code> denotes a connected pixel). It must be a
boolean array and have the same number of dimensions as <em class="xref py py-obj">image</em>. If
neither <code class="xref py py-obj docutils literal notranslate"><span class="pre">selem</span></code> nor <em class="xref py py-obj">connectivity</em> are given, all adjacent pixels are
considered as part of the neighborhood.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>A number used to determine the neighborhood of each evaluated pixel.
Adjacent pixels whose squared distance from the center is less than or
equal to <em class="xref py py-obj">connectivity</em> are considered neighbors. Ignored if
<code class="xref py py-obj docutils literal notranslate"><span class="pre">selem</span></code> is not None.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the output will be a tuple of one-dimensional arrays
representing the indices of local maxima in each dimension. If False,
the output will be a boolean array with the same shape as <em class="xref py py-obj">image</em>.</p>
</dd>
<dt><strong>allow_borders</strong><span class="classifier">bool, optional</span></dt><dd><p>If true, plateaus that touch the image border are valid maxima.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>maxima</strong><span class="classifier">ndarray or tuple[ndarray]</span></dt><dd><p>If <em class="xref py py-obj">indices</em> is false, a boolean array with the same shape as <em class="xref py py-obj">image</em>
is returned with <code class="docutils literal notranslate"><span class="pre">True</span></code> indicating the position of local maxima
(<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise). If <em class="xref py py-obj">indices</em> is true, a tuple of one-dimensional
arrays containing the coordinates (indices) of all found maxima.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Warns</dt>
<dd class="field-odd"><dl class="simple">
<dt>UserWarning</dt><dd><p>If <em class="xref py py-obj">allow_borders</em> is false and any dimension of the given <em class="xref py py-obj">image</em> is
shorter than 3 samples, maxima can’t exist and a warning is shown.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.local_minima" title="skimage.morphology.local_minima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.local_minima</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.h_maxima" title="skimage.morphology.h_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.h_maxima</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.h_minima" title="skimage.morphology.h_minima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.h_minima</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function operates on the following ideas:</p>
<ol class="arabic simple">
<li><p>Make a first pass over the image’s last dimension and flag candidates
for local maxima by comparing pixels in only one direction.
If the pixels aren’t connected in the last dimension all pixels are
flagged as candidates instead.</p></li>
</ol>
<p>For each candidate:</p>
<ol class="arabic simple" start="2">
<li><p>Perform a flood-fill to find all connected pixels that have the same
gray value and are part of the plateau.</p></li>
<li><p>Consider the connected neighborhood of a plateau: if no bordering sample
has a higher gray level, mark the plateau as a definite local maximum.</p></li>
</ol>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">local_maxima</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 1, 1, 0, 2, 2, 0],</span>
<span class="go">       [0, 1, 1, 0, 2, 2, 0],</span>
<span class="go">       [1, 0, 0, 0, 0, 0, 3]])</span>
</pre></div>
</div>
<p>Find local maxima by comparing to all neighboring pixels (maximal
connectivity):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">local_maxima</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">array([[False, False, False, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False, False, False, False],</span>
<span class="go">       [ True, False, False, False, False, False,  True]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_maxima</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(array([1, 1, 2, 2, 3, 3]), array([1, 2, 1, 2, 0, 6]))</span>
</pre></div>
</div>
<p>Find local maxima without comparing to diagonal pixels (connectivity 1):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">local_maxima</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[False, False, False, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [ True, False, False, False, False, False,  True]])</span>
</pre></div>
</div>
<p>and exclude maxima that border the image edge:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">local_maxima</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_borders</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([[False, False, False, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [False, False, False, False, False, False, False]])</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-local-maxima">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.local_maxima</span></code><a class="headerlink" href="#examples-using-skimage-morphology-local-maxima" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="We detect local maxima in a galaxy image. The image is corrupted by noise, generating many loca..."><div class="figure align-default" id="id78">
<img alt="../_images/sphx_glr_plot_extrema_thumb.png" src="../_images/sphx_glr_plot_extrema_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_extrema.html#sphx-glr-auto-examples-segmentation-plot-extrema-py"><span class="std std-ref">Extrema</span></a></span><a class="headerlink" href="#id78" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="local-minima">
<h2>local_minima<a class="headerlink" href="#local-minima" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.local_minima">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">local_minima</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">selem=None</em>, <em class="sig-param">connectivity=None</em>, <em class="sig-param">indices=False</em>, <em class="sig-param">allow_borders=True</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/extrema.py#L429"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.local_minima" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local minima of n-dimensional array.</p>
<p>The local minima are defined as connected sets of pixels with equal gray
level (plateaus) strictly smaller than the gray levels of all pixels in the
neighborhood.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>An n-dimensional array.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>A structuring element used to determine the neighborhood of each
evaluated pixel (<code class="docutils literal notranslate"><span class="pre">True</span></code> denotes a connected pixel). It must be a
boolean array and have the same number of dimensions as <em class="xref py py-obj">image</em>. If
neither <code class="xref py py-obj docutils literal notranslate"><span class="pre">selem</span></code> nor <em class="xref py py-obj">connectivity</em> are given, all adjacent pixels are
considered as part of the neighborhood.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>A number used to determine the neighborhood of each evaluated pixel.
Adjacent pixels whose squared distance from the center is less than or
equal to <em class="xref py py-obj">connectivity</em> are considered neighbors. Ignored if
<code class="xref py py-obj docutils literal notranslate"><span class="pre">selem</span></code> is not None.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the output will be a tuple of one-dimensional arrays
representing the indices of local minima in each dimension. If False,
the output will be a boolean array with the same shape as <em class="xref py py-obj">image</em>.</p>
</dd>
<dt><strong>allow_borders</strong><span class="classifier">bool, optional</span></dt><dd><p>If true, plateaus that touch the image border are valid minima.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>minima</strong><span class="classifier">ndarray or tuple[ndarray]</span></dt><dd><p>If <em class="xref py py-obj">indices</em> is false, a boolean array with the same shape as <em class="xref py py-obj">image</em>
is returned with <code class="docutils literal notranslate"><span class="pre">True</span></code> indicating the position of local minima
(<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise). If <em class="xref py py-obj">indices</em> is true, a tuple of one-dimensional
arrays containing the coordinates (indices) of all found minima.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.local_maxima" title="skimage.morphology.local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.local_maxima</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.h_maxima" title="skimage.morphology.h_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.h_maxima</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.h_minima" title="skimage.morphology.h_minima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.h_minima</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function operates on the following ideas:</p>
<ol class="arabic simple">
<li><p>Make a first pass over the image’s last dimension and flag candidates
for local minima by comparing pixels in only one direction.
If the pixels aren’t connected in the last dimension all pixels are
flagged as candidates instead.</p></li>
</ol>
<p>For each candidate:</p>
<ol class="arabic simple" start="2">
<li><p>Perform a flood-fill to find all connected pixels that have the same
gray value and are part of the plateau.</p></li>
<li><p>Consider the connected neighborhood of a plateau: if no bordering sample
has a smaller gray level, mark the plateau as a definite local minimum.</p></li>
</ol>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">local_minima</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span>
<span class="go">array([[ 0,  0,  0,  0,  0,  0,  0],</span>
<span class="go">       [ 0, -1, -1,  0, -2, -2,  0],</span>
<span class="go">       [ 0, -1, -1,  0, -2, -2,  0],</span>
<span class="go">       [-1,  0,  0,  0,  0,  0, -3]])</span>
</pre></div>
</div>
<p>Find local minima by comparing to all neighboring pixels (maximal
connectivity):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">local_minima</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">array([[False, False, False, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False, False, False, False],</span>
<span class="go">       [ True, False, False, False, False, False,  True]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_minima</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(array([1, 1, 2, 2, 3, 3]), array([1, 2, 1, 2, 0, 6]))</span>
</pre></div>
</div>
<p>Find local minima without comparing to diagonal pixels (connectivity 1):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">local_minima</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[False, False, False, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [ True, False, False, False, False, False,  True]])</span>
</pre></div>
</div>
<p>and exclude minima that border the image edge:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">local_minima</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_borders</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([[False, False, False, False, False, False, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [False,  True,  True, False,  True,  True, False],</span>
<span class="go">       [False, False, False, False, False, False, False]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="max-tree">
<h2>max_tree<a class="headerlink" href="#max-tree" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.max_tree">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">max_tree</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">connectivity=1</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/max_tree.py#L53"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.max_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the max tree from an image.</p>
<p>Component trees represent the hierarchical structure of the connected
components resulting from sequential thresholding operations applied to an
image. A connected component at one level is parent of a component at a
higher level if the latter is included in the first. A max-tree is an
efficient representation of a component tree. A connected component at
one level is represented by one reference pixel at this level, which is
parent to all other pixels at that level and to the reference pixel at the
level above. The max-tree is the basis for many morphological operators,
namely connected operators.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the max-tree is to be calculated.
This image can be of any type.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">unsigned int, optional</span></dt><dd><p>The neighborhood connectivity. The integer represents the maximum
number of orthogonal steps to reach a neighbor. In 2D, it is 1 for
a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>parent</strong><span class="classifier">ndarray, int64</span></dt><dd><p>Array of same shape as image. The value of each pixel is the index of
its parent in the ravelled array.</p>
</dd>
<dt><strong>tree_traverser</strong><span class="classifier">1D array, int64</span></dt><dd><p>The ordered pixel indices (referring to the ravelled array). The pixels
are ordered such that every pixel is preceded by its parent (except for
the root which has no parent).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd26fa56f6eaa-1"><span class="brackets">1</span></dt>
<dd><p>Salembier, P., Oliveras, A., &amp; Garrido, L. (1998). Antiextensive
Connected Operators for Image and Sequence Processing.
IEEE Transactions on Image Processing, 7(4), 555-570.
<a class="reference external" href="https://doi.org/10.1109/83.663500">DOI:10.1109/83.663500</a></p>
</dd>
<dt class="label" id="rd26fa56f6eaa-2"><span class="brackets">2</span></dt>
<dd><p>Berger, C., Geraud, T., Levillain, R., Widynski, N., Baillard, A.,
Bertin, E. (2007). Effective Component Tree Computation with
Application to Pattern Recognition in Astronomical Imaging.
In International Conference on Image Processing (ICIP) (pp. 41-44).
<a class="reference external" href="https://doi.org/10.1109/ICIP.2007.4379949">DOI:10.1109/ICIP.2007.4379949</a></p>
</dd>
<dt class="label" id="rd26fa56f6eaa-3"><span class="brackets">3</span></dt>
<dd><p>Najman, L., &amp; Couprie, M. (2006). Building the component tree in
quasi-linear time. IEEE Transactions on Image Processing, 15(11),
3531-3539.
<a class="reference external" href="https://doi.org/10.1109/TIP.2006.877518">DOI:10.1109/TIP.2006.877518</a></p>
</dd>
<dt class="label" id="rd26fa56f6eaa-4"><span class="brackets">4</span></dt>
<dd><p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of
Component Tree Computation Algorithms. IEEE Transactions on Image
Processing, 23(9), 3885-3895.
<a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>We create a small sample image (Figure 1 from [4]) and build the max-tree.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">],</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">max_tree</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-max-tree">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.max_tree</span></code><a class="headerlink" href="#examples-using-skimage-morphology-max-tree" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="The max-tree is a hierarchical representation of an image that is the basis for a large family ..."><div class="figure align-default" id="id79">
<img alt="../_images/sphx_glr_plot_max_tree_thumb.png" src="../_images/sphx_glr_plot_max_tree_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/developers/plot_max_tree.html#sphx-glr-auto-examples-developers-plot-max-tree-py"><span class="std std-ref">Max-tree</span></a></span><a class="headerlink" href="#id79" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="max-tree-local-maxima">
<h2>max_tree_local_maxima<a class="headerlink" href="#max-tree-local-maxima" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.max_tree_local_maxima">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">max_tree_local_maxima</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">connectivity=1</em>, <em class="sig-param">parent=None</em>, <em class="sig-param">tree_traverser=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/max_tree.py#L582"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.max_tree_local_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine all local maxima of the image.</p>
<p>The local maxima are defined as connected sets of pixels with equal
gray level strictly greater than the gray levels of all pixels in direct
neighborhood of the set. The function labels the local maxima.</p>
<p>Technically, the implementation is based on the max-tree representation
of an image. The function is very efficient if the max-tree representation
has already been computed. Otherwise, it is preferable to use
the function local_maxima.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>The input image for which the maxima are to be calculated.</p>
</dd>
<dt><strong>connectivity: unsigned int, optional</strong></dt><dd><p>The neighborhood connectivity. The integer represents the maximum
number of orthogonal steps to reach a neighbor. In 2D, it is 1 for
a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p>
</dd>
<dt><strong>parent: ndarray, int64, optional</strong></dt><dd><p>The value of each pixel is the index of its parent in the ravelled
array.</p>
</dd>
<dt><strong>tree_traverser: 1D array, int64, optional</strong></dt><dd><p>The ordered pixel indices (referring to the ravelled array). The pixels
are ordered such that every pixel is preceded by its parent (except for
the root which has no parent).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>local_max</strong><span class="classifier">ndarray, uint64</span></dt><dd><p>Labeled local maxima of the image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.local_maxima" title="skimage.morphology.local_maxima"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.local_maxima</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.max_tree</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r3593ae75839c-1"><span class="brackets">1</span></dt>
<dd><p>Vincent L., Proc. “Grayscale area openings and closings,
their efficient implementation and applications”,
EURASIP Workshop on Mathematical Morphology and its
Applications to Signal Processing, Barcelona, Spain, pp.22-27,
May 1993.</p>
</dd>
<dt class="label" id="r3593ae75839c-2"><span class="brackets">2</span></dt>
<dd><p>Soille, P., “Morphological Image Analysis: Principles and
Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.
<a class="reference external" href="https://doi.org/10.1007/978-3-662-05088-0">DOI:10.1007/978-3-662-05088-0</a></p>
</dd>
<dt class="label" id="r3593ae75839c-3"><span class="brackets">3</span></dt>
<dd><p>Salembier, P., Oliveras, A., &amp; Garrido, L. (1998). Antiextensive
Connected Operators for Image and Sequence Processing.
IEEE Transactions on Image Processing, 7(4), 555-570.
<a class="reference external" href="https://doi.org/10.1109/83.663500">DOI:10.1109/83.663500</a></p>
</dd>
<dt class="label" id="r3593ae75839c-4"><span class="brackets">4</span></dt>
<dd><p>Najman, L., &amp; Couprie, M. (2006). Building the component tree in
quasi-linear time. IEEE Transactions on Image Processing, 15(11),
3531-3539.
<a class="reference external" href="https://doi.org/10.1109/TIP.2006.877518">DOI:10.1109/TIP.2006.877518</a></p>
</dd>
<dt class="label" id="r3593ae75839c-5"><span class="brackets">5</span></dt>
<dd><p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of
Component Tree Computation Algorithms. IEEE Transactions on Image
Processing, 23(9), 3885-3895.
<a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>We create an image (quadratic function with a maximum in the center and
4 additional constant maxima.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate all local maxima:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">maxima</span> <span class="o">=</span> <span class="n">max_tree_local_maxima</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting image contains the labeled local maxima.</p>
</dd></dl>

</div>
<div class="section" id="medial-axis">
<h2>medial_axis<a class="headerlink" href="#medial-axis" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.medial_axis">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">medial_axis</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">mask=None</em>, <em class="sig-param">return_distance=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/_skeletonize.py#L364"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.medial_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the medial axis transform of a binary image</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">binary ndarray, shape (M, N)</span></dt><dd><p>The image of the shape to be skeletonized.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">binary ndarray, shape (M, N), optional</span></dt><dd><p>If a mask is given, only those elements in <em class="xref py py-obj">image</em> with a true
value in <em class="xref py py-obj">mask</em> are used for computing the medial axis.</p>
</dd>
<dt><strong>return_distance</strong><span class="classifier">bool, optional</span></dt><dd><p>If true, the distance transform is returned as well as the skeleton.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of bools</span></dt><dd><p>Medial axis transform of the image</p>
</dd>
<dt><strong>dist</strong><span class="classifier">ndarray of ints, optional</span></dt><dd><p>Distance transform of the image (only returned if <em class="xref py py-obj">return_distance</em>
is True)</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skeletonize</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This algorithm computes the medial axis transform of an image
as the ridges of its distance transform.</p>
<dl class="simple">
<dt>The different steps of the algorithm are as follows</dt><dd><ul class="simple">
<li><p>A lookup table is used, that assigns 0 or 1 to each configuration of
the 3x3 binary square, whether the central pixel should be removed
or kept. We want a point to be removed if it has more than one neighbor
and if removing it does not change the number of connected components.</p></li>
<li><p>The distance transform to the background is computed, as well as
the cornerness of the pixel.</p></li>
<li><p>The foreground (value of 1) points are ordered by
the distance transform, then the cornerness.</p></li>
<li><p>A cython function is called to reduce the image to its skeleton. It
processes pixels in the order determined at the previous step, and
removes or maintains a pixel according to the lookup table. Because
of the ordering, it is possible to process all pixels in only one
pass.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">medial_axis</span><span class="p">(</span><span class="n">square</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-medial-axis">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.medial_axis</span></code><a class="headerlink" href="#examples-using-skimage-morphology-medial-axis" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Skeletonization reduces binary objects to 1 pixel wide representations. This can be useful for ..."><div class="figure align-default" id="id80">
<img alt="../_images/sphx_glr_plot_skeleton_thumb.png" src="../_images/sphx_glr_plot_skeleton_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/edges/plot_skeleton.html#sphx-glr-auto-examples-edges-plot-skeleton-py"><span class="std std-ref">Skeletonize</span></a></span><a class="headerlink" href="#id80" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="octagon">
<h2>octagon<a class="headerlink" href="#octagon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.octagon">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">octagon</code><span class="sig-paren">(</span><em class="sig-param">m</em>, <em class="sig-param">n</em>, <em class="sig-param">dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/selem.py#L252"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.octagon" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an octagon shaped structuring element.</p>
<p>For a given size of (m) horizontal and vertical sides
and a given (n) height or width of slanted sides octagon is generated.
The slanted sides are 45 or 135 degrees to the horizontal axis
and hence the widths and heights are equal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>m</strong><span class="classifier">int</span></dt><dd><p>The size of the horizontal and vertical sides.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The height or width of the slanted sides.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-octagon">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.octagon</span></code><a class="headerlink" href="#examples-using-skimage-morphology-octagon" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :py:mod:`skimage.morphology` to generate structuring..."><div class="figure align-default" id="id81">
<img alt="../_images/sphx_glr_plot_structuring_elements_thumb.png" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate structuring elements</span></a></span><a class="headerlink" href="#id81" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="octahedron">
<h2>octahedron<a class="headerlink" href="#octahedron" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.octahedron">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">octahedron</code><span class="sig-paren">(</span><em class="sig-param">radius</em>, <em class="sig-param">dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/selem.py#L187"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.octahedron" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a octahedron-shaped structuring element.</p>
<p>This is the 3D equivalent of a diamond.
A pixel is part of the neighborhood (i.e. labeled 1) if
the city block/Manhattan distance between it and the center of
the neighborhood is no greater than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the octahedron-shaped structuring element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-octahedron">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.octahedron</span></code><a class="headerlink" href="#examples-using-skimage-morphology-octahedron" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :py:mod:`skimage.morphology` to generate structuring..."><div class="figure align-default" id="id82">
<img alt="../_images/sphx_glr_plot_structuring_elements_thumb.png" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate structuring elements</span></a></span><a class="headerlink" href="#id82" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="opening">
<h2>opening<a class="headerlink" href="#opening" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.opening">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">opening</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">selem=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/misc.py#L35"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.opening" title="Permalink to this definition">¶</a></dt>
<dd><p>Return greyscale morphological opening of an image.</p>
<p>The morphological opening on an image is defined as an erosion followed by
a dilation. Opening can remove small bright spots (i.e. “salt”) and connect
small dark cracks. This tends to “open” up (dark) gaps between (bright)
features.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>opening</strong><span class="classifier">array, same shape and type as <em class="xref py py-obj">image</em></span></dt><dd><p>The result of the morphological opening.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Open up gap between two bright regions (but also shrink regions)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bad_connection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opening</span><span class="p">(</span><span class="n">bad_connection</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 0, 1, 1],</span>
<span class="go">       [1, 1, 0, 1, 1],</span>
<span class="go">       [1, 1, 0, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-opening">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.opening</span></code><a class="headerlink" href="#examples-using-skimage-morphology-opening" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example is about comparing the segmentations obtained using the plain SLIC method [1]_ and..."><div class="figure align-default" id="id83">
<img alt="../_images/sphx_glr_plot_mask_slic_thumb.png" src="../_images/sphx_glr_plot_mask_slic_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_mask_slic.html#sphx-glr-auto-examples-segmentation-plot-mask-slic-py"><span class="std std-ref">maskSLIC Demonstration</span></a></span><a class="headerlink" href="#id83" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><div class="figure align-default" id="id84">
<img alt="../_images/sphx_glr_plot_morphology_thumb.png" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></span><a class="headerlink" href="#id84" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="reconstruction">
<h2>reconstruction<a class="headerlink" href="#reconstruction" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.reconstruction">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">reconstruction</code><span class="sig-paren">(</span><em class="sig-param">seed</em>, <em class="sig-param">mask</em>, <em class="sig-param">method='dilation'</em>, <em class="sig-param">selem=None</em>, <em class="sig-param">offset=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/greyreconstruct.py#L17"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.reconstruction" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a morphological reconstruction of an image.</p>
<p>Morphological reconstruction by dilation is similar to basic morphological
dilation: high-intensity values will replace nearby low-intensity values.
The basic dilation operator, however, uses a structuring element to
determine how far a value in the input image can spread. In contrast,
reconstruction uses two images: a “seed” image, which specifies the values
that spread, and a “mask” image, which gives the maximum allowed value at
each pixel. The mask image, like the structuring element, limits the spread
of high-intensity values. Reconstruction by erosion is simply the inverse:
low-intensity values spread from the seed image and are limited by the mask
image, which represents the minimum allowed value.</p>
<p>Alternatively, you can think of reconstruction as a way to isolate the
connected regions of an image. For dilation, reconstruction connects
regions marked by local maxima in the seed image: neighboring pixels
less-than-or-equal-to those seeds are connected to the seeded region.
Local maxima with values larger than the seed image will get truncated to
the seed value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seed</strong><span class="classifier">ndarray</span></dt><dd><p>The seed image (a.k.a. marker image), which specifies the values that
are dilated or eroded.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">ndarray</span></dt><dd><p>The maximum (dilation) / minimum (erosion) allowed value at each pixel.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘dilation’|’erosion’}, optional</span></dt><dd><p>Perform reconstruction by dilation or erosion. In dilation (or
erosion), the seed image is dilated (or eroded) until limited by the
mask image. For dilation, each seed value must be less than or equal
to the corresponding mask value; for erosion, the reverse is true.
Default is ‘dilation’.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an n-D array of 1’s and 0’s.
Default is the n-D square of radius equal to 1 (i.e. a 3x3 square
for 2D images, a 3x3x3 cube for 3D images, etc.)</p>
</dd>
<dt><strong>offset</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The coordinates of the center of the structuring element.
Default is located on the geometrical center of the selem, in that case
selem dimensions must be odd.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reconstructed</strong><span class="classifier">ndarray</span></dt><dd><p>The result of morphological reconstruction.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The algorithm is taken from <a class="reference internal" href="#r4e1a5d6f491d-1" id="id30">[1]</a>. Applications for greyscale reconstruction
are discussed in <a class="reference internal" href="#r4e1a5d6f491d-2" id="id31">[2]</a> and <a class="reference internal" href="#r4e1a5d6f491d-3" id="id32">[3]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4e1a5d6f491d-1"><span class="brackets"><a class="fn-backref" href="#id30">1</a></span></dt>
<dd><p>Robinson, “Efficient morphological reconstruction: a downhill
filter”, Pattern Recognition Letters 25 (2004) 1759-1767.</p>
</dd>
<dt class="label" id="r4e1a5d6f491d-2"><span class="brackets"><a class="fn-backref" href="#id31">2</a></span></dt>
<dd><p>Vincent, L., “Morphological Grayscale Reconstruction in Image
Analysis: Applications and Efficient Algorithms”, IEEE Transactions
on Image Processing (1993)</p>
</dd>
<dt class="label" id="r4e1a5d6f491d-3"><span class="brackets"><a class="fn-backref" href="#id32">3</a></span></dt>
<dd><p>Soille, P., “Morphological Image Analysis: Principles and
Applications”, Chapter 6, 2nd edition (2003), ISBN 3540429883.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">reconstruction</span>
</pre></div>
</div>
<p>First, we create a sinusoidal mask image with peaks at middle and ends.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, we create a seed image initialized to the minimum mask value (for
reconstruction by dilation, min-intensity values don’t spread) and add
“seeds” to the left and right peak, but at a fraction of peak value (1).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_seed</span> <span class="o">=</span> <span class="n">y_mask</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_seed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_seed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_rec</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">y_seed</span><span class="p">,</span> <span class="n">y_mask</span><span class="p">)</span>
</pre></div>
</div>
<p>The reconstructed image (or curve, in this case) is exactly the same as the
mask image, except that the peaks are truncated to 0.5 and 0. The middle
peak disappears completely: Since there were no seed values in this peak
region, its reconstructed value is truncated to the surrounding value (-1).</p>
<p>As a more practical example, we try to extract the bright features of an
image by subtracting a background image created by reconstruction.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="mi">20</span><span class="p">:</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mf">0.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bumps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>To create the background image, set the mask image to the original image,
and the seed image to the original image with an intensity offset, <em class="xref py py-obj">h</em>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seed</span> <span class="o">=</span> <span class="n">bumps</span> <span class="o">-</span> <span class="n">h</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">bumps</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting reconstructed image looks exactly like the original image,
but with the peaks of the bumps cut off. Subtracting this reconstructed
image from the original image leaves just the peaks of the bumps</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdome</span> <span class="o">=</span> <span class="n">bumps</span> <span class="o">-</span> <span class="n">background</span>
</pre></div>
</div>
<p>This operation is known as the h-dome of the image and leaves features
of height <em class="xref py py-obj">h</em> in the subtracted image.</p>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-reconstruction">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.reconstruction</span></code><a class="headerlink" href="#examples-using-skimage-morphology-reconstruction" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Here, we use morphological reconstruction to create a background image, which we can subtract f..."><div class="figure align-default" id="id85">
<img alt="../_images/sphx_glr_plot_regional_maxima_thumb.png" src="../_images/sphx_glr_plot_regional_maxima_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/color_exposure/plot_regional_maxima.html#sphx-glr-auto-examples-color-exposure-plot-regional-maxima-py"><span class="std std-ref">Filtering regional maxima</span></a></span><a class="headerlink" href="#id85" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="We fill holes (i.e. isolated, dark spots) in an image using morphological reconstruction by ero..."><div class="figure align-default" id="id86">
<img alt="../_images/sphx_glr_plot_holes_and_peaks_thumb.png" src="../_images/sphx_glr_plot_holes_and_peaks_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/features_detection/plot_holes_and_peaks.html#sphx-glr-auto-examples-features-detection-plot-holes-and-peaks-py"><span class="std std-ref">Filling holes and finding peaks</span></a></span><a class="headerlink" href="#id86" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="rectangle">
<h2>rectangle<a class="headerlink" href="#rectangle" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.rectangle">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">rectangle</code><span class="sig-paren">(</span><em class="sig-param">width</em>, <em class="sig-param">height</em>, <em class="sig-param">dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/selem.py#L32"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a flat, rectangular-shaped structuring element.</p>
<p>Every pixel in the rectangle generated for a given width and given height
belongs to the neighborhood.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>The width of the rectangle.</p>
</dd>
<dt><strong>height</strong><span class="classifier">int</span></dt><dd><p>The height of the rectangle.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>A structuring element consisting only of ones, i.e. every
pixel belongs to the neighborhood.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-rectangle">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.rectangle</span></code><a class="headerlink" href="#examples-using-skimage-morphology-rectangle" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :py:mod:`skimage.morphology` to generate structuring..."><div class="figure align-default" id="id87">
<img alt="../_images/sphx_glr_plot_structuring_elements_thumb.png" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate structuring elements</span></a></span><a class="headerlink" href="#id87" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="remove-small-holes">
<h2>remove_small_holes<a class="headerlink" href="#remove-small-holes" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.remove_small_holes">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">remove_small_holes</code><span class="sig-paren">(</span><em class="sig-param">ar</em>, <em class="sig-param">area_threshold=64</em>, <em class="sig-param">connectivity=1</em>, <em class="sig-param">in_place=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/misc.py#L142"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.remove_small_holes" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove contiguous holes smaller than the specified size.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ar</strong><span class="classifier">ndarray (arbitrary shape, int or bool type)</span></dt><dd><p>The array containing the connected components of interest.</p>
</dd>
<dt><strong>area_threshold</strong><span class="classifier">int, optional (default: 64)</span></dt><dd><p>The maximum area, in pixels, of a contiguous hole that will be filled.
Replaces <em class="xref py py-obj">min_size</em>.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, {1, 2, …, ar.ndim}, optional (default: 1)</span></dt><dd><p>The connectivity defining the neighborhood of a pixel.</p>
</dd>
<dt><strong>in_place</strong><span class="classifier">bool, optional (default: False)</span></dt><dd><p>If <em class="xref py py-obj">True</em>, remove the connected components in the input array itself.
Otherwise, make a copy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">ndarray, same shape and type as input <em class="xref py py-obj">ar</em></span></dt><dd><p>The input array with small holes within connected components removed.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If the input array is of an invalid type, such as float or string.</p>
</dd>
<dt>ValueError</dt><dd><p>If the input array contains negative values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If the array type is int, it is assumed that it contains already-labeled
objects. The labels are not kept in the output image (this function always
outputs a bool image). It is suggested that labeling is completed after
using this function.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">morphology</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_holes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[ True,  True,  True,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True, False],</span>
<span class="go">       [ True, False, False,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_holes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[ True,  True,  True,  True,  True, False],</span>
<span class="go">       [ True,  True,  True, False,  True, False],</span>
<span class="go">       [ True, False, False,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_holes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-remove-small-holes">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_holes</span></code><a class="headerlink" href="#examples-using-skimage-morphology-remove-small-holes" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example is about comparing the segmentations obtained using the plain SLIC method [1]_ and..."><div class="figure align-default" id="id88">
<img alt="../_images/sphx_glr_plot_mask_slic_thumb.png" src="../_images/sphx_glr_plot_mask_slic_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_mask_slic.html#sphx-glr-auto-examples-segmentation-plot-mask-slic-py"><span class="std std-ref">maskSLIC Demonstration</span></a></span><a class="headerlink" href="#id88" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="remove-small-objects">
<h2>remove_small_objects<a class="headerlink" href="#remove-small-objects" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.remove_small_objects">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">remove_small_objects</code><span class="sig-paren">(</span><em class="sig-param">ar</em>, <em class="sig-param">min_size=64</em>, <em class="sig-param">connectivity=1</em>, <em class="sig-param">in_place=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/misc.py#L51"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.remove_small_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove objects smaller than the specified size.</p>
<p>Expects ar to be an array with labeled objects, and removes objects
smaller than min_size. If <em class="xref py py-obj">ar</em> is bool, the image is first labeled.
This leads to potentially different behavior for bool and 0-and-1
arrays.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ar</strong><span class="classifier">ndarray (arbitrary shape, int or bool type)</span></dt><dd><p>The array containing the objects of interest. If the array type is
int, the ints must be non-negative.</p>
</dd>
<dt><strong>min_size</strong><span class="classifier">int, optional (default: 64)</span></dt><dd><p>The smallest allowable object size.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, {1, 2, …, ar.ndim}, optional (default: 1)</span></dt><dd><p>The connectivity defining the neighborhood of a pixel. Used during
labelling if <em class="xref py py-obj">ar</em> is bool.</p>
</dd>
<dt><strong>in_place</strong><span class="classifier">bool, optional (default: False)</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, remove the objects in the input array itself.
Otherwise, make a copy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">ndarray, same shape and type as input <em class="xref py py-obj">ar</em></span></dt><dd><p>The input array with small connected components removed.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If the input array is of an invalid type, such as float or string.</p>
</dd>
<dt>ValueError</dt><dd><p>If the input array contains negative values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">morphology</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[False, False, False, False, False],</span>
<span class="go">       [ True,  True,  True, False, False],</span>
<span class="go">       [ True,  True,  True, False, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[False, False, False,  True, False],</span>
<span class="go">       [ True,  True,  True, False, False],</span>
<span class="go">       [ True,  True,  True, False, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-remove-small-objects">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.remove_small_objects</span></code><a class="headerlink" href="#examples-using-skimage-morphology-remove-small-objects" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example is about comparing the segmentations obtained using the plain SLIC method [1]_ and..."><div class="figure align-default" id="id89">
<img alt="../_images/sphx_glr_plot_mask_slic_thumb.png" src="../_images/sphx_glr_plot_mask_slic_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_mask_slic.html#sphx-glr-auto-examples-segmentation-plot-mask-slic-py"><span class="std std-ref">maskSLIC Demonstration</span></a></span><a class="headerlink" href="#id89" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="When trying out different segmentation methods, how do you know which one is best? If you have ..."><div class="figure align-default" id="id90">
<img alt="../_images/sphx_glr_plot_metrics_thumb.png" src="../_images/sphx_glr_plot_metrics_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_metrics.html#sphx-glr-auto-examples-segmentation-plot-metrics-py"><span class="std std-ref">Evaluating segmentation metrics</span></a></span><a class="headerlink" href="#id90" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example, we will see how to segment objects from a background. We use the coins image f..."><div class="figure align-default" id="id91">
<img alt="../_images/sphx_glr_plot_coins_segmentation_thumb.png" src="../_images/sphx_glr_plot_coins_segmentation_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_coins_segmentation.html#sphx-glr-auto-examples-applications-plot-coins-segmentation-py"><span class="std std-ref">Comparing edge-based and region-based segmentation</span></a></span><a class="headerlink" href="#id91" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="skeletonize">
<h2>skeletonize<a class="headerlink" href="#skeletonize" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.skeletonize">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">skeletonize</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">*</em>, <em class="sig-param">method=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/_skeletonize.py#L16"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.skeletonize" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the skeleton of a binary image.</p>
<p>Thinning is used to reduce each connected component in a binary image
to a single-pixel wide skeleton.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray, 2D or 3D</span></dt><dd><p>A binary image containing the objects to be skeletonized. Zeros
represent background, nonzero values are foreground.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘zhang’, ‘lee’}, optional</span></dt><dd><p>Which algorithm to use. Zhang’s algorithm <a class="reference internal" href="#rc75910d539e3-zha84" id="id36">[Zha84]</a> only works for
2D images, and is the default for 2D. Lee’s algorithm <a class="reference internal" href="#rc75910d539e3-lee94" id="id37">[Lee94]</a>
works for 2D or 3D images and is the default for 3D.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>skeleton</strong><span class="classifier">ndarray</span></dt><dd><p>The thinned image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">medial_axis</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rc75910d539e3-lee94"><span class="brackets"><a class="fn-backref" href="#id37">Lee94</a></span></dt>
<dd><p>T.-C. Lee, R.L. Kashyap and C.-N. Chu, Building skeleton models
via 3-D medial surface/axis thinning algorithms.
Computer Vision, Graphics, and Image Processing, 56(6):462-478, 1994.</p>
</dd>
<dt class="label" id="rc75910d539e3-zha84"><span class="brackets"><a class="fn-backref" href="#id36">Zha84</a></span></dt>
<dd><p>A fast parallel algorithm for thinning digital patterns,
T. Y. Zhang and C. Y. Suen, Communications of the ACM,
March 1984, Volume 27, Number 3.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ellipse</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ellipse</span>
<span class="go">array([[0, 0, 0, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span> <span class="o">=</span> <span class="n">skeletonize</span><span class="p">(</span><span class="n">ellipse</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-skeletonize">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.skeletonize</span></code><a class="headerlink" href="#examples-using-skimage-morphology-skeletonize" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Skeletonization reduces binary objects to 1 pixel wide representations. This can be useful for ..."><div class="figure align-default" id="id92">
<img alt="../_images/sphx_glr_plot_skeleton_thumb.png" src="../_images/sphx_glr_plot_skeleton_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/edges/plot_skeleton.html#sphx-glr-auto-examples-edges-plot-skeleton-py"><span class="std std-ref">Skeletonize</span></a></span><a class="headerlink" href="#id92" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><div class="figure align-default" id="id93">
<img alt="../_images/sphx_glr_plot_morphology_thumb.png" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></span><a class="headerlink" href="#id93" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="skeletonize-3d">
<h2>skeletonize_3d<a class="headerlink" href="#skeletonize-3d" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.skeletonize_3d">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">skeletonize_3d</code><span class="sig-paren">(</span><em class="sig-param">image</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/_skeletonize.py#L579"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.skeletonize_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the skeleton of a binary image.</p>
<p>Thinning is used to reduce each connected component in a binary image
to a single-pixel wide skeleton.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray, 2D or 3D</span></dt><dd><p>A binary image containing the objects to be skeletonized. Zeros
represent background, nonzero values are foreground.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>skeleton</strong><span class="classifier">ndarray</span></dt><dd><p>The thinned image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skeletonize</span></code></a>, <a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">medial_axis</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The method of <a class="reference internal" href="#rc9cdb497d267-lee94" id="id40">[Lee94]</a> uses an octree data structure to examine a 3x3x3
neighborhood of a pixel. The algorithm proceeds by iteratively sweeping
over the image, and removing pixels at each iteration until the image
stops changing. Each iteration consists of two steps: first, a list of
candidates for removal is assembled; then pixels from this list are
rechecked sequentially, to better preserve connectivity of the image.</p>
<p>The algorithm this function implements is different from the algorithms
used by either <a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skeletonize</span></code></a> or <a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">medial_axis</span></code></a>, thus for 2D images the
results produced by this function are generally different.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rc9cdb497d267-lee94"><span class="brackets"><a class="fn-backref" href="#id40">Lee94</a></span></dt>
<dd><p>T.-C. Lee, R.L. Kashyap and C.-N. Chu, Building skeleton models
via 3-D medial surface/axis thinning algorithms.
Computer Vision, Graphics, and Image Processing, 56(6):462-478, 1994.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="square">
<h2>square<a class="headerlink" href="#square" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.square">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">square</code><span class="sig-paren">(</span><em class="sig-param">width</em>, <em class="sig-param">dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/selem.py#L6"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.square" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a flat, square-shaped structuring element.</p>
<p>Every pixel along the perimeter has a chessboard distance
no greater than radius (radius=floor(width/2)) pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>The width and height of the square.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>A structuring element consisting only of ones, i.e. every
pixel belongs to the neighborhood.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-square">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.square</span></code><a class="headerlink" href="#examples-using-skimage-morphology-square" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :py:mod:`skimage.morphology` to generate structuring..."><div class="figure align-default" id="id94">
<img alt="../_images/sphx_glr_plot_structuring_elements_thumb.png" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate structuring elements</span></a></span><a class="headerlink" href="#id94" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Attribute operators (or connected operators) [1]_ is a family of contour preserving filtering o..."><div class="figure align-default" id="id95">
<img alt="../_images/sphx_glr_plot_attribute_operators_thumb.png" src="../_images/sphx_glr_plot_attribute_operators_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/filters/plot_attribute_operators.html#sphx-glr-auto-examples-filters-plot-attribute-operators-py"><span class="std std-ref">Attribute operators</span></a></span><a class="headerlink" href="#id95" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to segment an image with image labelling. The following steps are applie..."><div class="figure align-default" id="id96">
<img alt="../_images/sphx_glr_plot_label_thumb.png" src="../_images/sphx_glr_plot_label_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_label.html#sphx-glr-auto-examples-segmentation-plot-label-py"><span class="std std-ref">Label image regions</span></a></span><a class="headerlink" href="#id96" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="star">
<h2>star<a class="headerlink" href="#star" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.star">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">star</code><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/selem.py#L293"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.star" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a star shaped structuring element.</p>
<p>Start has 8 vertices and is an overlap of square of size <em class="xref py py-obj">2*a + 1</em>
with its 45 degree rotated version.
The slanted sides are 45 or 135 degrees to the horizontal axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">int</span></dt><dd><p>Parameter deciding the size of the star structural element. The side
of the square array returned is <em class="xref py py-obj">2*a + 1 + 2*floor(a / 2)</em>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-star">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.star</span></code><a class="headerlink" href="#examples-using-skimage-morphology-star" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use functions in :py:mod:`skimage.morphology` to generate structuring..."><div class="figure align-default" id="id97">
<img alt="../_images/sphx_glr_plot_structuring_elements_thumb.png" src="../_images/sphx_glr_plot_structuring_elements_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/numpy_operations/plot_structuring_elements.html#sphx-glr-auto-examples-numpy-operations-plot-structuring-elements-py"><span class="std std-ref">Generate structuring elements</span></a></span><a class="headerlink" href="#id97" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="thin">
<h2>thin<a class="headerlink" href="#thin" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.thin">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">thin</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">max_iter=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/_skeletonize.py#L259"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.thin" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform morphological thinning of a binary image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">binary (M, N) ndarray</span></dt><dd><p>The image to be thinned.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int, number of iterations, optional</span></dt><dd><p>Regardless of the value of this parameter, the thinned image
is returned immediately if an iteration produces no change.
If this parameter is specified it thus sets an upper bound on
the number of iterations performed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of bool</span></dt><dd><p>Thinned image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skeletonize</span></code></a>, <a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">medial_axis</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This algorithm <a class="reference internal" href="#r2b353e29d473-1" id="id42">[1]</a> works by making multiple passes over the image,
removing pixels matching a set of criteria designed to thin
connected regions while preserving eight-connected components and
2 x 2 squares <a class="reference internal" href="#r2b353e29d473-2" id="id43">[2]</a>. In each of the two sub-iterations the algorithm
correlates the intermediate skeleton image with a neighborhood mask,
then looks up each neighborhood in a lookup table indicating whether
the central pixel should be deleted in that sub-iteration.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r2b353e29d473-1"><span class="brackets"><a class="fn-backref" href="#id42">1</a></span></dt>
<dd><p>Z. Guo and R. W. Hall, “Parallel thinning with
two-subiteration algorithms,” Comm. ACM, vol. 32, no. 3,
pp. 359-373, 1989. <a class="reference external" href="https://doi.org/10.1145/62065.62074">DOI:10.1145/62065.62074</a></p>
</dd>
<dt class="label" id="r2b353e29d473-2"><span class="brackets"><a class="fn-backref" href="#id43">2</a></span></dt>
<dd><p>Lam, L., Seong-Whan Lee, and Ching Y. Suen, “Thinning
Methodologies-A Comprehensive Survey,” IEEE Transactions on
Pattern Analysis and Machine Intelligence, Vol 14, No. 9,
p. 879, 1992. <a class="reference external" href="https://doi.org/10.1109/34.161346">DOI:10.1109/34.161346</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span>
<span class="go">array([[0, 1, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span> <span class="o">=</span> <span class="n">thin</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 1, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-thin">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.thin</span></code><a class="headerlink" href="#examples-using-skimage-morphology-thin" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Skeletonization reduces binary objects to 1 pixel wide representations. This can be useful for ..."><div class="figure align-default" id="id98">
<img alt="../_images/sphx_glr_plot_skeleton_thumb.png" src="../_images/sphx_glr_plot_skeleton_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/edges/plot_skeleton.html#sphx-glr-auto-examples-edges-plot-skeleton-py"><span class="std std-ref">Skeletonize</span></a></span><a class="headerlink" href="#id98" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="watershed">
<h2>watershed<a class="headerlink" href="#watershed" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.watershed">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">watershed</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">markers=None</em>, <em class="sig-param">connectivity=1</em>, <em class="sig-param">offset=None</em>, <em class="sig-param">mask=None</em>, <em class="sig-param">compactness=0</em>, <em class="sig-param">watershed_line=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/_shared/utils.py#L152"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.watershed" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <code class="docutils literal notranslate"><span class="pre">skimage.segmentation.watershed</span></code> instead.</p>
<p>Find watershed basins in <em class="xref py py-obj">image</em> flooded from given <em class="xref py py-obj">markers</em>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray (2-D, 3-D, …) of integers</span></dt><dd><p>Data array where the lowest value points are labeled first.</p>
</dd>
<dt><strong>markers</strong><span class="classifier">int, or ndarray of int, same shape as <em class="xref py py-obj">image</em>, optional</span></dt><dd><p>The desired number of markers, or an array marking the basins with the
values to be assigned in the label matrix. Zero means not a marker. If
<code class="docutils literal notranslate"><span class="pre">None</span></code> (no markers given), the local minima of the image are used as
markers.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">ndarray, optional</span></dt><dd><p>An array with the same number of dimensions as <em class="xref py py-obj">image</em> whose
non-zero elements indicate neighbors for connection.
Following the scipy convention, default is a one-connected array of
the dimension of the image.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">array_like of shape image.ndim, optional</span></dt><dd><p>offset of the connectivity (one offset per dimension)</p>
</dd>
<dt><strong>mask</strong><span class="classifier">ndarray of bools or 0s and 1s, optional</span></dt><dd><p>Array of same shape as <em class="xref py py-obj">image</em>. Only points at which mask == True
will be labeled.</p>
</dd>
<dt><strong>compactness</strong><span class="classifier">float, optional</span></dt><dd><p>Use compact watershed <a class="reference internal" href="#r91cba7b06893-3" id="id46">[3]</a> with given compactness parameter.
Higher values result in more regularly-shaped watershed basins.</p>
</dd>
<dt><strong>watershed_line</strong><span class="classifier">bool, optional</span></dt><dd><p>If watershed_line is True, a one-pixel wide line separates the regions
obtained by the watershed algorithm. The line has the label 0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>out: ndarray</dt><dd><p>A labeled matrix of the same type and shape as markers</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="skimage.segmentation.html#skimage.segmentation.random_walker" title="skimage.segmentation.random_walker"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.segmentation.random_walker</span></code></a></dt><dd><p>random walker segmentation A segmentation algorithm based on anisotropic diffusion, usually slower than the watershed but with good results on noisy data and boundaries with holes.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function implements a watershed algorithm <a class="reference internal" href="#r91cba7b06893-1" id="id47">[1]</a> <a class="reference internal" href="#r91cba7b06893-2" id="id48">[2]</a> that apportions
pixels into marked basins. The algorithm uses a priority queue to hold
the pixels with the metric for the priority queue being pixel value, then
the time of entry into the queue - this settles ties in favor of the
closest marker.
Some ideas taken from
Soille, “Automated Basin Delineation from Digital Elevation Models Using
Mathematical Morphology”, Signal Processing 20 (1990) 171-182
The most important insight in the paper is that entry time onto the queue
solves two problems: a pixel should be assigned to the neighbor with the
largest gradient or, if there is no gradient, pixels on a plateau should
be split between markers on opposite sides.
This implementation converts all arguments to specific, lowest common
denominator types, then passes these to a C algorithm.
Markers can be determined manually, or automatically using for example
the local minima of the gradient of the image, or the local maxima of the
distance function to the background for separating overlapping objects
(see example).</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r91cba7b06893-1"><span class="brackets"><a class="fn-backref" href="#id47">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Watershed_%28image_processing%29">https://en.wikipedia.org/wiki/Watershed_%28image_processing%29</a></p>
</dd>
<dt class="label" id="r91cba7b06893-2"><span class="brackets"><a class="fn-backref" href="#id48">2</a></span></dt>
<dd><p><a class="reference external" href="http://cmm.ensmp.fr/~beucher/wtshed.html">http://cmm.ensmp.fr/~beucher/wtshed.html</a></p>
</dd>
<dt class="label" id="r91cba7b06893-3"><span class="brackets"><a class="fn-backref" href="#id46">3</a></span></dt>
<dd><p>Peer Neubert &amp; Peter Protzel (2014). Compact Watershed and
Preemptive SLIC: On Improving Trade-offs of Superpixel Segmentation
Algorithms. ICPR 2014, pp 996-1001. <a class="reference external" href="https://doi.org/10.1109/ICPR.2014.181">DOI:10.1109/ICPR.2014.181</a>
<a class="reference external" href="https://www.tu-chemnitz.de/etit/proaut/publications/cws_pSLIC_ICPR.pdf">https://www.tu-chemnitz.de/etit/proaut/publications/cws_pSLIC_ICPR.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The watershed algorithm is useful to separate overlapping objects.</p>
<p>We first generate an initial image with two overlapping circles:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">((</span><span class="mi">80</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">52</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask_circle1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">r1</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask_circle2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">r2</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask_circle1</span><span class="p">,</span> <span class="n">mask_circle2</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we want to separate the two circles. We generate markers at the
maxima of the distance to the background:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span> <span class="k">as</span> <span class="n">ndi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distance</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">peak_local_max</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_maxi</span> <span class="o">=</span> <span class="n">peak_local_max</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">footprint</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
<span class="gp">... </span>                            <span class="n">indices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">markers</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">local_maxi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Finally, we run the watershed on the image and markers:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">watershed</span><span class="p">(</span><span class="o">-</span><span class="n">distance</span><span class="p">,</span> <span class="n">markers</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>  
</pre></div>
</div>
<p>The algorithm works also for 3-D images, and can be used for example to
separate overlapping spheres.</p>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-watershed">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.watershed</span></code><a class="headerlink" href="#examples-using-skimage-morphology-watershed" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="The watershed transform is commonly used as a starting point for many segmentation algorithms. ..."><div class="figure align-default" id="id99">
<img alt="../_images/sphx_glr_plot_compact_watershed_thumb.png" src="../_images/sphx_glr_plot_compact_watershed_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_compact_watershed.html#sphx-glr-auto-examples-segmentation-plot-compact-watershed-py"><span class="std std-ref">Find Regular Segments Using Compact Watershed</span></a></span><a class="headerlink" href="#id99" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
<div class="section" id="white-tophat">
<h2>white_tophat<a class="headerlink" href="#white-tophat" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.white_tophat">
<code class="sig-prename descclassname">skimage.morphology.</code><code class="sig-name descname">white_tophat</code><span class="sig-paren">(</span><em class="sig-param">image</em>, <em class="sig-param">selem=None</em>, <em class="sig-param">out=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.17.2/skimage/morphology/misc.py#L35"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.white_tophat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return white top hat of an image.</p>
<p>The white top hat of an image is defined as the image minus its
morphological opening. This operation returns the bright spots of the image
that are smaller than the structuring element.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">array, same shape and type as <em class="xref py py-obj">image</em></span></dt><dd><p>The result of the morphological white top hat.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#skimage.morphology.black_tophat" title="skimage.morphology.black_tophat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">black_tophat</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9700090f0649-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Top-hat_transform">https://en.wikipedia.org/wiki/Top-hat_transform</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Subtract grey background from bright peak</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bright_on_grey</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">white_tophat</span><span class="p">(</span><span class="n">bright_on_grey</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 1, 5, 1, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-morphology-white-tophat">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.morphology.white_tophat</span></code><a class="headerlink" href="#examples-using-skimage-morphology-white-tophat" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to remove small objects from grayscale images. The top-hat transform [1]..."><div class="figure align-default" id="id100">
<img alt="../_images/sphx_glr_plot_tophat_thumb.png" src="../_images/sphx_glr_plot_tophat_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/filters/plot_tophat.html#sphx-glr-auto-examples-filters-plot-tophat-py"><span class="std std-ref">Removing small objects in grayscale images with a top hat filter</span></a></span><a class="headerlink" href="#id100" title="Permalink to this image">¶</a></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Morphological image processing is a collection of non-linear operations related to the shape or..."><div class="figure align-default" id="id101">
<img alt="../_images/sphx_glr_plot_morphology_thumb.png" src="../_images/sphx_glr_plot_morphology_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_morphology.html#sphx-glr-auto-examples-applications-plot-morphology-py"><span class="std std-ref">Morphological Filtering</span></a></span><a class="headerlink" href="#id101" title="Permalink to this image">¶</a></p>
</div>
</div></div>
</div>
</div>


        </div>
    </div>
    <div class="well footer" role="contentinfo">
        <small>
            &copy; Copyright the scikit-image development team.
            Created using <a href="https://getbootstrap.com/">Bootstrap</a> and <a href="https://www.sphinx-doc.org/">Sphinx</a>.
        </small>
    </div>
</body>
</html>


<!-- Matomo -->
<script type="text/javascript">
  var _paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(["setDocumentTitle", document.domain + "/" + document.title]);
  _paq.push(["setCookieDomain", "*.scikit-image.org"]);
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="https://scikit-image.matomo.cloud/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src='//cdn.matomo.cloud/scikit-image.matomo.cloud/matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<!-- End Matomo Code -->