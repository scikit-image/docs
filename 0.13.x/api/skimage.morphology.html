


<!DOCTYPE html>
<html lang="en">
<head>
        <title>Module: morphology &mdash; skimage v0.13.1 docs</title>
    
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../_static/css/custom.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    
    <script src="http://code.jquery.com/jquery-latest.js"></script>
    <script src="../_static/js/bootstrap.min.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.13.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <link rel="index" title="Index" href="../genindex.html" />
        <link rel="search" title="Search" href="../search.html" />
        <link rel="top" title="skimage v0.13.1 docs" href="../index.html" />
        <link rel="up" title="API Reference for skimage 0.13.1" href="api.html" />
        <link rel="next" title="Module: novice" href="skimage.novice.html" />
        <link rel="prev" title="Module: measure" href="skimage.measure.html" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="shortcut icon" href="../_static/favicon.ico">
</head>
<body class="container">
    <a href="http://scikit-image.org" class="logo"><img src="../_static/img/logo.png" alt=""></a>
    <div class="clearfix"></div>
    <div class="navbar">
        <div class="navbar-inner">
            <ul class="nav">
                <li><a href="/docs/stable/install.html">Download</a></li>
<li><a href="/docs/dev/auto_examples">Gallery</a></li>
<li><a href="/docs/dev">Documentation</a></li>
<li><a href="/community_guidelines.html">Community Guidelines</a></li>

<li><a href="https://github.com/scikit-image/scikit-image">
    <img src="../_static/GitHub-Mark-32px.png"
        style="height: 15px; width: 15px;
               display: inline; float: none;
               padding-bottom: 3px;">
    Source</a>
</li>
            </ul>
        </div>
    </div>
    <div class="row">
        <div class="span3"><div style="padding-bottom: 3em">
  <form class="navbar-form pull-right" action="../search.html" method="get">
    <input type="text" class="search span3" name="q" placeholder="Search documentation ...">
    <input type="hidden" name="check_keywords" value="yes" >
    <input type="hidden" name="area" value="default" >
  </form>
</div><!-- 
        <h4 class="sidebar-box-heading">Contents</h4>
        <div class="well sidebar-box toc">
            <ul class="nav nav-list">
<li><a class="reference internal" href="#">Module: <code class="docutils literal"><span class="pre">morphology</span></code></a><ul class="nav nav-list">
<li><a class="reference internal" href="#ball">ball</a></li>
<li><a class="reference internal" href="#binary-closing">binary_closing</a></li>
<li><a class="reference internal" href="#binary-dilation">binary_dilation</a></li>
<li><a class="reference internal" href="#binary-erosion">binary_erosion</a></li>
<li><a class="reference internal" href="#binary-opening">binary_opening</a></li>
<li><a class="reference internal" href="#black-tophat">black_tophat</a></li>
<li><a class="reference internal" href="#closing">closing</a></li>
<li><a class="reference internal" href="#convex-hull-image">convex_hull_image</a></li>
<li><a class="reference internal" href="#convex-hull-object">convex_hull_object</a></li>
<li><a class="reference internal" href="#cube">cube</a></li>
<li><a class="reference internal" href="#diamond">diamond</a></li>
<li><a class="reference internal" href="#dilation">dilation</a></li>
<li><a class="reference internal" href="#disk">disk</a></li>
<li><a class="reference internal" href="#erosion">erosion</a></li>
<li><a class="reference internal" href="#h-maxima">h_maxima</a></li>
<li><a class="reference internal" href="#h-minima">h_minima</a></li>
<li><a class="reference internal" href="#label">label</a></li>
<li><a class="reference internal" href="#local-maxima">local_maxima</a></li>
<li><a class="reference internal" href="#local-minima">local_minima</a></li>
<li><a class="reference internal" href="#medial-axis">medial_axis</a></li>
<li><a class="reference internal" href="#octagon">octagon</a></li>
<li><a class="reference internal" href="#octahedron">octahedron</a></li>
<li><a class="reference internal" href="#opening">opening</a></li>
<li><a class="reference internal" href="#reconstruction">reconstruction</a></li>
<li><a class="reference internal" href="#rectangle">rectangle</a></li>
<li><a class="reference internal" href="#remove-small-holes">remove_small_holes</a></li>
<li><a class="reference internal" href="#remove-small-objects">remove_small_objects</a></li>
<li><a class="reference internal" href="#skeletonize">skeletonize</a></li>
<li><a class="reference internal" href="#skeletonize-3d">skeletonize_3d</a></li>
<li><a class="reference internal" href="#square">square</a></li>
<li><a class="reference internal" href="#star">star</a></li>
<li><a class="reference internal" href="#thin">thin</a></li>
<li><a class="reference internal" href="#watershed">watershed</a></li>
<li><a class="reference internal" href="#white-tophat">white_tophat</a></li>
</ul>
</li>
</ul>

        </div>


 --><div class="well">
    <strong>Docs for 0.13.1<br></strong>

    <a id="other">All versions</a>

    <ul id="versionList" style="display: none;">
        <script src="../../dev/_static/docversions.js"></script>
        <script type="text/javascript">
            insert_version_links();
        </script>
    </ul>

 </div>

<script type="text/javascript">
	$("#other").click(function() {
		$("#versionList").toggle();
	});
</script>
        </div>
        <div class="span9">
            
  <div class="section" id="module-skimage.morphology">
<span id="module-morphology"></span><h1>Module: <code class="xref py py-mod docutils literal"><span class="pre">morphology</span></code><a class="headerlink" href="#module-skimage.morphology" title="Permalink to this headline">¶</a></h1>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.ball" title="skimage.morphology.ball"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.ball</span></code></a>(radius[,&nbsp;dtype])</td>
<td>Generates a ball-shaped structuring element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.binary_closing" title="skimage.morphology.binary_closing"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.binary_closing</span></code></a>(image[,&nbsp;…])</td>
<td>Return fast binary morphological closing of an image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.binary_dilation" title="skimage.morphology.binary_dilation"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.binary_dilation</span></code></a>(image[,&nbsp;…])</td>
<td>Return fast binary morphological dilation of an image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.binary_erosion" title="skimage.morphology.binary_erosion"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.binary_erosion</span></code></a>(image[,&nbsp;…])</td>
<td>Return fast binary morphological erosion of an image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.binary_opening" title="skimage.morphology.binary_opening"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.binary_opening</span></code></a>(image[,&nbsp;…])</td>
<td>Return fast binary morphological opening of an image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.black_tophat" title="skimage.morphology.black_tophat"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.black_tophat</span></code></a>(image[,&nbsp;…])</td>
<td>Return black top hat of an image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.closing" title="skimage.morphology.closing"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.closing</span></code></a>(image[,&nbsp;selem,&nbsp;out])</td>
<td>Return greyscale morphological closing of an image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.convex_hull_image" title="skimage.morphology.convex_hull_image"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.convex_hull_image</span></code></a>(image)</td>
<td>Compute the convex hull image of a binary image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.convex_hull_object" title="skimage.morphology.convex_hull_object"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.convex_hull_object</span></code></a>(image)</td>
<td>Compute the convex hull image of individual objects in a binary image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.cube" title="skimage.morphology.cube"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.cube</span></code></a>(width[,&nbsp;dtype])</td>
<td>Generates a cube-shaped structuring element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.diamond" title="skimage.morphology.diamond"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.diamond</span></code></a>(radius[,&nbsp;dtype])</td>
<td>Generates a flat, diamond-shaped structuring element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.dilation" title="skimage.morphology.dilation"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.dilation</span></code></a>(image[,&nbsp;selem,&nbsp;…])</td>
<td>Return greyscale morphological dilation of an image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.disk" title="skimage.morphology.disk"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.disk</span></code></a>(radius[,&nbsp;dtype])</td>
<td>Generates a flat, disk-shaped structuring element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.erosion" title="skimage.morphology.erosion"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.erosion</span></code></a>(image[,&nbsp;selem,&nbsp;…])</td>
<td>Return greyscale morphological erosion of an image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.h_maxima" title="skimage.morphology.h_maxima"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.h_maxima</span></code></a>(img,&nbsp;h[,&nbsp;selem])</td>
<td>Determine all maxima of the image with height &gt;= h.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.h_minima" title="skimage.morphology.h_minima"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.h_minima</span></code></a>(img,&nbsp;h[,&nbsp;selem])</td>
<td>Determine all minima of the image with depth &gt;= h.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.label" title="skimage.morphology.label"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.label</span></code></a>(input[,&nbsp;neighbors,&nbsp;…])</td>
<td>Label connected regions of an integer array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.local_maxima" title="skimage.morphology.local_maxima"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.local_maxima</span></code></a>(img[,&nbsp;selem])</td>
<td>Determine all local maxima of the image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.local_minima" title="skimage.morphology.local_minima"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.local_minima</span></code></a>(img[,&nbsp;selem])</td>
<td>Determine all local minima of the image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.medial_axis</span></code></a>(image[,&nbsp;…])</td>
<td>Compute the medial axis transform of a binary image</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.octagon" title="skimage.morphology.octagon"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.octagon</span></code></a>(m,&nbsp;n[,&nbsp;dtype])</td>
<td>Generates an octagon shaped structuring element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.octahedron" title="skimage.morphology.octahedron"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.octahedron</span></code></a>(radius[,&nbsp;dtype])</td>
<td>Generates a octahedron-shaped structuring element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.opening" title="skimage.morphology.opening"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.opening</span></code></a>(image[,&nbsp;selem,&nbsp;out])</td>
<td>Return greyscale morphological opening of an image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.reconstruction" title="skimage.morphology.reconstruction"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.reconstruction</span></code></a>(seed,&nbsp;mask)</td>
<td>Perform a morphological reconstruction of an image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.rectangle" title="skimage.morphology.rectangle"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.rectangle</span></code></a>(width,&nbsp;height)</td>
<td>Generates a flat, rectangular-shaped structuring element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.remove_small_holes" title="skimage.morphology.remove_small_holes"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.remove_small_holes</span></code></a>(ar[,&nbsp;…])</td>
<td>Remove continguous holes smaller than the specified size.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.remove_small_objects" title="skimage.morphology.remove_small_objects"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.remove_small_objects</span></code></a>(ar)</td>
<td>Remove connected components smaller than the specified size.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.skeletonize</span></code></a>(image)</td>
<td>Return the skeleton of a binary image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.skeletonize_3d" title="skimage.morphology.skeletonize_3d"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.skeletonize_3d</span></code></a>(img)</td>
<td>Compute the skeleton of a binary image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.square" title="skimage.morphology.square"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.square</span></code></a>(width[,&nbsp;dtype])</td>
<td>Generates a flat, square-shaped structuring element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.star" title="skimage.morphology.star"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.star</span></code></a>(a[,&nbsp;dtype])</td>
<td>Generates a star shaped structuring element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.thin" title="skimage.morphology.thin"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.thin</span></code></a>(image[,&nbsp;max_iter])</td>
<td>Perform morphological thinning of a binary image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.morphology.watershed" title="skimage.morphology.watershed"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.watershed</span></code></a>(image,&nbsp;markers)</td>
<td>Find watershed basins in <cite>image</cite> flooded from given <cite>markers</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.morphology.white_tophat" title="skimage.morphology.white_tophat"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.white_tophat</span></code></a>(image[,&nbsp;…])</td>
<td>Return white top hat of an image.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.binary</span></code></td>
<td>Binary morphological operations</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.convex_hull</span></code></td>
<td>Convex Hull.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.extrema</span></code></td>
<td>extrema.py - local minima and maxima</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.grey</span></code></td>
<td>Grayscale morphological operations</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.greyreconstruct</span></code></td>
<td>This morphological reconstruction routine was adapted from CellProfiler, code licensed under both GPL and BSD licenses.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.misc</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.selem</span></code></td>
<td></td>
</tr>
</tbody>
</table>
<div class="section" id="ball">
<h2>ball<a class="headerlink" href="#ball" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.ball">
<code class="descclassname">skimage.morphology.</code><code class="descname">ball</code><span class="sig-paren">(</span><em>radius</em>, <em>dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/selem.py#L221"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.ball" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a ball-shaped structuring element.</p>
<p>This is the 3D equivalent of a disk.
A pixel is within the neighborhood if the euclidean distance between
it and the origin is no greater than radius.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>radius</strong> : int</p>
<blockquote>
<div><p>The radius of the ball-shaped structuring element.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>selem</strong> : ndarray</p>
<blockquote>
<div><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><p class="first"><strong>dtype</strong> : data-type</p>
<blockquote class="last">
<div><p>The data type of the structuring element.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="binary-closing">
<h2>binary_closing<a class="headerlink" href="#binary-closing" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.binary_closing">
<code class="descclassname">skimage.morphology.</code><code class="descname">binary_closing</code><span class="sig-paren">(</span><em>image</em>, <em>selem=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/misc.py#L33"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.binary_closing" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fast binary morphological closing of an image.</p>
<p>This function returns the same result as greyscale closing but performs
faster for binary images.</p>
<p>The morphological closing on an image is defined as a dilation followed by
an erosion. Closing can remove small dark spots (i.e. “pepper”) and connect
small bright cracks. This tends to “close” up (dark) gaps between (bright)
features.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Binary input image.</p>
</div></blockquote>
<p><strong>selem</strong> : ndarray, optional</p>
<blockquote>
<div><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</div></blockquote>
<p><strong>out</strong> : ndarray of bool, optional</p>
<blockquote>
<div><p>The array to store the result of the morphology. If None,
is passed, a new array will be allocated.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>closing</strong> : ndarray of bool</p>
<blockquote class="last">
<div><p>The result of the morphological closing.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="binary-dilation">
<h2>binary_dilation<a class="headerlink" href="#binary-dilation" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.binary_dilation">
<code class="descclassname">skimage.morphology.</code><code class="descname">binary_dilation</code><span class="sig-paren">(</span><em>image</em>, <em>selem=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/misc.py#L33"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.binary_dilation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fast binary morphological dilation of an image.</p>
<p>This function returns the same result as greyscale dilation but performs
faster for binary images.</p>
<p>Morphological dilation sets a pixel at <code class="docutils literal"><span class="pre">(i,j)</span></code> to the maximum over all
pixels in the neighborhood centered at <code class="docutils literal"><span class="pre">(i,j)</span></code>. Dilation enlarges bright
regions and shrinks dark regions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Binary input image.</p>
</div></blockquote>
<p><strong>selem</strong> : ndarray, optional</p>
<blockquote>
<div><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</div></blockquote>
<p><strong>out</strong> : ndarray of bool, optional</p>
<blockquote>
<div><p>The array to store the result of the morphology. If None, is
passed, a new array will be allocated.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dilated</strong> : ndarray of bool or uint</p>
<blockquote class="last">
<div><p>The result of the morphological dilation with values in
<code class="docutils literal"><span class="pre">[False,</span> <span class="pre">True]</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="binary-erosion">
<h2>binary_erosion<a class="headerlink" href="#binary-erosion" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.binary_erosion">
<code class="descclassname">skimage.morphology.</code><code class="descname">binary_erosion</code><span class="sig-paren">(</span><em>image</em>, <em>selem=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/misc.py#L33"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.binary_erosion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fast binary morphological erosion of an image.</p>
<p>This function returns the same result as greyscale erosion but performs
faster for binary images.</p>
<p>Morphological erosion sets a pixel at <code class="docutils literal"><span class="pre">(i,j)</span></code> to the minimum over all
pixels in the neighborhood centered at <code class="docutils literal"><span class="pre">(i,j)</span></code>. Erosion shrinks bright
regions and enlarges dark regions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Binary input image.</p>
</div></blockquote>
<p><strong>selem</strong> : ndarray, optional</p>
<blockquote>
<div><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</div></blockquote>
<p><strong>out</strong> : ndarray of bool, optional</p>
<blockquote>
<div><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eroded</strong> : ndarray of bool or uint</p>
<blockquote class="last">
<div><p>The result of the morphological erosion taking values in
<code class="docutils literal"><span class="pre">[False,</span> <span class="pre">True]</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="binary-opening">
<h2>binary_opening<a class="headerlink" href="#binary-opening" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.binary_opening">
<code class="descclassname">skimage.morphology.</code><code class="descname">binary_opening</code><span class="sig-paren">(</span><em>image</em>, <em>selem=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/misc.py#L33"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.binary_opening" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fast binary morphological opening of an image.</p>
<p>This function returns the same result as greyscale opening but performs
faster for binary images.</p>
<p>The morphological opening on an image is defined as an erosion followed by
a dilation. Opening can remove small bright spots (i.e. “salt”) and connect
small dark cracks. This tends to “open” up (dark) gaps between (bright)
features.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Binary input image.</p>
</div></blockquote>
<p><strong>selem</strong> : ndarray, optional</p>
<blockquote>
<div><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</div></blockquote>
<p><strong>out</strong> : ndarray of bool, optional</p>
<blockquote>
<div><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>opening</strong> : ndarray of bool</p>
<blockquote class="last">
<div><p>The result of the morphological opening.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="black-tophat">
<h2>black_tophat<a class="headerlink" href="#black-tophat" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.black_tophat">
<code class="descclassname">skimage.morphology.</code><code class="descname">black_tophat</code><span class="sig-paren">(</span><em>image</em>, <em>selem=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/misc.py#L33"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.black_tophat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return black top hat of an image.</p>
<p>The black top hat of an image is defined as its morphological closing minus
the original image. This operation returns the dark spots of the image that
are smaller than the structuring element. Note that dark spots in the
original image are bright spots after the black top hat.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Image array.</p>
</div></blockquote>
<p><strong>selem</strong> : ndarray, optional</p>
<blockquote>
<div><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</div></blockquote>
<p><strong>out</strong> : ndarray, optional</p>
<blockquote>
<div><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : array, same shape and type as <cite>image</cite></p>
<blockquote class="last">
<div><p>The result of the morphological black top hat.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Change dark peak to bright peak and subtract background</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="k">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dark_on_grey</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">black_tophat</span><span class="p">(</span><span class="n">dark_on_grey</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 1, 5, 1, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="closing">
<h2>closing<a class="headerlink" href="#closing" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.closing">
<code class="descclassname">skimage.morphology.</code><code class="descname">closing</code><span class="sig-paren">(</span><em>image</em>, <em>selem=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/misc.py#L33"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.closing" title="Permalink to this definition">¶</a></dt>
<dd><p>Return greyscale morphological closing of an image.</p>
<p>The morphological closing on an image is defined as a dilation followed by
an erosion. Closing can remove small dark spots (i.e. “pepper”) and connect
small bright cracks. This tends to “close” up (dark) gaps between (bright)
features.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Image array.</p>
</div></blockquote>
<p><strong>selem</strong> : ndarray, optional</p>
<blockquote>
<div><p>The neighborhood expressed as an array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</div></blockquote>
<p><strong>out</strong> : ndarray, optional</p>
<blockquote>
<div><p>The array to store the result of the morphology. If None,
is passed, a new array will be allocated.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>closing</strong> : array, same shape and type as <cite>image</cite></p>
<blockquote class="last">
<div><p>The result of the morphological closing.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Close a gap between two bright lines</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="k">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">broken_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">closing</span><span class="p">(</span><span class="n">broken_line</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="convex-hull-image">
<h2>convex_hull_image<a class="headerlink" href="#convex-hull-image" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.convex_hull_image">
<code class="descclassname">skimage.morphology.</code><code class="descname">convex_hull_image</code><span class="sig-paren">(</span><em>image</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/convex_hull.py#L16"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.convex_hull_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the convex hull image of a binary image.</p>
<p>The convex hull is the set of pixels included in the smallest convex
polygon that surround all white pixels in the input image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : (M, N) array</p>
<blockquote>
<div><p>Binary input image. This array is cast to bool before processing.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>hull</strong> : (M, N) array of bool</p>
<blockquote class="last">
<div><p>Binary image with pixels in convex hull set to True.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r381" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[R381]</a></td><td><a class="reference external" href="http://blogs.mathworks.com/steve/2011/10/04/binary-image-convex-hull-algorithm-notes/">http://blogs.mathworks.com/steve/2011/10/04/binary-image-convex-hull-algorithm-notes/</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="convex-hull-object">
<h2>convex_hull_object<a class="headerlink" href="#convex-hull-object" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.convex_hull_object">
<code class="descclassname">skimage.morphology.</code><code class="descname">convex_hull_object</code><span class="sig-paren">(</span><em>image</em>, <em>neighbors=8</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/convex_hull.py#L83"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.convex_hull_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the convex hull image of individual objects in a binary image.</p>
<p>The convex hull is the set of pixels included in the smallest convex
polygon that surround all white pixels in the input image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : (M, N) array</p>
<blockquote>
<div><p>Binary input image.</p>
</div></blockquote>
<p><strong>neighbors</strong> : {4, 8}, int</p>
<blockquote>
<div><p>Whether to use 4- or 8-connectivity.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>hull</strong> : ndarray of bool</p>
<blockquote class="last">
<div><p>Binary image with pixels in convex hull set to True.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function uses skimage.morphology.label to define unique objects,
finds the convex hull of each using convex_hull_image, and combines
these regions with logical OR. Be aware the convex hulls of unconnected
objects may overlap in the result. If this is suspected, consider using
convex_hull_image separately on each object.</p>
</dd></dl>

</div>
<div class="section" id="cube">
<h2>cube<a class="headerlink" href="#cube" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.cube">
<code class="descclassname">skimage.morphology.</code><code class="descname">cube</code><span class="sig-paren">(</span><em>width</em>, <em>dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/selem.py#L160"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a cube-shaped structuring element.</p>
<p>This is the 3D equivalent of a square.
Every pixel along the perimeter has a chessboard distance
no greater than radius (radius=floor(width/2)) pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>width</strong> : int</p>
<blockquote>
<div><p>The width, height and depth of the cube.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>selem</strong> : ndarray</p>
<blockquote>
<div><p>A structuring element consisting only of ones, i.e. every
pixel belongs to the neighborhood.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><p class="first"><strong>dtype</strong> : data-type</p>
<blockquote class="last">
<div><p>The data type of the structuring element.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="diamond">
<h2>diamond<a class="headerlink" href="#diamond" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.diamond">
<code class="descclassname">skimage.morphology.</code><code class="descname">diamond</code><span class="sig-paren">(</span><em>radius</em>, <em>dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/selem.py#L60"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.diamond" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a flat, diamond-shaped structuring element.</p>
<p>A pixel is part of the neighborhood (i.e. labeled 1) if
the city block/Manhattan distance between it and the center of
the neighborhood is no greater than radius.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>radius</strong> : int</p>
<blockquote>
<div><p>The radius of the diamond-shaped structuring element.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>selem</strong> : ndarray</p>
<blockquote>
<div><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><p class="first"><strong>dtype</strong> : data-type</p>
<blockquote class="last">
<div><p>The data type of the structuring element.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="dilation">
<h2>dilation<a class="headerlink" href="#dilation" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.dilation">
<code class="descclassname">skimage.morphology.</code><code class="descname">dilation</code><span class="sig-paren">(</span><em>image</em>, <em>selem=None</em>, <em>out=None</em>, <em>shift_x=False</em>, <em>shift_y=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/misc.py#L33"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.dilation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return greyscale morphological dilation of an image.</p>
<p>Morphological dilation sets a pixel at (i,j) to the maximum over all pixels
in the neighborhood centered at (i,j). Dilation enlarges bright regions
and shrinks dark regions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Image array.</p>
</div></blockquote>
<p><strong>selem</strong> : ndarray, optional</p>
<blockquote>
<div><p>The neighborhood expressed as a 2-D array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</div></blockquote>
<p><strong>out</strong> : ndarray, optional</p>
<blockquote>
<div><p>The array to store the result of the morphology. If None, is
passed, a new array will be allocated.</p>
</div></blockquote>
<p><strong>shift_x, shift_y</strong> : bool, optional</p>
<blockquote>
<div><p>shift structuring element about center point. This only affects
eccentric structuring elements (i.e. selem with even numbered sides).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dilated</strong> : uint8 array, same shape and type as <cite>image</cite></p>
<blockquote class="last">
<div><p>The result of the morphological dilation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For <cite>uint8</cite> (and <cite>uint16</cite> up to a certain bit-depth) data, the lower
algorithm complexity makes the <cite>skimage.filters.rank.maximum</cite> function more
efficient for larger images and structuring elements.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Dilation enlarges bright regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="k">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bright_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dilation</span><span class="p">(</span><span class="n">bright_pixel</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 1, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="disk">
<h2>disk<a class="headerlink" href="#disk" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.disk">
<code class="descclassname">skimage.morphology.</code><code class="descname">disk</code><span class="sig-paren">(</span><em>radius</em>, <em>dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/selem.py#L90"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.disk" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a flat, disk-shaped structuring element.</p>
<p>A pixel is within the neighborhood if the euclidean distance between
it and the origin is no greater than radius.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>radius</strong> : int</p>
<blockquote>
<div><p>The radius of the disk-shaped structuring element.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>selem</strong> : ndarray</p>
<blockquote>
<div><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><p class="first"><strong>dtype</strong> : data-type</p>
<blockquote class="last">
<div><p>The data type of the structuring element.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="erosion">
<h2>erosion<a class="headerlink" href="#erosion" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.erosion">
<code class="descclassname">skimage.morphology.</code><code class="descname">erosion</code><span class="sig-paren">(</span><em>image</em>, <em>selem=None</em>, <em>out=None</em>, <em>shift_x=False</em>, <em>shift_y=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/misc.py#L33"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.erosion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return greyscale morphological erosion of an image.</p>
<p>Morphological erosion sets a pixel at (i,j) to the minimum over all pixels
in the neighborhood centered at (i,j). Erosion shrinks bright regions and
enlarges dark regions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Image array.</p>
</div></blockquote>
<p><strong>selem</strong> : ndarray, optional</p>
<blockquote>
<div><p>The neighborhood expressed as an array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</div></blockquote>
<p><strong>out</strong> : ndarrays, optional</p>
<blockquote>
<div><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</div></blockquote>
<p><strong>shift_x, shift_y</strong> : bool, optional</p>
<blockquote>
<div><p>shift structuring element about center point. This only affects
eccentric structuring elements (i.e. selem with even numbered sides).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eroded</strong> : array, same shape as <cite>image</cite></p>
<blockquote class="last">
<div><p>The result of the morphological erosion.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For <code class="docutils literal"><span class="pre">uint8</span></code> (and <code class="docutils literal"><span class="pre">uint16</span></code> up to a certain bit-depth) data, the
lower algorithm complexity makes the <cite>skimage.filters.rank.minimum</cite>
function more efficient for larger images and structuring elements.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Erosion shrinks bright regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="k">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bright_square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">erosion</span><span class="p">(</span><span class="n">bright_square</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="h-maxima">
<h2>h_maxima<a class="headerlink" href="#h-maxima" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.h_maxima">
<code class="descclassname">skimage.morphology.</code><code class="descname">h_maxima</code><span class="sig-paren">(</span><em>img</em>, <em>h</em>, <em>selem=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/extrema.py#L48"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.h_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine all maxima of the image with height &gt;= h.</p>
<p>The local maxima are defined as connected sets of pixels with equal
grey level strictly greater than the grey level of all pixels in direct
neighborhood of the set.</p>
<p>A local maximum M of height h is a local maximum for which
there is at least one path joining M with a higher maximum on which the
minimal value is f(M) - h (i.e. the values along the path are not
decreasing by more than h with respect to the maximum’s value) and no
path for which the minimal value is greater.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>img</strong> : ndarray</p>
<blockquote>
<div><p>The input image for which the maxima are to be calculated.</p>
</div></blockquote>
<p><strong>h</strong> : unsigned integer</p>
<blockquote>
<div><p>The minimal height of all extracted maxima.</p>
</div></blockquote>
<p><strong>selem</strong> : ndarray, optional</p>
<blockquote>
<div><p>The neighborhood expressed as an n-D array of 1’s and 0’s.
Default is the ball of radius 1 according to the maximum norm
(i.e. a 3x3 square for 2D images, a 3x3x3 cube for 3D images, etc.)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>h_max</strong> : ndarray</p>
<blockquote class="last">
<div><p>The maxima of height &gt;= h. The result image is a binary image, where
pixels belonging to the selected maxima take value 1, the others
take value 0.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.extrema.h_minima</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.extrema.local_maxima</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.extrema.local_minima</span></code></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r382" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[R382]</a></td><td>Soille, P., “Morphological Image Analysis: Principles and
Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="k">import</span> <span class="n">extrema</span>
</pre></div>
</div>
<p>We create an image (quadratic function with a maximum in the center and
4 additional constant maxima.
The heights of the maxima are: 1, 21, 41, 61, 81, 101</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate all maxima with a height of at least 40:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">maxima</span> <span class="o">=</span> <span class="n">extrema</span><span class="o">.</span><span class="n">h_maxima</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting image will contain 4 local maxima.</p>
</dd></dl>

</div>
<div class="section" id="h-minima">
<h2>h_minima<a class="headerlink" href="#h-minima" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.h_minima">
<code class="descclassname">skimage.morphology.</code><code class="descname">h_minima</code><span class="sig-paren">(</span><em>img</em>, <em>h</em>, <em>selem=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/extrema.py#L129"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.h_minima" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine all minima of the image with depth &gt;= h.</p>
<p>The local minima are defined as connected sets of pixels with equal
grey level strictly smaller than the grey levels of all pixels in direct
neighborhood of the set.</p>
<p>A local minimum M of depth h is a local minimum for which
there is at least one path joining M with a deeper minimum on which the
maximal value is f(M) + h (i.e. the values along the path are not
increasing by more than h with respect to the minimum’s value) and no
path for which the maximal value is smaller.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>img</strong> : ndarray</p>
<blockquote>
<div><p>The input image for which the minima are to be calculated.</p>
</div></blockquote>
<p><strong>h</strong> : unsigned integer</p>
<blockquote>
<div><p>The minimal depth of all extracted minima.</p>
</div></blockquote>
<p><strong>selem</strong> : ndarray, optional</p>
<blockquote>
<div><p>The neighborhood expressed as an n-D array of 1’s and 0’s.
Default is the ball of radius 1 according to the maximum norm
(i.e. a 3x3 square for 2D images, a 3x3x3 cube for 3D images, etc.)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>h_min</strong> : ndarray</p>
<blockquote class="last">
<div><p>The minima of depth &gt;= h. The result image is a binary image, where
pixels belonging to the selected minima take value 1, the other pixels
take value 0.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.extrema.h_maxima</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.extrema.local_maxima</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.extrema.local_minima</span></code></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r383" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[R383]</a></td><td>Soille, P., “Morphological Image Analysis: Principles and
Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="k">import</span> <span class="n">extrema</span>
</pre></div>
</div>
<p>We create an image (quadratic function with a minimum in the center and
4 additional constant maxima.
The depth of the minima are: 1, 21, 41, 61, 81, 101</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">+</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">160</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">140</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate all minima with a depth of at least 40:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minima</span> <span class="o">=</span> <span class="n">extrema</span><span class="o">.</span><span class="n">h_minima</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting image will contain 4 local minima.</p>
</dd></dl>

</div>
<div class="section" id="label">
<h2>label<a class="headerlink" href="#label" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.label">
<code class="descclassname">skimage.morphology.</code><code class="descname">label</code><span class="sig-paren">(</span><em>input</em>, <em>neighbors=None</em>, <em>background=None</em>, <em>return_num=False</em>, <em>connectivity=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_label.py#L4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Label connected regions of an integer array.</p>
<p>Two pixels are connected when they are neighbors and have the same value.
In 2D, they can be neighbors either in a 1- or 2-connected sense.
The value refers to the maximum number of orthogonal hops to consider a
pixel/voxel a neighbor:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">-</span><span class="n">connectivity</span>      <span class="mi">2</span><span class="o">-</span><span class="n">connectivity</span>     <span class="n">diagonal</span> <span class="n">connection</span> <span class="n">close</span><span class="o">-</span><span class="n">up</span>

     <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>         <span class="p">[</span> <span class="p">]</span>
      <span class="o">|</span>               \  <span class="o">|</span>  <span class="o">/</span>             <span class="o">|</span>  <span class="o">&lt;-</span> <span class="n">hop</span> <span class="mi">2</span>
<span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>      <span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>    <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>
      <span class="o">|</span>               <span class="o">/</span>  <span class="o">|</span>  \         <span class="n">hop</span> <span class="mi">1</span>
     <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>input</strong> : ndarray of dtype int</p>
<blockquote>
<div><p>Image to label.</p>
</div></blockquote>
<p><strong>neighbors</strong> : {4, 8}, int, optional</p>
<blockquote>
<div><p>Whether to use 4- or 8-“connectivity”.
In 3D, 4-“connectivity” means connected pixels have to share face,
whereas with 8-“connectivity”, they have to share only edge or vertex.
<strong>Deprecated, use ``connectivity`` instead.</strong></p>
</div></blockquote>
<p><strong>background</strong> : int, optional</p>
<blockquote>
<div><p>Consider all pixels with this value as background pixels, and label
them as 0. By default, 0-valued pixels are considered as background
pixels.</p>
</div></blockquote>
<p><strong>return_num</strong> : bool, optional</p>
<blockquote>
<div><p>Whether to return the number of assigned labels.</p>
</div></blockquote>
<p><strong>connectivity</strong> : int, optional</p>
<blockquote>
<div><p>Maximum number of orthogonal hops to consider a pixel/voxel
as a neighbor.
Accepted values are ranging from  1 to input.ndim. If <code class="docutils literal"><span class="pre">None</span></code>, a full
connectivity of <code class="docutils literal"><span class="pre">input.ndim</span></code> is used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>labels</strong> : ndarray of dtype int</p>
<blockquote>
<div><p>Labeled array, where all connected regions are assigned the
same integer value.</p>
</div></blockquote>
<p><strong>num</strong> : int, optional</p>
<blockquote class="last">
<div><p>Number of labels, which equals the maximum label index and is only
returned if return_num is <cite>True</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal"><span class="pre">regionprops</span></code></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r384" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[R384]</a></td><td>Christophe Fiorio and Jens Gustedt, “Two linear time Union-Find
strategies for image processing”, Theoretical Computer Science
154 (1996), pp. 165-181.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r385" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[R385]</a></td><td>Kensheng Wu, Ekow Otoo and Arie Shoshani, “Optimizing connected
component labeling algorithms”, Paper LBNL-56864, 2005,
Lawrence Berkeley National Laboratory (University of California),
<a class="reference external" href="http://repositories.cdlib.org/lbnl/LBNL-56864">http://repositories.cdlib.org/lbnl/LBNL-56864</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 1 0]</span>
<span class="go"> [0 0 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 2 0]</span>
<span class="go"> [0 0 3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 1 0]</span>
<span class="go"> [0 0 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">background</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1 2 2]</span>
<span class="go"> [2 1 2]</span>
<span class="go"> [2 2 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [1 1 2]</span>
<span class="go"> [0 0 0]]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="local-maxima">
<h2>local_maxima<a class="headerlink" href="#local-maxima" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.local_maxima">
<code class="descclassname">skimage.morphology.</code><code class="descname">local_maxima</code><span class="sig-paren">(</span><em>img</em>, <em>selem=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/extrema.py#L219"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.local_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine all local maxima of the image.</p>
<p>The local maxima are defined as connected sets of pixels with equal
grey level strictly greater than the grey levels of all pixels in direct
neighborhood of the set.</p>
<p>For integer typed images, this corresponds to the h-maxima with h=1.
For float typed images, h is determined as the smallest difference
between grey levels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>img</strong> : ndarray</p>
<blockquote>
<div><p>The input image for which the maxima are to be calculated.</p>
</div></blockquote>
<p><strong>selem</strong> : ndarray, optional</p>
<blockquote>
<div><p>The neighborhood expressed as an n-D array of 1’s and 0’s.
Default is the ball of radius 1 according to the maximum norm
(i.e. a 3x3 square for 2D images, a 3x3x3 cube for 3D images, etc.)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>local_max</strong> : ndarray</p>
<blockquote class="last">
<div><p>All local maxima of the image. The result image is a binary image,
where pixels belonging to local maxima take value 1, the other pixels
take value 0.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.extrema.h_minima</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.extrema.h_maxima</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.extrema.local_minima</span></code></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r386" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[R386]</a></td><td>Soille, P., “Morphological Image Analysis: Principles and
Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="k">import</span> <span class="n">extrema</span>
</pre></div>
</div>
<p>We create an image (quadratic function with a maximum in the center and
4 additional constant maxima.
The heights of the maxima are: 1, 21, 41, 61, 81, 101</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate all local maxima:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">maxima</span> <span class="o">=</span> <span class="n">extrema</span><span class="o">.</span><span class="n">local_maxima</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting image will contain all 6 local maxima.</p>
</dd></dl>

</div>
<div class="section" id="local-minima">
<h2>local_minima<a class="headerlink" href="#local-minima" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.local_minima">
<code class="descclassname">skimage.morphology.</code><code class="descname">local_minima</code><span class="sig-paren">(</span><em>img</em>, <em>selem=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/extrema.py#L287"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.local_minima" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine all local minima of the image.</p>
<p>The local minima are defined as connected sets of pixels with equal
grey level strictly smaller than the grey levels of all pixels in direct
neighborhood of the set.</p>
<p>For integer typed images, this corresponds to the h-minima with h=1.
For float typed images, h is determined as the smallest difference
between grey levels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>img</strong> : ndarray</p>
<blockquote>
<div><p>The input image for which the minima are to be calculated.</p>
</div></blockquote>
<p><strong>selem</strong> : ndarray, optional</p>
<blockquote>
<div><p>The neighborhood expressed as an n-D array of 1’s and 0’s.
Default is the ball of radius 1 according to the maximum norm
(i.e. a 3x3 square for 2D images, a 3x3x3 cube for 3D images, etc.)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>local_min</strong> : ndarray</p>
<blockquote class="last">
<div><p>All local minima of the image. The result image is a binary image,
where pixels belonging to local minima take value 1, the other pixels
take value 0.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.extrema.h_minima</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.extrema.h_maxima</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.extrema.local_maxima</span></code></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r387" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[R387]</a></td><td>Soille, P., “Morphological Image Analysis: Principles and
Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="k">import</span> <span class="n">extrema</span>
</pre></div>
</div>
<p>We create an image (quadratic function with a minimum in the center and
4 additional constant maxima.
The depth of the minima are: 1, 21, 41, 61, 81, 101</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">w</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">+</span> <span class="mf">0.2</span><span class="o">*</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">160</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">140</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
</pre></div>
</div>
<p>We can calculate all local minima:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minima</span> <span class="o">=</span> <span class="n">extrema</span><span class="o">.</span><span class="n">local_minima</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting image will contain all 6 local minima.</p>
</dd></dl>

</div>
<div class="section" id="medial-axis">
<h2>medial_axis<a class="headerlink" href="#medial-axis" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.medial_axis">
<code class="descclassname">skimage.morphology.</code><code class="descname">medial_axis</code><span class="sig-paren">(</span><em>image</em>, <em>mask=None</em>, <em>return_distance=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/_skeletonize.py#L291"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.medial_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the medial axis transform of a binary image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : binary ndarray, shape (M, N)</p>
<blockquote>
<div><p>The image of the shape to be skeletonized.</p>
</div></blockquote>
<p><strong>mask</strong> : binary ndarray, shape (M, N), optional</p>
<blockquote>
<div><p>If a mask is given, only those elements in <cite>image</cite> with a true
value in <cite>mask</cite> are used for computing the medial axis.</p>
</div></blockquote>
<p><strong>return_distance</strong> : bool, optional</p>
<blockquote>
<div><p>If true, the distance transform is returned as well as the skeleton.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray of bools</p>
<blockquote>
<div><p>Medial axis transform of the image</p>
</div></blockquote>
<p><strong>dist</strong> : ndarray of ints, optional</p>
<blockquote class="last">
<div><p>Distance transform of the image (only returned if <cite>return_distance</cite>
is True)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code class="xref py py-obj docutils literal"><span class="pre">skeletonize</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This algorithm computes the medial axis transform of an image
as the ridges of its distance transform.</p>
<dl class="docutils">
<dt>The different steps of the algorithm are as follows</dt>
<dd><ul class="first last simple">
<li>A lookup table is used, that assigns 0 or 1 to each configuration of
the 3x3 binary square, whether the central pixel should be removed
or kept. We want a point to be removed if it has more than one neighbor
and if removing it does not change the number of connected components.</li>
<li>The distance transform to the background is computed, as well as
the cornerness of the pixel.</li>
<li>The foreground (value of 1) points are ordered by
the distance transform, then the cornerness.</li>
<li>A cython function is called to reduce the image to its skeleton. It
processes pixels in the order determined at the previous step, and
removes or maintains a pixel according to the lookup table. Because
of the ordering, it is possible to process all pixels in only one
pass.</li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">medial_axis</span><span class="p">(</span><span class="n">square</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="octagon">
<h2>octagon<a class="headerlink" href="#octagon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.octagon">
<code class="descclassname">skimage.morphology.</code><code class="descname">octagon</code><span class="sig-paren">(</span><em>m</em>, <em>n</em>, <em>dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/selem.py#L252"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.octagon" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an octagon shaped structuring element.</p>
<p>For a given size of (m) horizontal and vertical sides
and a given (n) height or width of slanted sides octagon is generated.
The slanted sides are 45 or 135 degrees to the horizontal axis
and hence the widths and heights are equal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>m</strong> : int</p>
<blockquote>
<div><p>The size of the horizontal and vertical sides.</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p>The height or width of the slanted sides.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>selem</strong> : ndarray</p>
<blockquote>
<div><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><p class="first"><strong>dtype</strong> : data-type</p>
<blockquote class="last">
<div><p>The data type of the structuring element.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="octahedron">
<h2>octahedron<a class="headerlink" href="#octahedron" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.octahedron">
<code class="descclassname">skimage.morphology.</code><code class="descname">octahedron</code><span class="sig-paren">(</span><em>radius</em>, <em>dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/selem.py#L187"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.octahedron" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a octahedron-shaped structuring element.</p>
<p>This is the 3D equivalent of a diamond.
A pixel is part of the neighborhood (i.e. labeled 1) if
the city block/Manhattan distance between it and the center of
the neighborhood is no greater than radius.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>radius</strong> : int</p>
<blockquote>
<div><p>The radius of the octahedron-shaped structuring element.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>selem</strong> : ndarray</p>
<blockquote>
<div><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><p class="first"><strong>dtype</strong> : data-type</p>
<blockquote class="last">
<div><p>The data type of the structuring element.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="opening">
<h2>opening<a class="headerlink" href="#opening" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.opening">
<code class="descclassname">skimage.morphology.</code><code class="descname">opening</code><span class="sig-paren">(</span><em>image</em>, <em>selem=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/misc.py#L33"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.opening" title="Permalink to this definition">¶</a></dt>
<dd><p>Return greyscale morphological opening of an image.</p>
<p>The morphological opening on an image is defined as an erosion followed by
a dilation. Opening can remove small bright spots (i.e. “salt”) and connect
small dark cracks. This tends to “open” up (dark) gaps between (bright)
features.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Image array.</p>
</div></blockquote>
<p><strong>selem</strong> : ndarray, optional</p>
<blockquote>
<div><p>The neighborhood expressed as an array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</div></blockquote>
<p><strong>out</strong> : ndarray, optional</p>
<blockquote>
<div><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>opening</strong> : array, same shape and type as <cite>image</cite></p>
<blockquote class="last">
<div><p>The result of the morphological opening.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Open up gap between two bright regions (but also shrink regions)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="k">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bad_connection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opening</span><span class="p">(</span><span class="n">bad_connection</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 0, 1, 1],</span>
<span class="go">       [1, 1, 0, 1, 1],</span>
<span class="go">       [1, 1, 0, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="reconstruction">
<h2>reconstruction<a class="headerlink" href="#reconstruction" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.reconstruction">
<code class="descclassname">skimage.morphology.</code><code class="descname">reconstruction</code><span class="sig-paren">(</span><em>seed</em>, <em>mask</em>, <em>method='dilation'</em>, <em>selem=None</em>, <em>offset=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/greyreconstruct.py#L17"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.reconstruction" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a morphological reconstruction of an image.</p>
<p>Morphological reconstruction by dilation is similar to basic morphological
dilation: high-intensity values will replace nearby low-intensity values.
The basic dilation operator, however, uses a structuring element to
determine how far a value in the input image can spread. In contrast,
reconstruction uses two images: a “seed” image, which specifies the values
that spread, and a “mask” image, which gives the maximum allowed value at
each pixel. The mask image, like the structuring element, limits the spread
of high-intensity values. Reconstruction by erosion is simply the inverse:
low-intensity values spread from the seed image and are limited by the mask
image, which represents the minimum allowed value.</p>
<p>Alternatively, you can think of reconstruction as a way to isolate the
connected regions of an image. For dilation, reconstruction connects
regions marked by local maxima in the seed image: neighboring pixels
less-than-or-equal-to those seeds are connected to the seeded region.
Local maxima with values larger than the seed image will get truncated to
the seed value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seed</strong> : ndarray</p>
<blockquote>
<div><p>The seed image (a.k.a. marker image), which specifies the values that
are dilated or eroded.</p>
</div></blockquote>
<p><strong>mask</strong> : ndarray</p>
<blockquote>
<div><p>The maximum (dilation) / minimum (erosion) allowed value at each pixel.</p>
</div></blockquote>
<p><strong>method</strong> : {‘dilation’|’erosion’}</p>
<blockquote>
<div><p>Perform reconstruction by dilation or erosion. In dilation (or
erosion), the seed image is dilated (or eroded) until limited by the
mask image. For dilation, each seed value must be less than or equal
to the corresponding mask value; for erosion, the reverse is true.</p>
</div></blockquote>
<p><strong>selem</strong> : ndarray</p>
<blockquote>
<div><p>The neighborhood expressed as an n-D array of 1’s and 0’s.
Default is the ball of radius 1 according to the maximum norm
(i.e. a 3x3 square for 2D images, a 3x3x3 cube for 3D images, etc.)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>reconstructed</strong> : ndarray</p>
<blockquote class="last">
<div><p>The result of morphological reconstruction.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The algorithm is taken from <a class="reference internal" href="#r388" id="id8">[R388]</a>. Applications for greyscale reconstruction
are discussed in <a class="reference internal" href="#r389" id="id9">[R389]</a> and <a class="reference internal" href="#r390" id="id10">[R390]</a>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r388" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R388]</td><td><em>(<a class="fn-backref" href="#id8">1</a>, <a class="fn-backref" href="#id11">2</a>)</em> Robinson, “Efficient morphological reconstruction: a downhill
filter”, Pattern Recognition Letters 25 (2004) 1759-1767.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r389" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R389]</td><td><em>(<a class="fn-backref" href="#id9">1</a>, <a class="fn-backref" href="#id12">2</a>)</em> Vincent, L., “Morphological Grayscale Reconstruction in Image
Analysis: Applications and Efficient Algorithms”, IEEE Transactions
on Image Processing (1993)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r390" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R390]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id13">2</a>)</em> Soille, P., “Morphological Image Analysis: Principles and
Applications”, Chapter 6, 2nd edition (2003), ISBN 3540429883.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="k">import</span> <span class="n">reconstruction</span>
</pre></div>
</div>
<p>First, we create a sinusoidal mask image with peaks at middle and ends.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, we create a seed image initialized to the minimum mask value (for
reconstruction by dilation, min-intensity values don’t spread) and add
“seeds” to the left and right peak, but at a fraction of peak value (1).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_seed</span> <span class="o">=</span> <span class="n">y_mask</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_seed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_seed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_rec</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">y_seed</span><span class="p">,</span> <span class="n">y_mask</span><span class="p">)</span>
</pre></div>
</div>
<p>The reconstructed image (or curve, in this case) is exactly the same as the
mask image, except that the peaks are truncated to 0.5 and 0. The middle
peak disappears completely: Since there were no seed values in this peak
region, its reconstructed value is truncated to the surrounding value (-1).</p>
<p>As a more practical example, we try to extract the bright features of an
image by subtracting a background image created by reconstruction.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="mi">20</span><span class="p">:</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mf">0.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bumps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>To create the background image, set the mask image to the original image,
and the seed image to the original image with an intensity offset, <cite>h</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seed</span> <span class="o">=</span> <span class="n">bumps</span> <span class="o">-</span> <span class="n">h</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">bumps</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting reconstructed image looks exactly like the original image,
but with the peaks of the bumps cut off. Subtracting this reconstructed
image from the original image leaves just the peaks of the bumps</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdome</span> <span class="o">=</span> <span class="n">bumps</span> <span class="o">-</span> <span class="n">background</span>
</pre></div>
</div>
<p>This operation is known as the h-dome of the image and leaves features
of height <cite>h</cite> in the subtracted image.</p>
</dd></dl>

</div>
<div class="section" id="rectangle">
<h2>rectangle<a class="headerlink" href="#rectangle" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.rectangle">
<code class="descclassname">skimage.morphology.</code><code class="descname">rectangle</code><span class="sig-paren">(</span><em>width</em>, <em>height</em>, <em>dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/selem.py#L32"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a flat, rectangular-shaped structuring element.</p>
<p>Every pixel in the rectangle generated for a given width and given height
belongs to the neighborhood.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>width</strong> : int</p>
<blockquote>
<div><p>The width of the rectangle.</p>
</div></blockquote>
<p><strong>height</strong> : int</p>
<blockquote>
<div><p>The height of the rectangle.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>selem</strong> : ndarray</p>
<blockquote>
<div><p>A structuring element consisting only of ones, i.e. every
pixel belongs to the neighborhood.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><p class="first"><strong>dtype</strong> : data-type</p>
<blockquote class="last">
<div><p>The data type of the structuring element.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="remove-small-holes">
<h2>remove_small_holes<a class="headerlink" href="#remove-small-holes" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.remove_small_holes">
<code class="descclassname">skimage.morphology.</code><code class="descname">remove_small_holes</code><span class="sig-paren">(</span><em>ar</em>, <em>min_size=64</em>, <em>connectivity=1</em>, <em>in_place=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/misc.py#L131"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.remove_small_holes" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove continguous holes smaller than the specified size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ar</strong> : ndarray (arbitrary shape, int or bool type)</p>
<blockquote>
<div><p>The array containing the connected components of interest.</p>
</div></blockquote>
<p><strong>min_size</strong> : int, optional (default: 64)</p>
<blockquote>
<div><p>The hole component size.</p>
</div></blockquote>
<p><strong>connectivity</strong> : int, {1, 2, …, ar.ndim}, optional (default: 1)</p>
<blockquote>
<div><p>The connectivity defining the neighborhood of a pixel.</p>
</div></blockquote>
<p><strong>in_place</strong> : bool, optional (default: False)</p>
<blockquote>
<div><p>If <cite>True</cite>, remove the connected components in the input array itself.
Otherwise, make a copy.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray, same shape and type as input <cite>ar</cite></p>
<blockquote>
<div><p>The input array with small holes within connected components removed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError</strong></p>
<blockquote>
<div><p>If the input array is of an invalid type, such as float or string.</p>
</div></blockquote>
<p><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>If the input array contains negative values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If the array type is int, it is assumed that it contains already-labeled
objects. The labels are not kept in the output image (this function always
outputs a bool image). It is suggested that labeling is completed after
using this function.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="k">import</span> <span class="n">morphology</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_holes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[ True,  True,  True,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True, False],</span>
<span class="go">       [ True, False, False,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True, False]], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_holes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[ True,  True,  True,  True,  True, False],</span>
<span class="go">       [ True,  True,  True, False,  True, False],</span>
<span class="go">       [ True, False, False,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True, False]], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_holes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="remove-small-objects">
<h2>remove_small_objects<a class="headerlink" href="#remove-small-objects" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.remove_small_objects">
<code class="descclassname">skimage.morphology.</code><code class="descname">remove_small_objects</code><span class="sig-paren">(</span><em>ar</em>, <em>min_size=64</em>, <em>connectivity=1</em>, <em>in_place=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/misc.py#L47"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.remove_small_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove connected components smaller than the specified size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ar</strong> : ndarray (arbitrary shape, int or bool type)</p>
<blockquote>
<div><p>The array containing the connected components of interest. If the array
type is int, it is assumed that it contains already-labeled objects.
The ints must be non-negative.</p>
</div></blockquote>
<p><strong>min_size</strong> : int, optional (default: 64)</p>
<blockquote>
<div><p>The smallest allowable connected component size.</p>
</div></blockquote>
<p><strong>connectivity</strong> : int, {1, 2, …, ar.ndim}, optional (default: 1)</p>
<blockquote>
<div><p>The connectivity defining the neighborhood of a pixel.</p>
</div></blockquote>
<p><strong>in_place</strong> : bool, optional (default: False)</p>
<blockquote>
<div><p>If <cite>True</cite>, remove the connected components in the input array itself.
Otherwise, make a copy.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray, same shape and type as input <cite>ar</cite></p>
<blockquote>
<div><p>The input array with small connected components removed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError</strong></p>
<blockquote>
<div><p>If the input array is of an invalid type, such as float or string.</p>
</div></blockquote>
<p><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>If the input array contains negative values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="k">import</span> <span class="n">morphology</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[False, False, False, False, False],</span>
<span class="go">       [ True,  True,  True, False, False],</span>
<span class="go">       [ True,  True,  True, False, False]], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[False, False, False,  True, False],</span>
<span class="go">       [ True,  True,  True, False, False],</span>
<span class="go">       [ True,  True,  True, False, False]], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="skeletonize">
<h2>skeletonize<a class="headerlink" href="#skeletonize" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.skeletonize">
<code class="descclassname">skimage.morphology.</code><code class="descname">skeletonize</code><span class="sig-paren">(</span><em>image</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/_skeletonize.py#L19"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.skeletonize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the skeleton of a binary image.</p>
<p>Thinning is used to reduce each connected component in a binary image
to a single-pixel wide skeleton.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : numpy.ndarray</p>
<blockquote>
<div><p>A binary image containing the objects to be skeletonized. ‘1’
represents foreground, and ‘0’ represents background. It
also accepts arrays of boolean values where True is foreground.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>skeleton</strong> : ndarray</p>
<blockquote class="last">
<div><p>A matrix containing the thinned image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code class="xref py py-obj docutils literal"><span class="pre">medial_axis</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The algorithm <a class="reference internal" href="../auto_examples/edges/plot_skeleton.html#zha84" id="id14">[Zha84]</a> works by making successive passes of the image,
removing pixels on object borders. This continues until no
more pixels can be removed.  The image is correlated with a
mask that assigns each pixel a number in the range [0…255]
corresponding to each possible pattern of its 8 neighbouring
pixels. A look up table is then used to assign the pixels a
value of 0, 1, 2 or 3, which are selectively removed during
the iterations.</p>
<p>Note that this algorithm will give different results than a
medial axis transform, which is also often referred to as
“skeletonization”.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="zha84" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Zha84]</td><td><em>(<a class="fn-backref" href="#id14">1</a>, <a class="fn-backref" href="#id15">2</a>)</em> A fast parallel algorithm for thinning digital patterns,
T. Y. Zhang and C. Y. Suen, Communications of the ACM,
March 1984, Volume 27, Number 3.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ellipse</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ellipse</span>
<span class="go">array([[0, 0, 0, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span> <span class="o">=</span> <span class="n">skeletonize</span><span class="p">(</span><span class="n">ellipse</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="skeletonize-3d">
<h2>skeletonize_3d<a class="headerlink" href="#skeletonize-3d" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.skeletonize_3d">
<code class="descclassname">skimage.morphology.</code><code class="descname">skeletonize_3d</code><span class="sig-paren">(</span><em>img</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/_skeletonize_3d.py#L8"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.skeletonize_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the skeleton of a binary image.</p>
<p>Thinning is used to reduce each connected component in a binary image
to a single-pixel wide skeleton.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>img</strong> : ndarray, 2D or 3D</p>
<blockquote>
<div><p>A binary image containing the objects to be skeletonized. Zeros
represent background, nonzero values are foreground.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>skeleton</strong> : ndarray</p>
<blockquote class="last">
<div><p>The thinned image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code class="xref py py-obj docutils literal"><span class="pre">skeletonize</span></code></a>, <a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code class="xref py py-obj docutils literal"><span class="pre">medial_axis</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The method of <a class="reference internal" href="../auto_examples/edges/plot_skeleton.html#lee94" id="id16">[Lee94]</a> uses an octree data structure to examine a 3x3x3
neighborhood of a pixel. The algorithm proceeds by iteratively sweeping
over the image, and removing pixels at each iteration until the image
stops changing. Each iteration consists of two steps: first, a list of
candidates for removal is assembled; then pixels from this list are
rechecked sequentially, to better preserve connectivity of the image.</p>
<p>The algorithm this function implements is different from the algorithms
used by either <cite>skeletonize</cite> or <cite>medial_axis</cite>, thus for 2D images the
results produced by this function are generally different.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="lee94" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Lee94]</td><td><em>(<a class="fn-backref" href="#id16">1</a>, <a class="fn-backref" href="#id17">2</a>)</em> T.-C. Lee, R.L. Kashyap and C.-N. Chu, Building skeleton models
via 3-D medial surface/axis thinning algorithms.
Computer Vision, Graphics, and Image Processing, 56(6):462-478, 1994.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="square">
<h2>square<a class="headerlink" href="#square" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.square">
<code class="descclassname">skimage.morphology.</code><code class="descname">square</code><span class="sig-paren">(</span><em>width</em>, <em>dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/selem.py#L6"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.square" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a flat, square-shaped structuring element.</p>
<p>Every pixel along the perimeter has a chessboard distance
no greater than radius (radius=floor(width/2)) pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>width</strong> : int</p>
<blockquote>
<div><p>The width and height of the square.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>selem</strong> : ndarray</p>
<blockquote>
<div><p>A structuring element consisting only of ones, i.e. every
pixel belongs to the neighborhood.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><p class="first"><strong>dtype</strong> : data-type</p>
<blockquote class="last">
<div><p>The data type of the structuring element.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="star">
<h2>star<a class="headerlink" href="#star" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.star">
<code class="descclassname">skimage.morphology.</code><code class="descname">star</code><span class="sig-paren">(</span><em>a</em>, <em>dtype=&lt;class 'numpy.uint8'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/selem.py#L293"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.star" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a star shaped structuring element.</p>
<p>Start has 8 vertices and is an overlap of square of size <cite>2*a + 1</cite>
with its 45 degree rotated version.
The slanted sides are 45 or 135 degrees to the horizontal axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : int</p>
<blockquote>
<div><p>Parameter deciding the size of the star structural element. The side
of the square array returned is <cite>2*a + 1 + 2*floor(a / 2)</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>selem</strong> : ndarray</p>
<blockquote>
<div><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><p class="first"><strong>dtype</strong> : data-type</p>
<blockquote class="last">
<div><p>The data type of the structuring element.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="thin">
<h2>thin<a class="headerlink" href="#thin" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.thin">
<code class="descclassname">skimage.morphology.</code><code class="descname">thin</code><span class="sig-paren">(</span><em>image</em>, <em>max_iter=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/_skeletonize.py#L185"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.thin" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform morphological thinning of a binary image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : binary (M, N) ndarray</p>
<blockquote>
<div><p>The image to be thinned.</p>
</div></blockquote>
<p><strong>max_iter</strong> : int, number of iterations, optional</p>
<blockquote>
<div><p>Regardless of the value of this parameter, the thinned image
is returned immediately if an iteration produces no change.
If this parameter is specified it thus sets an upper bound on
the number of iterations performed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray of bool</p>
<blockquote class="last">
<div><p>Thinned image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code class="xref py py-obj docutils literal"><span class="pre">skeletonize</span></code></a>, <a class="reference internal" href="#skimage.morphology.skeletonize_3d" title="skimage.morphology.skeletonize_3d"><code class="xref py py-obj docutils literal"><span class="pre">skeletonize_3d</span></code></a>, <a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code class="xref py py-obj docutils literal"><span class="pre">medial_axis</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This algorithm <a class="reference internal" href="#r391" id="id18">[R391]</a> works by making multiple passes over the image,
removing pixels matching a set of criteria designed to thin
connected regions while preserving eight-connected components and
2 x 2 squares <a class="reference internal" href="#r392" id="id19">[R392]</a>. In each of the two sub-iterations the algorithm
correlates the intermediate skeleton image with a neighborhood mask,
then looks up each neighborhood in a lookup table indicating whether
the central pixel should be deleted in that sub-iteration.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r391" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R391]</td><td><em>(<a class="fn-backref" href="#id18">1</a>, <a class="fn-backref" href="#id20">2</a>)</em> Z. Guo and R. W. Hall, “Parallel thinning with
two-subiteration algorithms,” Comm. ACM, vol. 32, no. 3,
pp. 359-373, 1989. DOI:10.1145/62065.62074</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r392" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R392]</td><td><em>(<a class="fn-backref" href="#id19">1</a>, <a class="fn-backref" href="#id21">2</a>)</em> Lam, L., Seong-Whan Lee, and Ching Y. Suen, “Thinning
Methodologies-A Comprehensive Survey,” IEEE Transactions on
Pattern Analysis and Machine Intelligence, Vol 14, No. 9,
p. 879, 1992. DOI:10.1109/34.161346</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span>
<span class="go">array([[0, 1, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span> <span class="o">=</span> <span class="n">thin</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 1, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="watershed">
<h2>watershed<a class="headerlink" href="#watershed" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.watershed">
<code class="descclassname">skimage.morphology.</code><code class="descname">watershed</code><span class="sig-paren">(</span><em>image</em>, <em>markers</em>, <em>connectivity=1</em>, <em>offset=None</em>, <em>mask=None</em>, <em>compactness=0</em>, <em>watershed_line=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/watershed.py#L134"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.watershed" title="Permalink to this definition">¶</a></dt>
<dd><p>Find watershed basins in <cite>image</cite> flooded from given <cite>markers</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image: ndarray (2-D, 3-D, …) of integers</strong></p>
<blockquote>
<div><p>Data array where the lowest value points are labeled first.</p>
</div></blockquote>
<p><strong>markers: int, or ndarray of int, same shape as `image`</strong></p>
<blockquote>
<div><p>The desired number of markers, or an array marking the basins with the
values to be assigned in the label matrix. Zero means not a marker.</p>
</div></blockquote>
<p><strong>connectivity: ndarray, optional</strong></p>
<blockquote>
<div><p>An array with the same number of dimensions as <cite>image</cite> whose
non-zero elements indicate neighbors for connection.
Following the scipy convention, default is a one-connected array of
the dimension of the image.</p>
</div></blockquote>
<p><strong>offset: array_like of shape image.ndim, optional</strong></p>
<blockquote>
<div><p>offset of the connectivity (one offset per dimension)</p>
</div></blockquote>
<p><strong>mask: ndarray of bools or 0s and 1s, optional</strong></p>
<blockquote>
<div><p>Array of same shape as <cite>image</cite>. Only points at which mask == True
will be labeled.</p>
</div></blockquote>
<p><strong>compactness</strong> : float, optional</p>
<blockquote>
<div><p>Use compact watershed <a class="reference internal" href="#r395" id="id22">[R395]</a> with given compactness parameter.
Higher values result in more regularly-shaped watershed basins.</p>
</div></blockquote>
<p><strong>watershed_line</strong> : bool, optional</p>
<blockquote>
<div><p>If watershed_line is True, a one-pixel wide line separates the regions
obtained by the watershed algorithm. The line has the label 0.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">out: ndarray</p>
<blockquote class="last">
<div><p>A labeled matrix of the same type and shape as markers</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="skimage.segmentation.html#skimage.segmentation.random_walker" title="skimage.segmentation.random_walker"><code class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.random_walker</span></code></a></dt>
<dd>random walker segmentation A segmentation algorithm based on anisotropic diffusion, usually slower than the watershed but with good results on noisy data and boundaries with holes.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function implements a watershed algorithm <a class="reference internal" href="#r393" id="id23">[R393]</a> <a class="reference internal" href="#r394" id="id24">[R394]</a> that apportions
pixels into marked basins. The algorithm uses a priority queue to hold
the pixels with the metric for the priority queue being pixel value, then
the time of entry into the queue - this settles ties in favor of the
closest marker.</p>
<p>Some ideas taken from
Soille, “Automated Basin Delineation from Digital Elevation Models Using
Mathematical Morphology”, Signal Processing 20 (1990) 171-182</p>
<p>The most important insight in the paper is that entry time onto the queue
solves two problems: a pixel should be assigned to the neighbor with the
largest gradient or, if there is no gradient, pixels on a plateau should
be split between markers on opposite sides.</p>
<p>This implementation converts all arguments to specific, lowest common
denominator types, then passes these to a C algorithm.</p>
<p>Markers can be determined manually, or automatically using for example
the local minima of the gradient of the image, or the local maxima of the
distance function to the background for separating overlapping objects
(see example).</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r393" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R393]</td><td><em>(<a class="fn-backref" href="#id23">1</a>, <a class="fn-backref" href="#id25">2</a>)</em> <a class="reference external" href="http://en.wikipedia.org/wiki/Watershed_%28image_processing%29">http://en.wikipedia.org/wiki/Watershed_%28image_processing%29</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r394" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R394]</td><td><em>(<a class="fn-backref" href="#id24">1</a>, <a class="fn-backref" href="#id26">2</a>)</em> <a class="reference external" href="http://cmm.ensmp.fr/~beucher/wtshed.html">http://cmm.ensmp.fr/~beucher/wtshed.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r395" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R395]</td><td><em>(<a class="fn-backref" href="#id22">1</a>, <a class="fn-backref" href="#id27">2</a>)</em> Peer Neubert &amp; Peter Protzel (2014). Compact Watershed and
Preemptive SLIC: On Improving Trade-offs of Superpixel Segmentation
Algorithms. ICPR 2014, pp 996-1001. DOI:10.1109/ICPR.2014.181
https://www.tu-chemnitz.de/etit/proaut/forschung/rsrc/cws_pSLIC_ICPR.pdf</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>The watershed algorithm is useful to separate overlapping objects.</p>
<p>We first generate an initial image with two overlapping circles:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">((</span><span class="mi">80</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">52</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask_circle1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">r1</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask_circle2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">r2</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask_circle1</span><span class="p">,</span> <span class="n">mask_circle2</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we want to separate the two circles. We generate markers at the
maxima of the distance to the background:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span> <span class="k">as</span> <span class="n">ndi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distance</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="k">import</span> <span class="n">peak_local_max</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">local_maxi</span> <span class="o">=</span> <span class="n">peak_local_max</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">footprint</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
<span class="gp">... </span>                            <span class="n">indices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">markers</span> <span class="o">=</span> <span class="n">ndi</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">local_maxi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Finally, we run the watershed on the image and markers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">watershed</span><span class="p">(</span><span class="o">-</span><span class="n">distance</span><span class="p">,</span> <span class="n">markers</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p>The algorithm works also for 3-D images, and can be used for example to
separate overlapping spheres.</p>
</dd></dl>

</div>
<div class="section" id="white-tophat">
<h2>white_tophat<a class="headerlink" href="#white-tophat" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.morphology.white_tophat">
<code class="descclassname">skimage.morphology.</code><code class="descname">white_tophat</code><span class="sig-paren">(</span><em>image</em>, <em>selem=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/morphology/misc.py#L33"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.morphology.white_tophat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return white top hat of an image.</p>
<p>The white top hat of an image is defined as the image minus its
morphological opening. This operation returns the bright spots of the image
that are smaller than the structuring element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Image array.</p>
</div></blockquote>
<p><strong>selem</strong> : ndarray, optional</p>
<blockquote>
<div><p>The neighborhood expressed as an array of 1’s and 0’s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</div></blockquote>
<p><strong>out</strong> : ndarray, optional</p>
<blockquote>
<div><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : array, same shape and type as <cite>image</cite></p>
<blockquote class="last">
<div><p>The result of the morphological white top hat.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Subtract grey background from bright peak</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="k">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bright_on_grey</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">white_tophat</span><span class="p">(</span><span class="n">bright_on_grey</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 1, 5, 1, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


        </div>
    </div>
    <div class="well footer">
        <small>
            &copy; Copyright the scikit-image development team.
            Created using <a href="http://getbootstrap.com/">Bootstrap</a> and <a href="http://sphinx-doc.org/">Sphinx</a>.
        </small>
    </div>
</body>
</html>


<!-- Piwik -->
<script type="text/javascript">
  var _paq = _paq || [];
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//piwik.sciunto.org/piwik/";
    _paq.push(['setTrackerUrl', u+'piwik.php']);
    _paq.push(['setSiteId', 2]);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<noscript><p><img src="//piwik.sciunto.org/piwik/piwik.php?idsite=2" style="border:0;" alt="" /></p></noscript>
<!-- End Piwik Code -->