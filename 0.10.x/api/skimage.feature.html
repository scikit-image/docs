


<!DOCTYPE html>
<html lang="en">
<head>
        <title>Module: feature &mdash; skimage v0.10.0 docs</title>
    
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../_static/css/custom.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
    
    <script src="http://code.jquery.com/jquery-latest.js"></script>
    <script src="../_static/js/bootstrap.min.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.10.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <link rel="top" title="skimage v0.10.0 docs" href="../index.html" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="shortcut icon" href="../_static/favicon.ico">
</head>
<body class="container">
    <a href="http://scikit-image.org" class="logo"><img src="../_static/img/logo.png" alt=""></a>
    <div class="clearfix"></div>
    <div class="navbar">
        <div class="navbar-inner">
            <ul class="nav">
                <li><a href="/">Home</a></li>
<li><a href="/docs/stable/install.html">Download</a></li>
<li><a href="/docs/dev/auto_examples">Gallery</a></li>
<li><a href="/docs/dev">Documentation</a></li>
<li><a href="https://github.com/scikit-image/scikit-image">Source</a></li>
            </ul>
            <form class="navbar-form pull-right" action="../search.html" method="get">
                <input type="text" class="search span3" name="q" placeholder="Search documentation ...">
                <input type="hidden" name="check_keywords" value="yes" >
                <input type="hidden" name="area" value="default" >
            </form>
        </div>
    </div>
    <div class="row">
        <div class="span9">
            
  <div class="section" id="module-skimage.feature">
<span id="module-feature"></span><h1>Module: <tt class="xref py py-mod docutils literal"><span class="pre">feature</span></tt><a class="headerlink" href="#module-skimage.feature" title="Permalink to this headline">¶</a></h1>
<div class="section" id="brief">
<h2><a class="reference internal" href="#skimage.feature.BRIEF" title="skimage.feature.BRIEF"><tt class="xref py py-class docutils literal"><span class="pre">BRIEF</span></tt></a><a class="headerlink" href="#brief" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.feature.BRIEF">
<em class="property">class </em><tt class="descclassname">skimage.feature.</tt><tt class="descname">BRIEF</tt><big>(</big><em>descriptor_size=256</em>, <em>patch_size=49</em>, <em>mode='normal'</em>, <em>sigma=1</em>, <em>sample_seed=1</em><big>)</big><a class="headerlink" href="#skimage.feature.BRIEF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.feature.util.DescriptorExtractor</span></tt></p>
<p>BRIEF binary descriptor extractor.</p>
<p>BRIEF (Binary Robust Independent Elementary Features) is an efficient
feature point descriptor. It is highly discriminative even when using
relatively few bits and is computed using simple intensity difference
tests.</p>
<p>For each keypoint, intensity comparisons are carried out for a specifically
distributed number N of pixel-pairs resulting in a binary descriptor of
length N. For binary descriptors the Hamming distance can be used for
feature matching, which leads to lower computational cost in comparison to
the L2 norm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>descriptor_size</strong> : int, optional</p>
<blockquote>
<div><p>Size of BRIEF descriptor for each keypoint. Sizes 128, 256 and 512
recommended by the authors. Default is 256.</p>
</div></blockquote>
<p><strong>patch_size</strong> : int, optional</p>
<blockquote>
<div><p>Length of the two dimensional square patch sampling region around
the keypoints. Default is 49.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;normal&#8217;, &#8216;uniform&#8217;}, optional</p>
<blockquote>
<div><p>Probability distribution for sampling location of decision pixel-pairs
around keypoints.</p>
</div></blockquote>
<p><strong>sample_seed</strong> : int, optional</p>
<blockquote>
<div><p>Seed for the random sampling of the decision pixel-pairs. From a square
window with length <cite>patch_size</cite>, pixel pairs are sampled using the
<cite>mode</cite> parameter to build the descriptors using intensity comparison.
The value of <cite>sample_seed</cite> must be the same for the images to be
matched while building the descriptors.</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote class="last">
<div><p>Standard deviation of the Gaussian low-pass filter applied to the image
to alleviate noise sensitivity, which is strongly recommended to obtain
discriminative and good descriptors.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="p">(</span><span class="n">corner_harris</span><span class="p">,</span> <span class="n">corner_peaks</span><span class="p">,</span> <span class="n">BRIEF</span><span class="p">,</span>
<span class="gp">... </span>                             <span class="n">match_descriptors</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square1</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square1</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0]], dtype=int32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square2</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square2</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=int32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keypoints1</span> <span class="o">=</span> <span class="n">corner_peaks</span><span class="p">(</span><span class="n">corner_harris</span><span class="p">(</span><span class="n">square1</span><span class="p">),</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keypoints2</span> <span class="o">=</span> <span class="n">corner_peaks</span><span class="p">(</span><span class="n">corner_harris</span><span class="p">(</span><span class="n">square2</span><span class="p">),</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extractor</span> <span class="o">=</span> <span class="n">BRIEF</span><span class="p">(</span><span class="n">patch_size</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extractor</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">square1</span><span class="p">,</span> <span class="n">keypoints1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">descriptors1</span> <span class="o">=</span> <span class="n">extractor</span><span class="o">.</span><span class="n">descriptors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extractor</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">square2</span><span class="p">,</span> <span class="n">keypoints2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">descriptors2</span> <span class="o">=</span> <span class="n">extractor</span><span class="o">.</span><span class="n">descriptors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matches</span> <span class="o">=</span> <span class="n">match_descriptors</span><span class="p">(</span><span class="n">descriptors1</span><span class="p">,</span> <span class="n">descriptors2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matches</span>
<span class="go">array([[0, 0],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [2, 2],</span>
<span class="go">       [3, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keypoints1</span><span class="p">[</span><span class="n">matches</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 5],</span>
<span class="go">       [5, 2],</span>
<span class="go">       [5, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keypoints2</span><span class="p">[</span><span class="n">matches</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 6],</span>
<span class="go">       [6, 2],</span>
<span class="go">       [6, 6]])</span>
</pre></div>
</div>
<p class="rubric">Attributes</p>
<dl class="method">
<dt id="skimage.feature.BRIEF.__init__">
<tt class="descname">__init__</tt><big>(</big><em>descriptor_size=256</em>, <em>patch_size=49</em>, <em>mode='normal'</em>, <em>sigma=1</em>, <em>sample_seed=1</em><big>)</big><a class="headerlink" href="#skimage.feature.BRIEF.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.feature.BRIEF.extract">
<tt class="descname">extract</tt><big>(</big><em>image</em>, <em>keypoints</em><big>)</big><a class="headerlink" href="#skimage.feature.BRIEF.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract BRIEF binary descriptors for given keypoints in image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2D array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>keypoints</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>Keypoint coordinates as <tt class="docutils literal"><span class="pre">(row,</span> <span class="pre">col)</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="censure">
<h2><a class="reference internal" href="#skimage.feature.CENSURE" title="skimage.feature.CENSURE"><tt class="xref py py-class docutils literal"><span class="pre">CENSURE</span></tt></a><a class="headerlink" href="#censure" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.feature.CENSURE">
<em class="property">class </em><tt class="descclassname">skimage.feature.</tt><tt class="descname">CENSURE</tt><big>(</big><em>min_scale=1</em>, <em>max_scale=7</em>, <em>mode='DoB'</em>, <em>non_max_threshold=0.15</em>, <em>line_threshold=10</em><big>)</big><a class="headerlink" href="#skimage.feature.CENSURE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.feature.util.FeatureDetector</span></tt></p>
<p>CENSURE keypoint detector.</p>
<dl class="docutils">
<dt>min_scale <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Minimum scale to extract keypoints from.</dd>
<dt>max_scale <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Maximum scale to extract keypoints from. The keypoints will be
extracted from all the scales except the first and the last i.e.
from the scales in the range [min_scale + 1, max_scale - 1]. The filter
sizes for different scales is such that the two adjacent scales
comprise of an octave.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">{&#8216;DoB&#8217;, &#8216;Octagon&#8217;, &#8216;STAR&#8217;}, optional</span></dt>
<dd>Type of bi-level filter used to get the scales of the input image.
Possible values are &#8216;DoB&#8217;, &#8216;Octagon&#8217; and &#8216;STAR&#8217;. The three modes
represent the shape of the bi-level filters i.e. box(square), octagon
and star respectively. For instance, a bi-level octagon filter consists
of a smaller inner octagon and a larger outer octagon with the filter
weights being uniformly negative in both the inner octagon while
uniformly positive in the difference region. Use STAR and Octagon for
better features and DoB for better performance.</dd>
<dt>non_max_threshold <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd>Threshold value used to suppress maximas and minimas with a weak
magnitude response obtained after Non-Maximal Suppression.</dd>
<dt>line_threshold <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd>Threshold for rejecting interest points which have ratio of principal
curvatures greater than this value.</dd>
</dl>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r89" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[R89]</a></td><td>Motilal Agrawal, Kurt Konolige and Morten Rufus Blas
&#8220;CENSURE: Center Surround Extremas for Realtime Feature
Detection and Matching&#8221;,
<a class="reference external" href="http://link.springer.com/content/pdf/10.1007%2F978-3-540-88693-8_8.pdf">http://link.springer.com/content/pdf/10.1007%2F978-3-540-88693-8_8.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r90" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[R90]</a></td><td>Adam Schmidt, Marek Kraft, Michal Fularz and Zuzanna Domagala
&#8220;Comparative Assessment of Point Feature Detectors and
Descriptors in the Context of Robot Navigation&#8221;
<a class="reference external" href="http://www.jamris.org/01_2013/saveas.php?QUEST=JAMRIS_No01_2013_P_11-20.pdf">http://www.jamris.org/01_2013/saveas.php?QUEST=JAMRIS_No01_2013_P_11-20.pdf</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">lena</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.color</span> <span class="kn">import</span> <span class="n">rgb2gray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">CENSURE</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">rgb2gray</span><span class="p">(</span><span class="n">lena</span><span class="p">()[</span><span class="mi">100</span><span class="p">:</span><span class="mi">300</span><span class="p">,</span> <span class="mi">100</span><span class="p">:</span><span class="mi">300</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">censure</span> <span class="o">=</span> <span class="n">CENSURE</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">censure</span><span class="o">.</span><span class="n">detect</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">censure</span><span class="o">.</span><span class="n">keypoints</span>
<span class="go">array([[ 71, 148],</span>
<span class="go">       [ 77, 186],</span>
<span class="go">       [ 78, 189],</span>
<span class="go">       [ 89, 174],</span>
<span class="go">       [127, 134],</span>
<span class="go">       [131, 133],</span>
<span class="go">       [134, 125],</span>
<span class="go">       [137, 125],</span>
<span class="go">       [149,  36],</span>
<span class="go">       [162, 165],</span>
<span class="go">       [168, 167],</span>
<span class="go">       [170,   5],</span>
<span class="go">       [171,  29],</span>
<span class="go">       [179,  20],</span>
<span class="go">       [194,  65]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">censure</span><span class="o">.</span><span class="n">scales</span>
<span class="go">array([2, 4, 2, 3, 4, 2, 2, 3, 4, 6, 3, 2, 3, 4, 2])</span>
</pre></div>
</div>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="20%" />
<col width="65%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>keypoints</td>
<td>(N, 2) array</td>
<td>Keypoint coordinates as <tt class="docutils literal"><span class="pre">(row,</span> <span class="pre">col)</span></tt>.</td>
</tr>
<tr class="row-even"><td>scales</td>
<td>(N, ) array</td>
<td>Corresponding scales.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.feature.CENSURE.__init__">
<tt class="descname">__init__</tt><big>(</big><em>min_scale=1</em>, <em>max_scale=7</em>, <em>mode='DoB'</em>, <em>non_max_threshold=0.15</em>, <em>line_threshold=10</em><big>)</big><a class="headerlink" href="#skimage.feature.CENSURE.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.feature.CENSURE.detect">
<tt class="descname">detect</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#skimage.feature.CENSURE.detect" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect CENSURE keypoints along with the corresponding scale.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2D ndarray</p>
<blockquote class="last">
<div><p>Input image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="orb">
<h2><a class="reference internal" href="#skimage.feature.ORB" title="skimage.feature.ORB"><tt class="xref py py-class docutils literal"><span class="pre">ORB</span></tt></a><a class="headerlink" href="#orb" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.feature.ORB">
<em class="property">class </em><tt class="descclassname">skimage.feature.</tt><tt class="descname">ORB</tt><big>(</big><em>downscale=1.2</em>, <em>n_scales=8</em>, <em>n_keypoints=500</em>, <em>fast_n=9</em>, <em>fast_threshold=0.08</em>, <em>harris_k=0.04</em><big>)</big><a class="headerlink" href="#skimage.feature.ORB" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.feature.util.FeatureDetector</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">skimage.feature.util.DescriptorExtractor</span></tt></p>
<p>Oriented FAST and rotated BRIEF feature detector and binary descriptor
extractor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n_keypoints</strong> : int, optional</p>
<blockquote>
<div><p>Number of keypoints to be returned. The function will return the best
<cite>n_keypoints</cite> according to the Harris corner response if more than
<cite>n_keypoints</cite> are detected. If not, then all the detected keypoints
are returned.</p>
</div></blockquote>
<p><strong>fast_n</strong> : int, optional</p>
<blockquote>
<div><p>The <cite>n</cite> parameter in <cite>skimage.feature.corner_fast</cite>. Minimum number of
consecutive pixels out of 16 pixels on the circle that should all be
either brighter or darker w.r.t test-pixel. A point c on the circle is
darker w.r.t test pixel p if <tt class="docutils literal"><span class="pre">Ic</span> <span class="pre">&lt;</span> <span class="pre">Ip</span> <span class="pre">-</span> <span class="pre">threshold</span></tt> and brighter if
<tt class="docutils literal"><span class="pre">Ic</span> <span class="pre">&gt;</span> <span class="pre">Ip</span> <span class="pre">+</span> <span class="pre">threshold</span></tt>. Also stands for the n in <tt class="docutils literal"><span class="pre">FAST-n</span></tt> corner
detector.</p>
</div></blockquote>
<p><strong>fast_threshold</strong> : float, optional</p>
<blockquote>
<div><p>The <tt class="docutils literal"><span class="pre">threshold</span></tt> parameter in <tt class="docutils literal"><span class="pre">feature.corner_fast</span></tt>. Threshold used
to decide whether the pixels on the circle are brighter, darker or
similar w.r.t. the test pixel. Decrease the threshold when more
corners are desired and vice-versa.</p>
</div></blockquote>
<p><strong>harris_k</strong> : float, optional</p>
<blockquote>
<div><p>The <cite>k</cite> parameter in <cite>skimage.feature.corner_harris</cite>. Sensitivity
factor to separate corners from edges, typically in range <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">0.2]</span></tt>.
Small values of <cite>k</cite> result in detection of sharp corners.</p>
</div></blockquote>
<p><strong>downscale</strong> : float, optional</p>
<blockquote>
<div><p>Downscale factor for the image pyramid. Default value 1.2 is chosen so
that there are more dense scales which enable robust scale invariance
for a subsequent feature description.</p>
</div></blockquote>
<p><strong>n_scales</strong> : int, optional</p>
<blockquote class="last">
<div><p>Maximum number of scales from the bottom of the image pyramid to
extract the features from.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r91" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[R91]</a></td><td>Ethan Rublee, Vincent Rabaud, Kurt Konolige and Gary Bradski
&#8220;ORB: An efficient alternative to SIFT and SURF&#8221;
<a class="reference external" href="http://www.vision.cs.chubu.ac.jp/CV-R/pdf/Rublee_iccv2011.pdf">http://www.vision.cs.chubu.ac.jp/CV-R/pdf/Rublee_iccv2011.pdf</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">ORB</span><span class="p">,</span> <span class="n">match_descriptors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img1</span><span class="p">[</span><span class="mi">40</span><span class="p">:</span><span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">:</span><span class="mi">60</span><span class="p">]</span> <span class="o">=</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img2</span><span class="p">[</span><span class="mi">53</span><span class="p">:</span><span class="mi">73</span><span class="p">,</span> <span class="mi">53</span><span class="p">:</span><span class="mi">73</span><span class="p">]</span> <span class="o">=</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">detector_extractor1</span> <span class="o">=</span> <span class="n">ORB</span><span class="p">(</span><span class="n">n_keypoints</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">detector_extractor2</span> <span class="o">=</span> <span class="n">ORB</span><span class="p">(</span><span class="n">n_keypoints</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">detector_extractor1</span><span class="o">.</span><span class="n">detect_and_extract</span><span class="p">(</span><span class="n">img1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">detector_extractor2</span><span class="o">.</span><span class="n">detect_and_extract</span><span class="p">(</span><span class="n">img2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matches</span> <span class="o">=</span> <span class="n">match_descriptors</span><span class="p">(</span><span class="n">detector_extractor1</span><span class="o">.</span><span class="n">descriptors</span><span class="p">,</span>
<span class="gp">... </span>                            <span class="n">detector_extractor2</span><span class="o">.</span><span class="n">descriptors</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matches</span>
<span class="go">array([[0, 0],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [2, 2],</span>
<span class="go">       [3, 3],</span>
<span class="go">       [4, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">detector_extractor1</span><span class="o">.</span><span class="n">keypoints</span><span class="p">[</span><span class="n">matches</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="go">array([[ 42.,  40.],</span>
<span class="go">       [ 47.,  58.],</span>
<span class="go">       [ 44.,  40.],</span>
<span class="go">       [ 59.,  42.],</span>
<span class="go">       [ 45.,  44.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">detector_extractor2</span><span class="o">.</span><span class="n">keypoints</span><span class="p">[</span><span class="n">matches</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="go">array([[ 55.,  53.],</span>
<span class="go">       [ 60.,  71.],</span>
<span class="go">       [ 57.,  53.],</span>
<span class="go">       [ 72.,  55.],</span>
<span class="go">       [ 58.,  57.]])</span>
</pre></div>
</div>
<p class="rubric">Attributes</p>
<dl class="method">
<dt id="skimage.feature.ORB.__init__">
<tt class="descname">__init__</tt><big>(</big><em>downscale=1.2</em>, <em>n_scales=8</em>, <em>n_keypoints=500</em>, <em>fast_n=9</em>, <em>fast_threshold=0.08</em>, <em>harris_k=0.04</em><big>)</big><a class="headerlink" href="#skimage.feature.ORB.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.feature.ORB.detect">
<tt class="descname">detect</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#skimage.feature.ORB.detect" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect oriented FAST keypoints along with the corresponding scale.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2D array</p>
<blockquote class="last">
<div><p>Input image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.feature.ORB.detect_and_extract">
<tt class="descname">detect_and_extract</tt><big>(</big><em>image</em><big>)</big><a class="headerlink" href="#skimage.feature.ORB.detect_and_extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect oriented FAST keypoints and extract rBRIEF descriptors.</p>
<p>Note that this is faster than first calling <cite>detect</cite> and then
<cite>extract</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2D array</p>
<blockquote class="last">
<div><p>Input image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.feature.ORB.extract">
<tt class="descname">extract</tt><big>(</big><em>image</em>, <em>keypoints</em>, <em>scales</em>, <em>orientations</em><big>)</big><a class="headerlink" href="#skimage.feature.ORB.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract rBRIEF binary descriptors for given keypoints in image.</p>
<p>Note that the keypoints must be extracted using the same <cite>downscale</cite>
and <cite>n_scales</cite> parameters. Additionally, if you want to extract both
keypoints and descriptors you should use the faster
<cite>detect_and_extract</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2D array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>keypoints</strong> : (N, 2) array</p>
<blockquote>
<div><p>Keypoint coordinates as <tt class="docutils literal"><span class="pre">(row,</span> <span class="pre">col)</span></tt>.</p>
</div></blockquote>
<p><strong>scales</strong> : (N, ) array</p>
<blockquote>
<div><p>Corresponding scales.</p>
</div></blockquote>
<p><strong>orientations</strong> : (N, ) array</p>
<blockquote class="last">
<div><p>Corresponding orientations in radians.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.blob_dog" title="skimage.feature.blob_dog"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.blob_dog</span></tt></a>(image[,&nbsp;min_sigma,&nbsp;...])</td>
<td>Finds blobs in the given grayscale image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.blob_doh" title="skimage.feature.blob_doh"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.blob_doh</span></tt></a>(image[,&nbsp;min_sigma,&nbsp;...])</td>
<td>Finds blobs in the given grayscale image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.blob_log" title="skimage.feature.blob_log"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.blob_log</span></tt></a>(image[,&nbsp;min_sigma,&nbsp;...])</td>
<td>Finds blobs in the given grayscale image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.corner_fast" title="skimage.feature.corner_fast"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_fast</span></tt></a>(image[,&nbsp;n,&nbsp;...])</td>
<td>Extract FAST corners for a given image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.corner_foerstner" title="skimage.feature.corner_foerstner"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_foerstner</span></tt></a>(image[,&nbsp;sigma])</td>
<td>Compute Foerstner corner measure response image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.corner_harris" title="skimage.feature.corner_harris"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_harris</span></tt></a>(image[,&nbsp;...])</td>
<td>Compute Harris corner measure response image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.corner_kitchen_rosenfeld" title="skimage.feature.corner_kitchen_rosenfeld"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_kitchen_rosenfeld</span></tt></a>(image)</td>
<td>Compute Kitchen and Rosenfeld corner measure response image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.corner_moravec" title="skimage.feature.corner_moravec"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_moravec</span></tt></a></td>
<td>Compute Moravec corner measure response image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.corner_orientations" title="skimage.feature.corner_orientations"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_orientations</span></tt></a></td>
<td>Compute the orientation of corners.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.corner_peaks" title="skimage.feature.corner_peaks"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_peaks</span></tt></a>(image[,&nbsp;...])</td>
<td>Find corners in corner measure response image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.corner_shi_tomasi" title="skimage.feature.corner_shi_tomasi"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_shi_tomasi</span></tt></a>(image[,&nbsp;sigma])</td>
<td>Compute Shi-Tomasi (Kanade-Tomasi) corner measure response image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.corner_subpix" title="skimage.feature.corner_subpix"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.corner_subpix</span></tt></a>(image,&nbsp;corners)</td>
<td>Determine subpixel position of corners.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.daisy" title="skimage.feature.daisy"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.daisy</span></tt></a>(img[,&nbsp;step,&nbsp;radius,&nbsp;...])</td>
<td>Extract DAISY feature descriptors densely for the given image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.greycomatrix" title="skimage.feature.greycomatrix"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.greycomatrix</span></tt></a>(image,&nbsp;...[,&nbsp;...])</td>
<td>Calculate the grey-level co-occurrence matrix.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.greycoprops" title="skimage.feature.greycoprops"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.greycoprops</span></tt></a>(P[,&nbsp;prop])</td>
<td>Calculate texture properties of a GLCM.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.hessian_matrix" title="skimage.feature.hessian_matrix"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.hessian_matrix</span></tt></a>(image[,&nbsp;...])</td>
<td>Compute Hessian matrix.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.hessian_matrix_det" title="skimage.feature.hessian_matrix_det"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.hessian_matrix_det</span></tt></a>(image,&nbsp;sigma)</td>
<td>Computes the approximate Hessian Determinant over an image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.hessian_matrix_eigvals" title="skimage.feature.hessian_matrix_eigvals"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.hessian_matrix_eigvals</span></tt></a>(Hxx,&nbsp;...)</td>
<td>Compute Eigen values of Hessian matrix.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.hog" title="skimage.feature.hog"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.hog</span></tt></a>(image[,&nbsp;orientations,&nbsp;...])</td>
<td>Extract Histogram of Oriented Gradients (HOG) for a given image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.local_binary_pattern" title="skimage.feature.local_binary_pattern"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.local_binary_pattern</span></tt></a>(image,&nbsp;P,&nbsp;R)</td>
<td>Gray scale and rotation invariant LBP (Local Binary Patterns).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.match_descriptors" title="skimage.feature.match_descriptors"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.match_descriptors</span></tt></a>(...[,&nbsp;...])</td>
<td>Brute-force matching of descriptors.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.match_template" title="skimage.feature.match_template"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.match_template</span></tt></a>(image,&nbsp;template)</td>
<td>Match a template to a 2-D or 3-D image using normalized correlation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.peak_local_max" title="skimage.feature.peak_local_max"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.peak_local_max</span></tt></a>(image[,&nbsp;...])</td>
<td>Find peaks in an image, and return them as coordinates or a boolean array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.plot_matches" title="skimage.feature.plot_matches"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.plot_matches</span></tt></a>(ax,&nbsp;image1,&nbsp;...)</td>
<td>Plot matched features.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.feature.structure_tensor" title="skimage.feature.structure_tensor"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.structure_tensor</span></tt></a>(image[,&nbsp;...])</td>
<td>Compute structure tensor using sum of squared differences.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.feature.structure_tensor_eigvals" title="skimage.feature.structure_tensor_eigvals"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.feature.structure_tensor_eigvals</span></tt></a>(...)</td>
<td>Compute Eigen values of structure tensor.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="blob-dog">
<h2>blob_dog<a class="headerlink" href="#blob-dog" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.blob_dog">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">blob_dog</tt><big>(</big><em>image</em>, <em>min_sigma=1</em>, <em>max_sigma=50</em>, <em>sigma_ratio=1.6</em>, <em>threshold=2.0</em>, <em>overlap=0.5</em><big>)</big><a class="headerlink" href="#skimage.feature.blob_dog" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds blobs in the given grayscale image.</p>
<p>Blobs are found using the Difference of Gaussian (DoG) method <a class="reference internal" href="#r121" id="id4">[R121]</a>.
For each blob found, the method returns its coordinates and the standard
deviation of the Gaussian kernel that detected the blob.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input grayscale image, blobs are assumed to be light on dark
background (white on black).</p>
</div></blockquote>
<p><strong>min_sigma</strong> : float, optional</p>
<blockquote>
<div><p>The minimum standard deviation for Gaussian Kernel. Keep this low to
detect smaller blobs.</p>
</div></blockquote>
<p><strong>max_sigma</strong> : float, optional</p>
<blockquote>
<div><p>The maximum standard deviation for Gaussian Kernel. Keep this high to
detect larger blobs.</p>
</div></blockquote>
<p><strong>sigma_ratio</strong> : float, optional</p>
<blockquote>
<div><p>The ratio between the standard deviation of Gaussian Kernels used for
computing the Difference of Gaussians</p>
</div></blockquote>
<p><strong>threshold</strong> : float, optional.</p>
<blockquote>
<div><p>The absolute lower bound for scale space maxima. Local maxima smaller
than thresh are ignored. Reduce this to detect blobs with less
intensities.</p>
</div></blockquote>
<p><strong>overlap</strong> : float, optional</p>
<blockquote>
<div><p>A value between 0 and 1. If the area of two blobs overlaps by a
fraction greater than <cite>threshold</cite>, the smaller blob is eliminated.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>A</strong> : (n, 3) ndarray</p>
<blockquote class="last">
<div><p>A 2d array with each row representing 3 values, <tt class="docutils literal"><span class="pre">(y,x,sigma)</span></tt>
where <tt class="docutils literal"><span class="pre">(y,x)</span></tt> are coordinates of the blob and <tt class="docutils literal"><span class="pre">sigma</span></tt> is the
standard deviation of the Gaussian kernel which detected the blob.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The radius of each blob is approximately <img class="math" src="../_images/math/6872b86c6f1d197ae13916fd96a25c67f3ef07e8.png" alt="\sqrt{2}sigma"/>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r121" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R121]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> <a class="reference external" href="http://en.wikipedia.org/wiki/Blob_detection#The_difference_of_Gaussians_approach">http://en.wikipedia.org/wiki/Blob_detection#The_difference_of_Gaussians_approach</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">feature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">feature</span><span class="o">.</span><span class="n">blob_dog</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">(),</span> <span class="n">threshold</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_sigma</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="go">array([[ 45, 336,  16],</span>
<span class="go">       [ 52, 155,  16],</span>
<span class="go">       [ 52, 216,  16],</span>
<span class="go">       [ 54,  42,  16],</span>
<span class="go">       [ 54, 276,  10],</span>
<span class="go">       [ 58, 100,  10],</span>
<span class="go">       [120, 272,  16],</span>
<span class="go">       [124, 337,  10],</span>
<span class="go">       [125,  45,  16],</span>
<span class="go">       [125, 208,  10],</span>
<span class="go">       [127, 102,  10],</span>
<span class="go">       [128, 154,  10],</span>
<span class="go">       [185, 347,  16],</span>
<span class="go">       [193, 213,  16],</span>
<span class="go">       [194, 277,  16],</span>
<span class="go">       [195, 102,  16],</span>
<span class="go">       [196,  43,  10],</span>
<span class="go">       [198, 155,  10],</span>
<span class="go">       [260,  46,  16],</span>
<span class="go">       [261, 173,  16],</span>
<span class="go">       [263, 245,  16],</span>
<span class="go">       [263, 302,  16],</span>
<span class="go">       [267, 115,  10],</span>
<span class="go">       [267, 359,  16]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="blob-doh">
<h2>blob_doh<a class="headerlink" href="#blob-doh" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.blob_doh">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">blob_doh</tt><big>(</big><em>image</em>, <em>min_sigma=1</em>, <em>max_sigma=30</em>, <em>num_sigma=10</em>, <em>threshold=0.01</em>, <em>overlap=0.5</em>, <em>log_scale=False</em><big>)</big><a class="headerlink" href="#skimage.feature.blob_doh" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds blobs in the given grayscale image.</p>
<p>Blobs are found using the Determinant of Hessian method <a class="reference internal" href="#r122" id="id6">[R122]</a>. For each blob
found, the method returns its coordinates and the standard deviation
of the Gaussian Kernel used for the Hessian matrix whose determinant
detected the blob. Determinant of Hessians is approximated using <a class="reference internal" href="#r123" id="id7">[R123]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input grayscale image.Blobs can either be light on dark or vice versa.</p>
</div></blockquote>
<p><strong>min_sigma</strong> : float, optional</p>
<blockquote>
<div><p>The minimum standard deviation for Gaussian Kernel used to compute
Hessian matrix. Keep this low to detect smaller blobs.</p>
</div></blockquote>
<p><strong>max_sigma</strong> : float, optional</p>
<blockquote>
<div><p>The maximum standard deviation for Gaussian Kernel used to compute
Hessian matrix. Keep this high to detect larger blobs.</p>
</div></blockquote>
<p><strong>num_sigma</strong> : int, optional</p>
<blockquote>
<div><p>The number of intermediate values of standard deviations to consider
between <cite>min_sigma</cite> and <cite>max_sigma</cite>.</p>
</div></blockquote>
<p><strong>threshold</strong> : float, optional.</p>
<blockquote>
<div><p>The absolute lower bound for scale space maxima. Local maxima smaller
than thresh are ignored. Reduce this to detect less prominent blobs.</p>
</div></blockquote>
<p><strong>overlap</strong> : float, optional</p>
<blockquote>
<div><p>A value between 0 and 1. If the area of two blobs overlaps by a
fraction greater than <cite>threshold</cite>, the smaller blob is eliminated.</p>
</div></blockquote>
<p><strong>log_scale</strong> : bool, optional</p>
<blockquote>
<div><p>If set intermediate values of standard deviations are interpolated
using a logarithmic scale to the base <cite>10</cite>. If not, linear
interpolation is used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>A</strong> : (n, 3) ndarray</p>
<blockquote class="last">
<div><p>A 2d array with each row representing 3 values, <tt class="docutils literal"><span class="pre">(y,x,sigma)</span></tt>
where <tt class="docutils literal"><span class="pre">(y,x)</span></tt> are coordinates of the blob and <tt class="docutils literal"><span class="pre">sigma</span></tt> is the
standard deviation of the Gaussian kernel of the Hessian Matrix whose
determinant detected the blob.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The radius of each blob is approximately <cite>sigma</cite>.
Computation of Determinant of Hessians is independent of the standard
deviation. Therefore detecting larger blobs won&#8217;t take more time. In
methods line <a class="reference internal" href="#skimage.feature.blob_dog" title="skimage.feature.blob_dog"><tt class="xref py py-meth docutils literal"><span class="pre">blob_dog()</span></tt></a> and <a class="reference internal" href="#skimage.feature.blob_log" title="skimage.feature.blob_log"><tt class="xref py py-meth docutils literal"><span class="pre">blob_log()</span></tt></a> the computation
of Gaussians for larger <cite>sigma</cite> takes more time. The downside is that
this method can&#8217;t be used for detecting blobs of radius less than <cite>3px</cite>
due to the box filters used in the approximation of Hessian Determinant.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r122" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R122]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id8">2</a>)</em> <a class="reference external" href="http://en.wikipedia.org/wiki/Blob_detection#The_determinant_of_the_Hessian">http://en.wikipedia.org/wiki/Blob_detection#The_determinant_of_the_Hessian</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r123" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R123]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id9">2</a>)</em> Herbert Bay, Andreas Ess, Tinne Tuytelaars, Luc Van Gool,
&#8220;SURF: Speeded Up Robust Features&#8221;
<a class="reference external" href="ftp://ftp.vision.ee.ethz.ch/publications/articles/eth_biwi_00517.pdf">ftp://ftp.vision.ee.ethz.ch/publications/articles/eth_biwi_00517.pdf</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">feature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">feature</span><span class="o">.</span><span class="n">blob_doh</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="go">array([[121, 271,  30],</span>
<span class="go">       [123,  44,  23],</span>
<span class="go">       [123, 205,  20],</span>
<span class="go">       [124, 336,  20],</span>
<span class="go">       [126, 101,  20],</span>
<span class="go">       [126, 153,  20],</span>
<span class="go">       [156, 302,  30],</span>
<span class="go">       [185, 348,  30],</span>
<span class="go">       [192, 212,  23],</span>
<span class="go">       [193, 275,  23],</span>
<span class="go">       [195, 100,  23],</span>
<span class="go">       [197,  44,  20],</span>
<span class="go">       [197, 153,  20],</span>
<span class="go">       [260, 173,  30],</span>
<span class="go">       [262, 243,  23],</span>
<span class="go">       [265, 113,  23],</span>
<span class="go">       [270, 363,  30]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="blob-log">
<h2>blob_log<a class="headerlink" href="#blob-log" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.blob_log">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">blob_log</tt><big>(</big><em>image</em>, <em>min_sigma=1</em>, <em>max_sigma=50</em>, <em>num_sigma=10</em>, <em>threshold=0.2</em>, <em>overlap=0.5</em>, <em>log_scale=False</em><big>)</big><a class="headerlink" href="#skimage.feature.blob_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds blobs in the given grayscale image.</p>
<p>Blobs are found using the Laplacian of Gaussian (LoG) method <a class="reference internal" href="#r124" id="id10">[R124]</a>.
For each blob found, the method returns its coordinates and the standard
deviation of the Gaussian kernel that detected the blob.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input grayscale image, blobs are assumed to be light on dark
background (white on black).</p>
</div></blockquote>
<p><strong>min_sigma</strong> : float, optional</p>
<blockquote>
<div><p>The minimum standard deviation for Gaussian Kernel. Keep this low to
detect smaller blobs.</p>
</div></blockquote>
<p><strong>max_sigma</strong> : float, optional</p>
<blockquote>
<div><p>The maximum standard deviation for Gaussian Kernel. Keep this high to
detect larger blobs.</p>
</div></blockquote>
<p><strong>num_sigma</strong> : int, optional</p>
<blockquote>
<div><p>The number of intermediate values of standard deviations to consider
between <cite>min_sigma</cite> and <cite>max_sigma</cite>.</p>
</div></blockquote>
<p><strong>threshold</strong> : float, optional.</p>
<blockquote>
<div><p>The absolute lower bound for scale space maxima. Local maxima smaller
than thresh are ignored. Reduce this to detect blobs with less
intensities.</p>
</div></blockquote>
<p><strong>overlap</strong> : float, optional</p>
<blockquote>
<div><p>A value between 0 and 1. If the area of two blobs overlaps by a
fraction greater than <cite>threshold</cite>, the smaller blob is eliminated.</p>
</div></blockquote>
<p><strong>log_scale</strong> : bool, optional</p>
<blockquote>
<div><p>If set intermediate values of standard deviations are interpolated
using a logarithmic scale to the base <cite>10</cite>. If not, linear
interpolation is used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>A</strong> : (n, 3) ndarray</p>
<blockquote class="last">
<div><p>A 2d array with each row representing 3 values, <tt class="docutils literal"><span class="pre">(y,x,sigma)</span></tt>
where <tt class="docutils literal"><span class="pre">(y,x)</span></tt> are coordinates of the blob and <tt class="docutils literal"><span class="pre">sigma</span></tt> is the
standard deviation of the Gaussian kernel which detected the blob.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The radius of each blob is approximately <img class="math" src="../_images/math/6872b86c6f1d197ae13916fd96a25c67f3ef07e8.png" alt="\sqrt{2}sigma"/>.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r124" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R124]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id11">2</a>)</em> <a class="reference external" href="http://en.wikipedia.org/wiki/Blob_detection#The_Laplacian_of_Gaussian">http://en.wikipedia.org/wiki/Blob_detection#The_Laplacian_of_Gaussian</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">feature</span><span class="p">,</span> <span class="n">exposure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">equalize_hist</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>  <span class="c"># improves detection</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">feature</span><span class="o">.</span><span class="n">blob_log</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="o">.</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([[113, 323,   1],</span>
<span class="go">       [121, 272,  17],</span>
<span class="go">       [124, 336,  11],</span>
<span class="go">       [126,  46,  11],</span>
<span class="go">       [126, 208,  11],</span>
<span class="go">       [127, 102,  11],</span>
<span class="go">       [128, 154,  11],</span>
<span class="go">       [185, 344,  17],</span>
<span class="go">       [194, 213,  17],</span>
<span class="go">       [194, 276,  17],</span>
<span class="go">       [197,  44,  11],</span>
<span class="go">       [198, 103,  11],</span>
<span class="go">       [198, 155,  11],</span>
<span class="go">       [260, 174,  17],</span>
<span class="go">       [263, 244,  17],</span>
<span class="go">       [263, 302,  17],</span>
<span class="go">       [266, 115,  11]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="corner-fast">
<h2>corner_fast<a class="headerlink" href="#corner-fast" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_fast">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_fast</tt><big>(</big><em>image</em>, <em>n=12</em>, <em>threshold=0.15</em><big>)</big><a class="headerlink" href="#skimage.feature.corner_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract FAST corners for a given image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2D ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p>Minimum number of consecutive pixels out of 16 pixels on the circle
that should all be either brighter or darker w.r.t testpixel.
A point c on the circle is darker w.r.t test pixel p if
<cite>Ic &lt; Ip - threshold</cite> and brighter if <cite>Ic &gt; Ip + threshold</cite>. Also
stands for the n in <cite>FAST-n</cite> corner detector.</p>
</div></blockquote>
<p><strong>threshold</strong> : float</p>
<blockquote>
<div><p>Threshold used in deciding whether the pixels on the circle are
brighter, darker or similar w.r.t. the test pixel. Decrease the
threshold when more corners are desired and vice-versa.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>response</strong> : ndarray</p>
<blockquote class="last">
<div><p>FAST corner response image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r125" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[R125]</a></td><td>Edward Rosten and Tom Drummond
&#8220;Machine Learning for high-speed corner detection&#8221;,
<a class="reference external" href="http://www.edwardrosten.com/work/rosten_2006_machine.pdf">http://www.edwardrosten.com/work/rosten_2006_machine.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r126" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[R126]</a></td><td>Wikipedia, &#8220;Features from accelerated segment test&#8221;,
<a class="reference external" href="https://en.wikipedia.org/wiki/Features_from_accelerated_segment_test">https://en.wikipedia.org/wiki/Features_from_accelerated_segment_test</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">corner_fast</span><span class="p">,</span> <span class="n">corner_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">corner_fast</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[3, 3],</span>
<span class="go">       [3, 8],</span>
<span class="go">       [8, 3],</span>
<span class="go">       [8, 8]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="corner-foerstner">
<h2>corner_foerstner<a class="headerlink" href="#corner-foerstner" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_foerstner">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_foerstner</tt><big>(</big><em>image</em>, <em>sigma=1</em><big>)</big><a class="headerlink" href="#skimage.feature.corner_foerstner" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Foerstner corner measure response image.</p>
<p>This corner detector uses information from the auto-correlation matrix A:</p>
<div class="highlight-python"><div class="highlight"><pre>A = [(imx**2)   (imx*imy)] = [Axx Axy]
    [(imx*imy)   (imy**2)]   [Axy Ayy]
</pre></div>
</div>
<p>Where imx and imy are first derivatives, averaged with a gaussian filter.
The corner measure is then defined as:</p>
<div class="highlight-python"><div class="highlight"><pre>w = det(A) / trace(A)           (size of error ellipse)
q = 4 * det(A) / trace(A)**2    (roundness of error ellipse)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote>
<div><p>Standard deviation used for the Gaussian kernel, which is used as
weighting function for the auto-correlation matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>w</strong> : ndarray</p>
<blockquote>
<div><p>Error ellipse sizes.</p>
</div></blockquote>
<p><strong>q</strong> : ndarray</p>
<blockquote class="last">
<div><p>Roundness of error ellipse.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r127" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[R127]</a></td><td><a class="reference external" href="http://www.ipb.uni-bonn.de/uploads/tx_ikgpublication/foerstner87.fast.pdf">http://www.ipb.uni-bonn.de/uploads/tx_ikgpublication/foerstner87.fast.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r128" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[R128]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Corner_detection">http://en.wikipedia.org/wiki/Corner_detection</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">corner_foerstner</span><span class="p">,</span> <span class="n">corner_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">corner_foerstner</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">accuracy_thresh</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roundness_thresh</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foerstner</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;</span> <span class="n">roundness_thresh</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="n">accuracy_thresh</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">foerstner</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 7],</span>
<span class="go">       [7, 2],</span>
<span class="go">       [7, 7]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="corner-harris">
<h2>corner_harris<a class="headerlink" href="#corner-harris" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_harris">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_harris</tt><big>(</big><em>image</em>, <em>method='k'</em>, <em>k=0.05</em>, <em>eps=1e-06</em>, <em>sigma=1</em><big>)</big><a class="headerlink" href="#skimage.feature.corner_harris" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Harris corner measure response image.</p>
<p>This corner detector uses information from the auto-correlation matrix A:</p>
<div class="highlight-python"><div class="highlight"><pre>A = [(imx**2)   (imx*imy)] = [Axx Axy]
    [(imx*imy)   (imy**2)]   [Axy Ayy]
</pre></div>
</div>
<p>Where imx and imy are first derivatives, averaged with a gaussian filter.
The corner measure is then defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span> <span class="o">*</span> <span class="n">trace</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">2</span> <span class="o">*</span> <span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">trace</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>method</strong> : {&#8216;k&#8217;, &#8216;eps&#8217;}, optional</p>
<blockquote>
<div><p>Method to compute the response image from the auto-correlation matrix.</p>
</div></blockquote>
<p><strong>k</strong> : float, optional</p>
<blockquote>
<div><p>Sensitivity factor to separate corners from edges, typically in range
<cite>[0, 0.2]</cite>. Small values of k result in detection of sharp corners.</p>
</div></blockquote>
<p><strong>eps</strong> : float, optional</p>
<blockquote>
<div><p>Normalisation factor (Noble&#8217;s corner measure).</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote>
<div><p>Standard deviation used for the Gaussian kernel, which is used as
weighting function for the auto-correlation matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>response</strong> : ndarray</p>
<blockquote class="last">
<div><p>Harris response image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r129" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[R129]</a></td><td><a class="reference external" href="http://kiwi.cs.dal.ca/~dparks/CornerDetection/harris.htm">http://kiwi.cs.dal.ca/~dparks/CornerDetection/harris.htm</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r130" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[R130]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Corner_detection">http://en.wikipedia.org/wiki/Corner_detection</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">corner_harris</span><span class="p">,</span> <span class="n">corner_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">corner_harris</span><span class="p">(</span><span class="n">square</span><span class="p">),</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 7],</span>
<span class="go">       [7, 2],</span>
<span class="go">       [7, 7]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="corner-kitchen-rosenfeld">
<h2>corner_kitchen_rosenfeld<a class="headerlink" href="#corner-kitchen-rosenfeld" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_kitchen_rosenfeld">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_kitchen_rosenfeld</tt><big>(</big><em>image</em>, <em>mode='constant'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.feature.corner_kitchen_rosenfeld" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Kitchen and Rosenfeld corner measure response image.</p>
<p>The corner measure is calculated as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>(imxx * imy**2 + imyy * imx**2 - 2 * imxy * imx * imy)
    / (imx**2 + imy**2)
</pre></div>
</div>
<p>Where imx and imy are the first and imxx, imxy, imyy the second
derivatives.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;constant&#8217;, &#8216;reflect&#8217;, &#8216;wrap&#8217;, &#8216;nearest&#8217;, &#8216;mirror&#8217;}, optional</p>
<blockquote>
<div><p>How to handle values outside the image borders.</p>
</div></blockquote>
<p><strong>cval</strong> : float, optional</p>
<blockquote>
<div><p>Used in conjunction with mode &#8216;constant&#8217;, the value outside
the image boundaries.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>response</strong> : ndarray</p>
<blockquote class="last">
<div><p>Kitchen and Rosenfeld response image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="corner-moravec">
<h2>corner_moravec<a class="headerlink" href="#corner-moravec" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_moravec">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_moravec</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.feature.corner_moravec" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Moravec corner measure response image.</p>
<p>This is one of the simplest corner detectors and is comparatively fast but
has several limitations (e.g. not rotation invariant).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>window_size</strong> : int, optional (default 1)</p>
<blockquote>
<div><p>Window size.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>response</strong> : ndarray</p>
<blockquote class="last">
<div><p>Moravec response image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r131" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[R131]</a></td><td><a class="reference external" href="http://kiwi.cs.dal.ca/~dparks/CornerDetection/moravec.htm">http://kiwi.cs.dal.ca/~dparks/CornerDetection/moravec.htm</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r132" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[R132]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Corner_detection">http://en.wikipedia.org/wiki/Corner_detection</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">corner_moravec</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_moravec</span><span class="p">(</span><span class="n">square</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 2, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="corner-orientations">
<h2>corner_orientations<a class="headerlink" href="#corner-orientations" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_orientations">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_orientations</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.feature.corner_orientations" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the orientation of corners.</p>
<p>The orientation of corners is computed using the first order central moment
i.e. the center of mass approach. The corner orientation is the angle of
the vector from the corner coordinate to the intensity centroid in the
local neighborhood around the corner calculated using first order central
moment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : 2D array</p>
<blockquote>
<div><p>Input grayscale image.</p>
</div></blockquote>
<p><strong>corners</strong> : (N, 2) array</p>
<blockquote>
<div><p>Corner coordinates as <tt class="docutils literal"><span class="pre">(row,</span> <span class="pre">col)</span></tt>.</p>
</div></blockquote>
<p><strong>mask</strong> : 2D array</p>
<blockquote>
<div><p>Mask defining the local neighborhood of the corner used for the
calculation of the central moment.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>orientations</strong> : (N, 1) array</p>
<blockquote class="last">
<div><p>Orientations of corners in the range [-pi, pi].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r133" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[R133]</a></td><td>Ethan Rublee, Vincent Rabaud, Kurt Konolige and Gary Bradski
&#8220;ORB : An efficient alternative to SIFT and SURF&#8221;
<a class="reference external" href="http://www.vision.cs.chubu.ac.jp/CV-R/pdf/Rublee_iccv2011.pdf">http://www.vision.cs.chubu.ac.jp/CV-R/pdf/Rublee_iccv2011.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r134" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[R134]</a></td><td>Paul L. Rosin, &#8220;Measuring Corner Properties&#8221;
<a class="reference external" href="http://users.cs.cf.ac.uk/Paul.Rosin/corner2.pdf">http://users.cs.cf.ac.uk/Paul.Rosin/corner2.pdf</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">octagon</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="p">(</span><span class="n">corner_fast</span><span class="p">,</span> <span class="n">corner_peaks</span><span class="p">,</span>
<span class="gp">... </span>                             <span class="n">corner_orientations</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corners</span> <span class="o">=</span> <span class="n">corner_peaks</span><span class="p">(</span><span class="n">corner_fast</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corners</span>
<span class="go">array([[3, 3],</span>
<span class="go">       [3, 8],</span>
<span class="go">       [8, 3],</span>
<span class="go">       [8, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orientations</span> <span class="o">=</span> <span class="n">corner_orientations</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">corners</span><span class="p">,</span> <span class="n">octagon</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">orientations</span><span class="p">)</span>
<span class="go">array([  45.,  135.,  -45., -135.])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="corner-peaks">
<h2>corner_peaks<a class="headerlink" href="#corner-peaks" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_peaks">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_peaks</tt><big>(</big><em>image</em>, <em>min_distance=10</em>, <em>threshold_abs=0</em>, <em>threshold_rel=0.1</em>, <em>exclude_border=True</em>, <em>indices=True</em>, <em>num_peaks=inf</em>, <em>footprint=None</em>, <em>labels=None</em><big>)</big><a class="headerlink" href="#skimage.feature.corner_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Find corners in corner measure response image.</p>
<p>This differs from <cite>skimage.feature.peak_local_max</cite> in that it suppresses
multiple connected peaks with the same accumulator value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>*</strong> : *</p>
<blockquote class="last">
<div><p>See <a class="reference internal" href="#skimage.feature.peak_local_max" title="skimage.feature.peak_local_max"><tt class="xref py py-meth docutils literal"><span class="pre">skimage.feature.peak_local_max()</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">peak_local_max</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 2],</span>
<span class="go">       [3, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">array([[2, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 2],</span>
<span class="go">       [3, 3]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="corner-shi-tomasi">
<h2>corner_shi_tomasi<a class="headerlink" href="#corner-shi-tomasi" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_shi_tomasi">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_shi_tomasi</tt><big>(</big><em>image</em>, <em>sigma=1</em><big>)</big><a class="headerlink" href="#skimage.feature.corner_shi_tomasi" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Shi-Tomasi (Kanade-Tomasi) corner measure response image.</p>
<p>This corner detector uses information from the auto-correlation matrix A:</p>
<div class="highlight-python"><div class="highlight"><pre>A = [(imx**2)   (imx*imy)] = [Axx Axy]
    [(imx*imy)   (imy**2)]   [Axy Ayy]
</pre></div>
</div>
<p>Where imx and imy are first derivatives, averaged with a gaussian filter.
The corner measure is then defined as the smaller eigenvalue of A:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">((</span><span class="n">Axx</span> <span class="o">+</span> <span class="n">Ayy</span><span class="p">)</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">Axx</span> <span class="o">-</span> <span class="n">Ayy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">Axy</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote>
<div><p>Standard deviation used for the Gaussian kernel, which is used as
weighting function for the auto-correlation matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>response</strong> : ndarray</p>
<blockquote class="last">
<div><p>Shi-Tomasi response image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r135" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[R135]</a></td><td><a class="reference external" href="http://kiwi.cs.dal.ca/~dparks/CornerDetection/harris.htm">http://kiwi.cs.dal.ca/~dparks/CornerDetection/harris.htm</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r136" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[R136]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Corner_detection">http://en.wikipedia.org/wiki/Corner_detection</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">corner_shi_tomasi</span><span class="p">,</span> <span class="n">corner_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">corner_shi_tomasi</span><span class="p">(</span><span class="n">square</span><span class="p">),</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 7],</span>
<span class="go">       [7, 2],</span>
<span class="go">       [7, 7]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="corner-subpix">
<h2>corner_subpix<a class="headerlink" href="#corner-subpix" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.corner_subpix">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">corner_subpix</tt><big>(</big><em>image</em>, <em>corners</em>, <em>window_size=11</em>, <em>alpha=0.99</em><big>)</big><a class="headerlink" href="#skimage.feature.corner_subpix" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine subpixel position of corners.</p>
<p>A statistical test decides whether the corner is defined as the
intersection of two edges or a single peak. Depending on the classification
result, the subpixel corner location is determined based on the local
covariance of the grey-values. If the significance level for either
statistical test is not sufficient, the corner cannot be classified, and
the output subpixel position is set to NaN.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>corners</strong> : (N, 2) ndarray</p>
<blockquote>
<div><p>Corner coordinates <cite>(row, col)</cite>.</p>
</div></blockquote>
<p><strong>window_size</strong> : int, optional</p>
<blockquote>
<div><p>Search window size for subpixel estimation.</p>
</div></blockquote>
<p><strong>alpha</strong> : float, optional</p>
<blockquote>
<div><p>Significance level for corner classification.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>positions</strong> : (N, 2) ndarray</p>
<blockquote class="last">
<div><p>Subpixel corner positions. NaN for &#8220;not classified&#8221; corners.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r137" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id24">[R137]</a></td><td><a class="reference external" href="http://www.ipb.uni-bonn.de/uploads/tx_ikgpublication/">http://www.ipb.uni-bonn.de/uploads/tx_ikgpublication/</a>           foerstner87.fast.pdf</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r138" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[R138]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Corner_detection">http://en.wikipedia.org/wiki/Corner_detection</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">corner_harris</span><span class="p">,</span> <span class="n">corner_peaks</span><span class="p">,</span> <span class="n">corner_subpix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[:</span><span class="mi">5</span><span class="p">,</span> <span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="mi">5</span><span class="p">:,</span> <span class="mi">5</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 1, 1, 0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 1, 1, 1, 0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 1, 1, 1, 0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 1, 1, 1, 0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 1, 1, 1, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">corner_peaks</span><span class="p">(</span><span class="n">corner_harris</span><span class="p">(</span><span class="n">img</span><span class="p">),</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords_subpix</span> <span class="o">=</span> <span class="n">corner_subpix</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords_subpix</span>
<span class="go">array([[ 4.5,  4.5]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="daisy">
<h2>daisy<a class="headerlink" href="#daisy" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.daisy">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">daisy</tt><big>(</big><em>img</em>, <em>step=4</em>, <em>radius=15</em>, <em>rings=3</em>, <em>histograms=8</em>, <em>orientations=8</em>, <em>normalization='l1'</em>, <em>sigmas=None</em>, <em>ring_radii=None</em>, <em>visualize=False</em><big>)</big><a class="headerlink" href="#skimage.feature.daisy" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract DAISY feature descriptors densely for the given image.</p>
<p>DAISY is a feature descriptor similar to SIFT formulated in a way that
allows for fast dense extraction. Typically, this is practical for
bag-of-features image representations.</p>
<p>The implementation follows Tola et al. <a class="reference internal" href="#r139" id="id26">[R139]</a> but deviate on the following
points:</p>
<blockquote>
<div><ul class="simple">
<li>Histogram bin contribution are smoothed with a circular Gaussian
window over the tonal range (the angular range).</li>
<li>The sigma values of the spatial Gaussian smoothing in this code do not
match the sigma values in the original code by Tola et al. <a class="reference internal" href="#r140" id="id27">[R140]</a>. In
their code, spatial smoothing is applied to both the input image and
the center histogram. However, this smoothing is not documented in <a class="reference internal" href="#r139" id="id28">[R139]</a>
and, therefore, it is omitted.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>img</strong> : (M, N) array</p>
<blockquote>
<div><p>Input image (greyscale).</p>
</div></blockquote>
<p><strong>step</strong> : int, optional</p>
<blockquote>
<div><p>Distance between descriptor sampling points.</p>
</div></blockquote>
<p><strong>radius</strong> : int, optional</p>
<blockquote>
<div><p>Radius (in pixels) of the outermost ring.</p>
</div></blockquote>
<p><strong>rings</strong> : int, optional</p>
<blockquote>
<div><p>Number of rings.</p>
</div></blockquote>
<p><strong>histograms</strong> : int, optional</p>
<blockquote>
<div><p>Number of histograms sampled per ring.</p>
</div></blockquote>
<p><strong>orientations</strong> : int, optional</p>
<blockquote>
<div><p>Number of orientations (bins) per histogram.</p>
</div></blockquote>
<p><strong>normalization</strong> : [ &#8216;l1&#8217; | &#8216;l2&#8217; | &#8216;daisy&#8217; | &#8216;off&#8217; ], optional</p>
<blockquote>
<div><p>How to normalize the descriptors</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;l1&#8217;: L1-normalization of each descriptor.</li>
<li>&#8216;l2&#8217;: L2-normalization of each descriptor.</li>
<li>&#8216;daisy&#8217;: L2-normalization of individual histograms.</li>
<li>&#8216;off&#8217;: Disable normalization.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>sigmas</strong> : 1D array of float, optional</p>
<blockquote>
<div><p>Standard deviation of spatial Gaussian smoothing for the center
histogram and for each ring of histograms. The array of sigmas should
be sorted from the center and out. I.e. the first sigma value defines
the spatial smoothing of the center histogram and the last sigma value
defines the spatial smoothing of the outermost ring. Specifying sigmas
overrides the following parameter.</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">rings</span> <span class="pre">=</span> <span class="pre">len(sigmas)</span> <span class="pre">-</span> <span class="pre">1</span></tt></p>
</div></blockquote>
</div></blockquote>
<p><strong>ring_radii</strong> : 1D array of int, optional</p>
<blockquote>
<div><p>Radius (in pixels) for each ring. Specifying ring_radii overrides the
following two parameters.</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">rings</span> <span class="pre">=</span> <span class="pre">len(ring_radii)</span></tt>
<tt class="docutils literal"><span class="pre">radius</span> <span class="pre">=</span> <span class="pre">ring_radii[-1]</span></tt></p>
</div></blockquote>
<p>If both sigmas and ring_radii are given, they must satisfy the
following predicate since no radius is needed for the center
histogram.</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">len(ring_radii)</span> <span class="pre">==</span> <span class="pre">len(sigmas)</span> <span class="pre">+</span> <span class="pre">1</span></tt></p>
</div></blockquote>
</div></blockquote>
<p><strong>visualize</strong> : bool, optional</p>
<blockquote>
<div><p>Generate a visualization of the DAISY descriptors</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>descs</strong> : array</p>
<blockquote>
<div><p>Grid of DAISY descriptors for the given image as an array
dimensionality  (P, Q, R) where</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">ceil((M</span> <span class="pre">-</span> <span class="pre">radius*2)</span> <span class="pre">/</span> <span class="pre">step)</span></tt>
<tt class="docutils literal"><span class="pre">Q</span> <span class="pre">=</span> <span class="pre">ceil((N</span> <span class="pre">-</span> <span class="pre">radius*2)</span> <span class="pre">/</span> <span class="pre">step)</span></tt>
<tt class="docutils literal"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">(rings</span> <span class="pre">*</span> <span class="pre">histograms</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">orientations</span></tt></p>
</div></blockquote>
</div></blockquote>
<p><strong>descs_img</strong> : (M, N, 3) array (only if visualize==True)</p>
<blockquote class="last">
<div><p>Visualization of the DAISY descriptors.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r139" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R139]</td><td><em>(<a class="fn-backref" href="#id26">1</a>, <a class="fn-backref" href="#id28">2</a>, <a class="fn-backref" href="#id29">3</a>)</em> Tola et al. &#8220;Daisy: An efficient dense descriptor applied to wide-
baseline stereo.&#8221; Pattern Analysis and Machine Intelligence, IEEE
Transactions on 32.5 (2010): 815-830.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r140" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R140]</td><td><em>(<a class="fn-backref" href="#id27">1</a>, <a class="fn-backref" href="#id30">2</a>)</em> <a class="reference external" href="http://cvlab.epfl.ch/alumni/tola/daisy.html">http://cvlab.epfl.ch/alumni/tola/daisy.html</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="greycomatrix">
<h2>greycomatrix<a class="headerlink" href="#greycomatrix" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.greycomatrix">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">greycomatrix</tt><big>(</big><em>image</em>, <em>distances</em>, <em>angles</em>, <em>levels=256</em>, <em>symmetric=False</em>, <em>normed=False</em><big>)</big><a class="headerlink" href="#skimage.feature.greycomatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the grey-level co-occurrence matrix.</p>
<p>A grey level co-occurence matrix is a histogram of co-occuring
greyscale values at a given offset over an image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : array_like of uint8</p>
<blockquote>
<div><p>Integer typed input image. The image will be cast to uint8, so
the maximum value must be less than 256.</p>
</div></blockquote>
<p><strong>distances</strong> : array_like</p>
<blockquote>
<div><p>List of pixel pair distance offsets.</p>
</div></blockquote>
<p><strong>angles</strong> : array_like</p>
<blockquote>
<div><p>List of pixel pair angles in radians.</p>
</div></blockquote>
<p><strong>levels</strong> : int, optional</p>
<blockquote>
<div><p>The input image should contain integers in [0, levels-1],
where levels indicate the number of grey-levels counted
(typically 256 for an 8-bit image). The maximum value is
256.</p>
</div></blockquote>
<p><strong>symmetric</strong> : bool, optional</p>
<blockquote>
<div><p>If True, the output matrix <cite>P[:, :, d, theta]</cite> is symmetric. This
is accomplished by ignoring the order of value pairs, so both
(i, j) and (j, i) are accumulated when (i, j) is encountered
for a given offset. The default is False.</p>
</div></blockquote>
<p><strong>normed</strong> : bool, optional</p>
<blockquote>
<div><p>If True, normalize each matrix <cite>P[:, :, d, theta]</cite> by dividing
by the total number of accumulated co-occurrences for the given
offset. The elements of the resulting matrix sum to 1. The
default is False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>P</strong> : 4-D ndarray</p>
<blockquote class="last">
<div><p>The grey-level co-occurrence histogram. The value
<cite>P[i,j,d,theta]</cite> is the number of times that grey-level <cite>j</cite>
occurs at a distance <cite>d</cite> and at an angle <cite>theta</cite> from
grey-level <cite>i</cite>. If <cite>normed</cite> is <cite>False</cite>, the output is of
type uint32, otherwise it is float64.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r141" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id31">[R141]</a></td><td>The GLCM Tutorial Home Page,
<a class="reference external" href="http://www.fp.ucalgary.ca/mhallbey/tutorial.htm">http://www.fp.ucalgary.ca/mhallbey/tutorial.htm</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r142" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id32">[R142]</a></td><td>Pattern Recognition Engineering, Morton Nadler &amp; Eric P.
Smith</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r143" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id33">[R143]</a></td><td>Wikipedia, <a class="reference external" href="http://en.wikipedia.org/wiki/Co-occurrence_matrix">http://en.wikipedia.org/wiki/Co-occurrence_matrix</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Compute 2 GLCMs: One for a 1-pixel offset to the right, and one
for a 1-pixel offset upwards.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">greycomatrix</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">],</span> <span class="n">levels</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[2, 2, 1, 0],</span>
<span class="go">       [0, 2, 0, 0],</span>
<span class="go">       [0, 0, 3, 1],</span>
<span class="go">       [0, 0, 0, 1]], dtype=uint32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">array([[1, 1, 3, 0],</span>
<span class="go">       [0, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 2],</span>
<span class="go">       [0, 0, 0, 0]], dtype=uint32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="go">array([[3, 0, 2, 0],</span>
<span class="go">       [0, 2, 2, 0],</span>
<span class="go">       [0, 0, 1, 2],</span>
<span class="go">       [0, 0, 0, 0]], dtype=uint32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="go">array([[2, 0, 0, 0],</span>
<span class="go">       [1, 1, 2, 0],</span>
<span class="go">       [0, 0, 2, 1],</span>
<span class="go">       [0, 0, 0, 0]], dtype=uint32)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="greycoprops">
<h2>greycoprops<a class="headerlink" href="#greycoprops" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.greycoprops">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">greycoprops</tt><big>(</big><em>P</em>, <em>prop='contrast'</em><big>)</big><a class="headerlink" href="#skimage.feature.greycoprops" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate texture properties of a GLCM.</p>
<p>Compute a feature of a grey level co-occurrence matrix to serve as
a compact summary of the matrix. The properties are computed as
follows:</p>
<ul>
<li><p class="first">&#8216;contrast&#8217;: <img class="math" src="../_images/math/e2ef7f012f36fb8909d4e34edbea36ae01365c92.png" alt="\sum_{i,j=0}^{levels-1} P_{i,j}(i-j)^2"/></p>
</li>
<li><p class="first">&#8216;dissimilarity&#8217;: <img class="math" src="../_images/math/c547b7874b6fa4c30aca007b3f9841ba7791b484.png" alt="\sum_{i,j=0}^{levels-1}P_{i,j}|i-j|"/></p>
</li>
<li><p class="first">&#8216;homogeneity&#8217;: <img class="math" src="../_images/math/e7e5ebf972f23d01ada1091f31bce6b1da61c1ab.png" alt="\sum_{i,j=0}^{levels-1}\frac{P_{i,j}}{1+(i-j)^2}"/></p>
</li>
<li><p class="first">&#8216;ASM&#8217;: <img class="math" src="../_images/math/18579b75e932607726b9ac8ce24798b6ff971411.png" alt="\sum_{i,j=0}^{levels-1} P_{i,j}^2"/></p>
</li>
<li><p class="first">&#8216;energy&#8217;: <img class="math" src="../_images/math/7bedbaeef28afd9a441f5b7be15f11546e2b21b7.png" alt="\sqrt{ASM}"/></p>
</li>
<li><dl class="first docutils">
<dt>&#8216;correlation&#8217;:</dt>
<dd><div class="first last math">
<p><img src="../_images/math/445e6743bd7a4e8f4e2c6e525a3beaf48b3d256c.png" alt="\sum_{i,j=0}^{levels-1} P_{i,j}\left[\frac{(i-\mu_i) \
(j-\mu_j)}{\sqrt{(\sigma_i^2)(\sigma_j^2)}}\right]"/></p>
</div></dd>
</dl>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>P</strong> : ndarray</p>
<blockquote>
<div><p>Input array. <cite>P</cite> is the grey-level co-occurrence histogram
for which to compute the specified property. The value
<cite>P[i,j,d,theta]</cite> is the number of times that grey-level j
occurs at a distance d and at an angle theta from
grey-level i.</p>
</div></blockquote>
<p><strong>prop</strong> : {&#8216;contrast&#8217;, &#8216;dissimilarity&#8217;, &#8216;homogeneity&#8217;, &#8216;energy&#8217;,             &#8216;correlation&#8217;, &#8216;ASM&#8217;}, optional</p>
<blockquote>
<div><p>The property of the GLCM to compute. The default is &#8216;contrast&#8217;.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>results</strong> : 2-D ndarray</p>
<blockquote class="last">
<div><p>2-dimensional array. <cite>results[d, a]</cite> is the property &#8216;prop&#8217; for
the d&#8217;th distance and the a&#8217;th angle.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r144" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id34">[R144]</a></td><td>The GLCM Tutorial Home Page,
<a class="reference external" href="http://www.fp.ucalgary.ca/mhallbey/tutorial.htm">http://www.fp.ucalgary.ca/mhallbey/tutorial.htm</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Compute the contrast for GLCMs with distances [1, 2] and angles
[0 degrees, 90 degrees]</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">greycomatrix</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="n">levels</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
<span class="gp">... </span>                 <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">contrast</span> <span class="o">=</span> <span class="n">greycoprops</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s">&#39;contrast&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">contrast</span>
<span class="go">array([[ 0.58333333,  1.        ],</span>
<span class="go">       [ 1.25      ,  2.75      ]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="hessian-matrix">
<h2>hessian_matrix<a class="headerlink" href="#hessian-matrix" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.hessian_matrix">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">hessian_matrix</tt><big>(</big><em>image</em>, <em>sigma=1</em>, <em>mode='constant'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.feature.hessian_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Hessian matrix.</p>
<p>The Hessian matrix is defined as:</p>
<div class="highlight-python"><div class="highlight"><pre>H = [Hxx Hxy]
    [Hxy Hyy]
</pre></div>
</div>
<p>which is computed by convolving the image with the second derivatives
of the Gaussian kernel in the respective x- and y-directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>sigma</strong> : float</p>
<blockquote>
<div><p>Standard deviation used for the Gaussian kernel, which is used as
weighting function for the auto-correlation matrix.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;constant&#8217;, &#8216;reflect&#8217;, &#8216;wrap&#8217;, &#8216;nearest&#8217;, &#8216;mirror&#8217;}, optional</p>
<blockquote>
<div><p>How to handle values outside the image borders.</p>
</div></blockquote>
<p><strong>cval</strong> : float, optional</p>
<blockquote>
<div><p>Used in conjunction with mode &#8216;constant&#8217;, the value outside
the image boundaries.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Hxx</strong> : ndarray</p>
<blockquote>
<div><p>Element of the Hessian matrix for each pixel in the input image.</p>
</div></blockquote>
<p><strong>Hxy</strong> : ndarray</p>
<blockquote>
<div><p>Element of the Hessian matrix for each pixel in the input image.</p>
</div></blockquote>
<p><strong>Hyy</strong> : ndarray</p>
<blockquote class="last">
<div><p>Element of the Hessian matrix for each pixel in the input image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">hessian_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Hxx</span><span class="p">,</span> <span class="n">Hxy</span><span class="p">,</span> <span class="n">Hyy</span> <span class="o">=</span> <span class="n">hessian_matrix</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Hxx</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="hessian-matrix-det">
<h2>hessian_matrix_det<a class="headerlink" href="#hessian-matrix-det" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.hessian_matrix_det">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">hessian_matrix_det</tt><big>(</big><em>image</em>, <em>sigma</em><big>)</big><a class="headerlink" href="#skimage.feature.hessian_matrix_det" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the approximate Hessian Determinant over an image.</p>
<p>This method uses box filters over integral images to compute the
approximate Hessian Determinant as described in <a class="reference internal" href="#r145" id="id35">[R145]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote>
<div><p>The image over which to compute Hessian Determinant.</p>
</div></blockquote>
<p><strong>sigma</strong> : float</p>
<blockquote>
<div><p>Standard deviation used for the Gaussian kernel, used for the Hessian
matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : array</p>
<blockquote class="last">
<div><p>The array of the Determinant of Hessians.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The running time of this method only depends on size of the image. It is
independent of <cite>sigma</cite> as one would expect. The downside is that the
result for <cite>sigma</cite> less than <cite>3</cite> is not accurate, i.e., not similar to
the result obtained if someone computed the Hessian and took it&#8217;s
determinant.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r145" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R145]</td><td><em>(<a class="fn-backref" href="#id35">1</a>, <a class="fn-backref" href="#id36">2</a>)</em> Herbert Bay, Andreas Ess, Tinne Tuytelaars, Luc Van Gool,
&#8220;SURF: Speeded Up Robust Features&#8221;
<a class="reference external" href="ftp://ftp.vision.ee.ethz.ch/publications/articles/eth_biwi_00517.pdf">ftp://ftp.vision.ee.ethz.ch/publications/articles/eth_biwi_00517.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="hessian-matrix-eigvals">
<h2>hessian_matrix_eigvals<a class="headerlink" href="#hessian-matrix-eigvals" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.hessian_matrix_eigvals">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">hessian_matrix_eigvals</tt><big>(</big><em>Hxx</em>, <em>Hxy</em>, <em>Hyy</em><big>)</big><a class="headerlink" href="#skimage.feature.hessian_matrix_eigvals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Eigen values of Hessian matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Hxx</strong> : ndarray</p>
<blockquote>
<div><p>Element of the Hessian matrix for each pixel in the input image.</p>
</div></blockquote>
<p><strong>Hxy</strong> : ndarray</p>
<blockquote>
<div><p>Element of the Hessian matrix for each pixel in the input image.</p>
</div></blockquote>
<p><strong>Hyy</strong> : ndarray</p>
<blockquote>
<div><p>Element of the Hessian matrix for each pixel in the input image.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>l1</strong> : ndarray</p>
<blockquote>
<div><p>Larger eigen value for each input matrix.</p>
</div></blockquote>
<p><strong>l2</strong> : ndarray</p>
<blockquote class="last">
<div><p>Smaller eigen value for each input matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">hessian_matrix</span><span class="p">,</span> <span class="n">hessian_matrix_eigvals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Hxx</span><span class="p">,</span> <span class="n">Hxy</span><span class="p">,</span> <span class="n">Hyy</span> <span class="o">=</span> <span class="n">hessian_matrix</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hessian_matrix_eigvals</span><span class="p">(</span><span class="n">Hxx</span><span class="p">,</span> <span class="n">Hxy</span><span class="p">,</span> <span class="n">Hyy</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="hog">
<h2>hog<a class="headerlink" href="#hog" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.hog">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">hog</tt><big>(</big><em>image</em>, <em>orientations=9</em>, <em>pixels_per_cell=(8</em>, <em>8)</em>, <em>cells_per_block=(3</em>, <em>3)</em>, <em>visualise=False</em>, <em>normalise=False</em><big>)</big><a class="headerlink" href="#skimage.feature.hog" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract Histogram of Oriented Gradients (HOG) for a given image.</p>
<p>Compute a Histogram of Oriented Gradients (HOG) by</p>
<blockquote>
<div><ol class="arabic simple">
<li>(optional) global image normalisation</li>
<li>computing the gradient image in x and y</li>
<li>computing gradient histograms</li>
<li>normalising across blocks</li>
<li>flattening into a feature vector</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : (M, N) ndarray</p>
<blockquote>
<div><p>Input image (greyscale).</p>
</div></blockquote>
<p><strong>orientations</strong> : int</p>
<blockquote>
<div><p>Number of orientation bins.</p>
</div></blockquote>
<p><strong>pixels_per_cell</strong> : 2 tuple (int, int)</p>
<blockquote>
<div><p>Size (in pixels) of a cell.</p>
</div></blockquote>
<p><strong>cells_per_block</strong> : 2 tuple (int,int)</p>
<blockquote>
<div><p>Number of cells in each block.</p>
</div></blockquote>
<p><strong>visualise</strong> : bool, optional</p>
<blockquote>
<div><p>Also return an image of the HOG.</p>
</div></blockquote>
<p><strong>normalise</strong> : bool, optional</p>
<blockquote>
<div><p>Apply power law compression to normalise the image before
processing.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>newarr</strong> : ndarray</p>
<blockquote>
<div><p>HOG for the image as a 1D (flattened) array.</p>
</div></blockquote>
<p><strong>hog_image</strong> : ndarray (if visualise=True)</p>
<blockquote class="last">
<div><p>A visualisation of the HOG image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Histogram_of_oriented_gradients">http://en.wikipedia.org/wiki/Histogram_of_oriented_gradients</a></li>
<li>Dalal, N and Triggs, B, Histograms of Oriented Gradients for
Human Detection, IEEE Computer Society Conference on Computer
Vision and Pattern Recognition 2005 San Diego, CA, USA</li>
</ul>
</dd></dl>

</div>
<div class="section" id="local-binary-pattern">
<h2>local_binary_pattern<a class="headerlink" href="#local-binary-pattern" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.local_binary_pattern">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">local_binary_pattern</tt><big>(</big><em>image</em>, <em>P</em>, <em>R</em>, <em>method='default'</em><big>)</big><a class="headerlink" href="#skimage.feature.local_binary_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Gray scale and rotation invariant LBP (Local Binary Patterns).</p>
<p>LBP is an invariant descriptor that can be used for texture classification.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : (N, M) array</p>
<blockquote>
<div><p>Graylevel image.</p>
</div></blockquote>
<p><strong>P</strong> : int</p>
<blockquote>
<div><p>Number of circularly symmetric neighbour set points (quantization of
the angular space).</p>
</div></blockquote>
<p><strong>R</strong> : float</p>
<blockquote>
<div><p>Radius of circle (spatial resolution of the operator).</p>
</div></blockquote>
<p><strong>method</strong> : {&#8216;default&#8217;, &#8216;ror&#8217;, &#8216;uniform&#8217;, &#8216;var&#8217;}</p>
<blockquote>
<div><p>Method to determine the pattern.</p>
<ul>
<li><dl class="first docutils">
<dt>&#8216;default&#8217;: original local binary pattern which is gray scale but not</dt>
<dd><p class="first last">rotation invariant.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;ror&#8217;: extension of default implementation which is gray scale and</dt>
<dd><p class="first last">rotation invariant.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;uniform&#8217;: improved rotation invariance with uniform patterns and</dt>
<dd><p class="first last">finer quantization of the angular space which is gray scale and
rotation invariant.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;nri_uniform&#8217;: non rotation-invariant uniform patterns variant</dt>
<dd><p class="first last">which is only gray scale invariant [2].</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;var&#8217;: rotation invariant variance measures of the contrast of local</dt>
<dd><p class="first last">image texture which is rotation but not gray scale invariant.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : (N, M) array</p>
<blockquote class="last">
<div><p>LBP image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r146" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id37">[R146]</a></td><td>Multiresolution Gray-Scale and Rotation Invariant Texture
Classification with Local Binary Patterns.
Timo Ojala, Matti Pietikainen, Topi Maenpaa.
<a class="reference external" href="http://www.rafbis.it/biplab15/images/stories/docenti/Danielriccio/">http://www.rafbis.it/biplab15/images/stories/docenti/Danielriccio/</a>           Articoliriferimento/LBP.pdf, 2002.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r147" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id38">[R147]</a></td><td>Face recognition with local binary patterns.
Timo Ahonen, Abdenour Hadid, Matti Pietikainen,
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.214.6851">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.214.6851</a>,
2004.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="match-descriptors">
<h2>match_descriptors<a class="headerlink" href="#match-descriptors" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.match_descriptors">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">match_descriptors</tt><big>(</big><em>descriptors1</em>, <em>descriptors2</em>, <em>metric=None</em>, <em>p=2</em>, <em>max_distance=inf</em>, <em>cross_check=True</em><big>)</big><a class="headerlink" href="#skimage.feature.match_descriptors" title="Permalink to this definition">¶</a></dt>
<dd><p>Brute-force matching of descriptors.</p>
<p>For each descriptor in the first set this matcher finds the closest
descriptor in the second set (and vice-versa in the case of enabled
cross-checking).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>descriptors1</strong> : (M, P) array</p>
<blockquote>
<div><p>Binary descriptors of size P about M keypoints in the first image.</p>
</div></blockquote>
<p><strong>descriptors2</strong> : (N, P) array</p>
<blockquote>
<div><p>Binary descriptors of size P about N keypoints in the second image.</p>
</div></blockquote>
<p><strong>metric</strong> : {&#8216;euclidean&#8217;, &#8216;cityblock&#8217;, &#8216;minkowski&#8217;, &#8216;hamming&#8217;, ...}</p>
<blockquote>
<div><p>The metric to compute the distance between two descriptors. See
<cite>scipy.spatial.distance.cdist</cite> for all possible types. The hamming
distance should be used for binary descriptors. By default the L2-norm
is used for all descriptors of dtype float or double and the Hamming
distance is used for binary descriptors automatically.</p>
</div></blockquote>
<p><strong>p</strong> : int</p>
<blockquote>
<div><p>The p-norm to apply for <tt class="docutils literal"><span class="pre">metric='minkowski'</span></tt>.</p>
</div></blockquote>
<p><strong>max_distance</strong> : float</p>
<blockquote>
<div><p>Maximum allowed distance between descriptors of two keypoints
in separate images to be regarded as a match.</p>
</div></blockquote>
<p><strong>cross_check</strong> : bool</p>
<blockquote>
<div><p>If True, the matched keypoints are returned after cross checking i.e. a
matched pair (keypoint1, keypoint2) is returned if keypoint2 is the
best match for keypoint1 in second image and keypoint1 is the best
match for keypoint2 in first image.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>matches</strong> : (Q, 2) array</p>
<blockquote class="last">
<div><p>Indices of corresponding matches in first and second set of
descriptors, where <tt class="docutils literal"><span class="pre">matches[:,</span> <span class="pre">0]</span></tt> denote the indices in the first
and <tt class="docutils literal"><span class="pre">matches[:,</span> <span class="pre">1]</span></tt> the indices in the second set of descriptors.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="match-template">
<h2>match_template<a class="headerlink" href="#match-template" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.match_template">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">match_template</tt><big>(</big><em>image</em>, <em>template</em>, <em>pad_input=False</em>, <em>mode='constant'</em>, <em>constant_values=0</em><big>)</big><a class="headerlink" href="#skimage.feature.match_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Match a template to a 2-D or 3-D image using normalized correlation.</p>
<p>The output is an array with values between -1.0 and 1.0. The value at a
given position corresponds to the correlation coefficient between the image
and the template.</p>
<p>For <cite>pad_input=True</cite> matches correspond to the center and otherwise to the
top-left corner of the template. To find the best match you must search for
peaks in the response (output) image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : (M, N[, D]) array</p>
<blockquote>
<div><p>2-D or 3-D input image.</p>
</div></blockquote>
<p><strong>template</strong> : (m, n[, d]) array</p>
<blockquote>
<div><p>Template to locate. It must be <cite>(m &lt;= M, n &lt;= N[, d &lt;= D])</cite>.</p>
</div></blockquote>
<p><strong>pad_input</strong> : bool</p>
<blockquote>
<div><p>If True, pad <cite>image</cite> so that output is the same size as the image, and
output values correspond to the template center. Otherwise, the output
is an array with shape <cite>(M - m + 1, N - n + 1)</cite> for an <cite>(M, N)</cite> image
and an <cite>(m, n)</cite> template, and matches correspond to origin
(top-left corner) of the template.</p>
</div></blockquote>
<p><strong>mode</strong> : see <cite>numpy.pad</cite>, optional</p>
<blockquote>
<div><p>Padding mode.</p>
</div></blockquote>
<p><strong>constant_values</strong> : see <cite>numpy.pad</cite>, optional</p>
<blockquote>
<div><p>Constant values used in conjunction with <tt class="docutils literal"><span class="pre">mode='constant'</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : array</p>
<blockquote class="last">
<div><p>Response image with correlation coefficients.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r148" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id39">[R148]</a></td><td>Briechle and Hanebeck, &#8220;Template Matching using Fast Normalized
Cross Correlation&#8221;, Proceedings of the SPIE (2001).</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r149" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id40">[R149]</a></td><td>J. P. Lewis, &#8220;Fast Normalized Cross-Correlation&#8221;, Industrial Light
and Magic.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">template</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">template</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">template</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">match_template</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([[ 1.   , -0.125,  0.   ,  0.   ],</span>
<span class="go">       [-0.125, -0.125,  0.   ,  0.   ],</span>
<span class="go">       [ 0.   ,  0.   ,  0.125,  0.125],</span>
<span class="go">       [ 0.   ,  0.   ,  0.125, -1.   ]], dtype=float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">match_template</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">pad_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([[-0.125, -0.125, -0.125,  0.   ,  0.   ,  0.   ],</span>
<span class="go">       [-0.125,  1.   , -0.125,  0.   ,  0.   ,  0.   ],</span>
<span class="go">       [-0.125, -0.125, -0.125,  0.   ,  0.   ,  0.   ],</span>
<span class="go">       [ 0.   ,  0.   ,  0.   ,  0.125,  0.125,  0.125],</span>
<span class="go">       [ 0.   ,  0.   ,  0.   ,  0.125, -1.   ,  0.125],</span>
<span class="go">       [ 0.   ,  0.   ,  0.   ,  0.125,  0.125,  0.125]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="peak-local-max">
<h2>peak_local_max<a class="headerlink" href="#peak-local-max" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.peak_local_max">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">peak_local_max</tt><big>(</big><em>image</em>, <em>min_distance=10</em>, <em>threshold_abs=0</em>, <em>threshold_rel=0.1</em>, <em>exclude_border=True</em>, <em>indices=True</em>, <em>num_peaks=inf</em>, <em>footprint=None</em>, <em>labels=None</em><big>)</big><a class="headerlink" href="#skimage.feature.peak_local_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Find peaks in an image, and return them as coordinates or a boolean array.</p>
<p>Peaks are the local maxima in a region of <cite>2 * min_distance + 1</cite>
(i.e. peaks are separated by at least <cite>min_distance</cite>).</p>
<p>NOTE: If peaks are flat (i.e. multiple adjacent pixels have identical
intensities), the coordinates of all such pixels are returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray of floats</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>min_distance</strong> : int</p>
<blockquote>
<div><p>Minimum number of pixels separating peaks in a region of <cite>2 *
min_distance + 1</cite> (i.e. peaks are separated by at least
<cite>min_distance</cite>). If <cite>exclude_border</cite> is True, this value also excludes
a border <cite>min_distance</cite> from the image boundary.
To find the maximum number of peaks, use <cite>min_distance=1</cite>.</p>
</div></blockquote>
<p><strong>threshold_abs</strong> : float</p>
<blockquote>
<div><p>Minimum intensity of peaks.</p>
</div></blockquote>
<p><strong>threshold_rel</strong> : float</p>
<blockquote>
<div><p>Minimum intensity of peaks calculated as <cite>max(image) * threshold_rel</cite>.</p>
</div></blockquote>
<p><strong>exclude_border</strong> : bool</p>
<blockquote>
<div><p>If True, <cite>min_distance</cite> excludes peaks from the border of the image as
well as from each other.</p>
</div></blockquote>
<p><strong>indices</strong> : bool</p>
<blockquote>
<div><p>If True, the output will be an array representing peak coordinates.
If False, the output will be a boolean array shaped as <cite>image.shape</cite>
with peaks present at True elements.</p>
</div></blockquote>
<p><strong>num_peaks</strong> : int</p>
<blockquote>
<div><p>Maximum number of peaks. When the number of peaks exceeds <cite>num_peaks</cite>,
return <cite>num_peaks</cite> peaks based on highest peak intensity.</p>
</div></blockquote>
<p><strong>footprint</strong> : ndarray of bools, optional</p>
<blockquote>
<div><p>If provided, <cite>footprint == 1</cite> represents the local region within which
to search for peaks at every point in <cite>image</cite>.  Overrides
<cite>min_distance</cite>, except for border exclusion if <cite>exclude_border=True</cite>.</p>
</div></blockquote>
<p><strong>labels</strong> : ndarray of ints, optional</p>
<blockquote>
<div><p>If provided, each unique region <cite>labels == value</cite> represents a unique
region to search for peaks. Zero is reserved for background.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : ndarray or ndarray of bools</p>
<blockquote class="last">
<div><ul class="simple">
<li>If <cite>indices = True</cite>  : (row, column, ...) coordinates of peaks.</li>
<li>If <cite>indices = False</cite> : Boolean array shaped like <cite>image</cite>, with peaks
represented by True values.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The peak local maximum function returns the coordinates of local peaks
(maxima) in a image. A maximum filter is used for finding local maxima.
This operation dilates the original image. After comparison between
dilated and original image, peak_local_max function returns the
coordinates of peaks where dilated image = original.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">img1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img1</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img1</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img1</span>
<span class="go">array([[ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ],</span>
<span class="go">       [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ],</span>
<span class="go">       [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ],</span>
<span class="go">       [ 0. ,  0. ,  1.5,  0. ,  1. ,  0. ,  0. ],</span>
<span class="go">       [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ],</span>
<span class="go">       [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ],</span>
<span class="go">       [ 0. ,  0. ,  0. ,  0. ,  0. ,  0. ,  0. ]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[3, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[3, 2]])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">img2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img2</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">img2</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">array([[10, 10, 10]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="plot-matches">
<h2>plot_matches<a class="headerlink" href="#plot-matches" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.plot_matches">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">plot_matches</tt><big>(</big><em>ax</em>, <em>image1</em>, <em>image2</em>, <em>keypoints1</em>, <em>keypoints2</em>, <em>matches</em>, <em>keypoints_color='k'</em>, <em>matches_color=None</em>, <em>only_matches=False</em><big>)</big><a class="headerlink" href="#skimage.feature.plot_matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot matched features.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ax</strong> : matplotlib.axes.Axes</p>
<blockquote>
<div><p>Matches and image are drawn in this ax.</p>
</div></blockquote>
<p><strong>image1</strong> : (N, M [, 3]) array</p>
<blockquote>
<div><p>First grayscale or color image.</p>
</div></blockquote>
<p><strong>image2</strong> : (N, M [, 3]) array</p>
<blockquote>
<div><p>Second grayscale or color image.</p>
</div></blockquote>
<p><strong>keypoints1</strong> : (K1, 2) array</p>
<blockquote>
<div><p>First keypoint coordinates as <tt class="docutils literal"><span class="pre">(row,</span> <span class="pre">col)</span></tt>.</p>
</div></blockquote>
<p><strong>keypoints2</strong> : (K2, 2) array</p>
<blockquote>
<div><p>Second keypoint coordinates as <tt class="docutils literal"><span class="pre">(row,</span> <span class="pre">col)</span></tt>.</p>
</div></blockquote>
<p><strong>matches</strong> : (Q, 2) array</p>
<blockquote>
<div><p>Indices of corresponding matches in first and second set of
descriptors, where <tt class="docutils literal"><span class="pre">matches[:,</span> <span class="pre">0]</span></tt> denote the indices in the first
and <tt class="docutils literal"><span class="pre">matches[:,</span> <span class="pre">1]</span></tt> the indices in the second set of descriptors.</p>
</div></blockquote>
<p><strong>keypoints_color</strong> : matplotlib color, optional</p>
<blockquote>
<div><p>Color for keypoint locations.</p>
</div></blockquote>
<p><strong>matches_color</strong> : matplotlib color, optional</p>
<blockquote>
<div><p>Color for lines which connect keypoint matches. By default the
color is chosen randomly.</p>
</div></blockquote>
<p><strong>only_matches</strong> : bool, optional</p>
<blockquote class="last">
<div><p>Whether to only plot matches and not plot the keypoint locations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="structure-tensor">
<h2>structure_tensor<a class="headerlink" href="#structure-tensor" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.structure_tensor">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">structure_tensor</tt><big>(</big><em>image</em>, <em>sigma=1</em>, <em>mode='constant'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.feature.structure_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute structure tensor using sum of squared differences.</p>
<p>The structure tensor A is defined as:</p>
<div class="highlight-python"><div class="highlight"><pre>A = [Axx Axy]
    [Axy Ayy]
</pre></div>
</div>
<p>which is approximated by the weighted sum of squared differences in a local
window around each pixel in the image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>sigma</strong> : float</p>
<blockquote>
<div><p>Standard deviation used for the Gaussian kernel, which is used as a
weighting function for the local summation of squared differences.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;constant&#8217;, &#8216;reflect&#8217;, &#8216;wrap&#8217;, &#8216;nearest&#8217;, &#8216;mirror&#8217;}, optional</p>
<blockquote>
<div><p>How to handle values outside the image borders.</p>
</div></blockquote>
<p><strong>cval</strong> : float, optional</p>
<blockquote>
<div><p>Used in conjunction with mode &#8216;constant&#8217;, the value outside
the image boundaries.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Axx</strong> : ndarray</p>
<blockquote>
<div><p>Element of the structure tensor for each pixel in the input image.</p>
</div></blockquote>
<p><strong>Axy</strong> : ndarray</p>
<blockquote>
<div><p>Element of the structure tensor for each pixel in the input image.</p>
</div></blockquote>
<p><strong>Ayy</strong> : ndarray</p>
<blockquote class="last">
<div><p>Element of the structure tensor for each pixel in the input image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">structure_tensor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Axx</span><span class="p">,</span> <span class="n">Axy</span><span class="p">,</span> <span class="n">Ayy</span> <span class="o">=</span> <span class="n">structure_tensor</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Axx</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.,  1.,  0.],</span>
<span class="go">       [ 0.,  4.,  0.,  4.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="structure-tensor-eigvals">
<h2>structure_tensor_eigvals<a class="headerlink" href="#structure-tensor-eigvals" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.feature.structure_tensor_eigvals">
<tt class="descclassname">skimage.feature.</tt><tt class="descname">structure_tensor_eigvals</tt><big>(</big><em>Axx</em>, <em>Axy</em>, <em>Ayy</em><big>)</big><a class="headerlink" href="#skimage.feature.structure_tensor_eigvals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Eigen values of structure tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Axx</strong> : ndarray</p>
<blockquote>
<div><p>Element of the structure tensor for each pixel in the input image.</p>
</div></blockquote>
<p><strong>Axy</strong> : ndarray</p>
<blockquote>
<div><p>Element of the structure tensor for each pixel in the input image.</p>
</div></blockquote>
<p><strong>Ayy</strong> : ndarray</p>
<blockquote>
<div><p>Element of the structure tensor for each pixel in the input image.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>l1</strong> : ndarray</p>
<blockquote>
<div><p>Larger eigen value for each input matrix.</p>
</div></blockquote>
<p><strong>l2</strong> : ndarray</p>
<blockquote class="last">
<div><p>Smaller eigen value for each input matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">structure_tensor</span><span class="p">,</span> <span class="n">structure_tensor_eigvals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Axx</span><span class="p">,</span> <span class="n">Axy</span><span class="p">,</span> <span class="n">Ayy</span> <span class="o">=</span> <span class="n">structure_tensor</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure_tensor_eigvals</span><span class="p">(</span><span class="n">Axx</span><span class="p">,</span> <span class="n">Axy</span><span class="p">,</span> <span class="n">Ayy</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  2.,  4.,  2.,  0.],</span>
<span class="go">       [ 0.,  4.,  0.,  4.,  0.],</span>
<span class="go">       [ 0.,  2.,  4.,  2.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


        </div>
        <div class="span3"><h4 class="sidebar-box-heading">Navigation</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <li><a href="../index.html">Documentation Home</a></li>
    </ul>
</div>
        <h4 class="sidebar-box-heading">Contents</h4>
        <div class="well sidebar-box toc">
            <ul class="nav nav-list">
<li><a class="reference internal" href="#">Module: <tt class="docutils literal"><span class="pre">feature</span></tt></a><ul class="nav nav-list">
<li><a class="reference internal" href="#brief"><tt class="docutils literal"><span class="pre">BRIEF</span></tt></a></li>
<li><a class="reference internal" href="#censure"><tt class="docutils literal"><span class="pre">CENSURE</span></tt></a></li>
<li><a class="reference internal" href="#orb"><tt class="docutils literal"><span class="pre">ORB</span></tt></a></li>
<li><a class="reference internal" href="#blob-dog">blob_dog</a></li>
<li><a class="reference internal" href="#blob-doh">blob_doh</a></li>
<li><a class="reference internal" href="#blob-log">blob_log</a></li>
<li><a class="reference internal" href="#corner-fast">corner_fast</a></li>
<li><a class="reference internal" href="#corner-foerstner">corner_foerstner</a></li>
<li><a class="reference internal" href="#corner-harris">corner_harris</a></li>
<li><a class="reference internal" href="#corner-kitchen-rosenfeld">corner_kitchen_rosenfeld</a></li>
<li><a class="reference internal" href="#corner-moravec">corner_moravec</a></li>
<li><a class="reference internal" href="#corner-orientations">corner_orientations</a></li>
<li><a class="reference internal" href="#corner-peaks">corner_peaks</a></li>
<li><a class="reference internal" href="#corner-shi-tomasi">corner_shi_tomasi</a></li>
<li><a class="reference internal" href="#corner-subpix">corner_subpix</a></li>
<li><a class="reference internal" href="#daisy">daisy</a></li>
<li><a class="reference internal" href="#greycomatrix">greycomatrix</a></li>
<li><a class="reference internal" href="#greycoprops">greycoprops</a></li>
<li><a class="reference internal" href="#hessian-matrix">hessian_matrix</a></li>
<li><a class="reference internal" href="#hessian-matrix-det">hessian_matrix_det</a></li>
<li><a class="reference internal" href="#hessian-matrix-eigvals">hessian_matrix_eigvals</a></li>
<li><a class="reference internal" href="#hog">hog</a></li>
<li><a class="reference internal" href="#local-binary-pattern">local_binary_pattern</a></li>
<li><a class="reference internal" href="#match-descriptors">match_descriptors</a></li>
<li><a class="reference internal" href="#match-template">match_template</a></li>
<li><a class="reference internal" href="#peak-local-max">peak_local_max</a></li>
<li><a class="reference internal" href="#plot-matches">plot_matches</a></li>
<li><a class="reference internal" href="#structure-tensor">structure_tensor</a></li>
<li><a class="reference internal" href="#structure-tensor-eigvals">structure_tensor_eigvals</a></li>
</ul>
</li>
</ul>

        </div>

<h4 class="sidebar-box-heading">Versions</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <script src="../../dev/_static/docversions.js"></script>
        <script type="text/javascript">
            insert_version_links();
        </script>
    </ul>
</div>
        </div>
    </div>
    <div class="well footer">
        <small>
            &copy; Copyright the scikit-image development team.
            Created using <a href="http://twitter.github.com/bootstrap/">Bootstrap</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.
        </small>
    </div>
</body>
</html>