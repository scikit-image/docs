

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Module: transform &mdash; skimage v0.7.0 docs</title>
    
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../../dev/_static/docversions.js"></script>
    <link rel="top" title="skimage v0.7.0 docs" href="../index.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
          <div class="logo"><a href="http://scikits-image.org">
            <img class="logo" src="../_static/scikits_image_logo_small.png" alt="Logo"/>
          </a></div>
       
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
             
            
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"> 

  
    <h3>Navigation</h3>
    <p>
    <a href="../index.html">Documentation Home</a>
    </p>
    <p>&nbsp;</p>
  
    <h3>Contents</h3>
    <ul>
<li><a class="reference internal" href="#">Module: <tt class="docutils literal"><span class="pre">transform</span></tt></a><ul>
<li><a class="reference internal" href="#affinetransform"><tt class="docutils literal"><span class="pre">AffineTransform</span></tt></a></li>
<li><a class="reference internal" href="#piecewiseaffinetransform"><tt class="docutils literal"><span class="pre">PiecewiseAffineTransform</span></tt></a></li>
<li><a class="reference internal" href="#polynomialtransform"><tt class="docutils literal"><span class="pre">PolynomialTransform</span></tt></a></li>
<li><a class="reference internal" href="#projectivetransform"><tt class="docutils literal"><span class="pre">ProjectiveTransform</span></tt></a></li>
<li><a class="reference internal" href="#similaritytransform"><tt class="docutils literal"><span class="pre">SimilarityTransform</span></tt></a></li>
<li><a class="reference internal" href="#estimate-transform">estimate_transform</a></li>
<li><a class="reference internal" href="#frt2">frt2</a></li>
<li><a class="reference internal" href="#homography">homography</a></li>
<li><a class="reference internal" href="#hough">hough</a></li>
<li><a class="reference internal" href="#ifrt2">ifrt2</a></li>
<li><a class="reference internal" href="#integral-image">integral_image</a></li>
<li><a class="reference internal" href="#integrate">integrate</a></li>
<li><a class="reference internal" href="#iradon">iradon</a></li>
<li><a class="reference internal" href="#probabilistic-hough">probabilistic_hough</a></li>
<li><a class="reference internal" href="#pyramid-expand">pyramid_expand</a></li>
<li><a class="reference internal" href="#pyramid-gaussian">pyramid_gaussian</a></li>
<li><a class="reference internal" href="#pyramid-laplacian">pyramid_laplacian</a></li>
<li><a class="reference internal" href="#pyramid-reduce">pyramid_reduce</a></li>
<li><a class="reference internal" href="#radon">radon</a></li>
<li><a class="reference internal" href="#resize">resize</a></li>
<li><a class="reference internal" href="#rotate">rotate</a></li>
<li><a class="reference internal" href="#swirl">swirl</a></li>
<li><a class="reference internal" href="#warp">warp</a></li>
<li><a class="reference internal" href="#warp-coords">warp_coords</a></li>
</ul>
</li>
</ul>




  <h3>Version</h3>

    <script type="text/javascript">
      insert_version_links();
    </script>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-skimage.transform">
<span id="module-transform"></span><h1>Module: <tt class="xref py py-mod docutils literal"><span class="pre">transform</span></tt><a class="headerlink" href="#module-skimage.transform" title="Permalink to this headline">¶</a></h1>
<div class="section" id="affinetransform">
<h2><a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><tt class="xref py py-class docutils literal"><span class="pre">AffineTransform</span></tt></a><a class="headerlink" href="#affinetransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.AffineTransform">
<em class="property">class </em><tt class="descclassname">skimage.transform.</tt><tt class="descname">AffineTransform</tt><big>(</big><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>shear=None</em>, <em>translation=None</em><big>)</big><a class="headerlink" href="#skimage.transform.AffineTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.transform._geometric.ProjectiveTransform</span></tt></p>
<p>2D affine transformation of the form:</p>
<div class="highlight-python"><pre>X = a0*x + a1*y + a2 =
  = sx*x*cos(rotation) - sy*y*sin(rotation + shear) + a2

Y = b0*x + b1*y + b2 =
  = sx*x*sin(rotation) + sy*y*cos(rotation + shear) + b2</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">sx</span></tt> and <tt class="docutils literal"><span class="pre">sy</span></tt> are zoom factors in the x and y directions,
and the homogeneous transformation matrix is:</p>
<div class="highlight-python"><pre>[[a0  a1  a2]
 [b0  b1  b2]
 [0   0    1]]</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>matrix</strong> : (3, 3) array, optional</p>
<blockquote>
<div><p>Homogeneous transformation matrix.</p>
</div></blockquote>
<p><strong>scale</strong> : (sx, sy) as array, list or tuple, optional</p>
<blockquote>
<div><p>Scale factors.</p>
</div></blockquote>
<p><strong>rotation</strong> : float, optional</p>
<blockquote>
<div><p>Rotation angle in counter-clockwise direction as radians.</p>
</div></blockquote>
<p><strong>shear</strong> : float, optional</p>
<blockquote>
<div><p>Shear angle in counter-clockwise direction as radians.</p>
</div></blockquote>
<p><strong>translation</strong> : (tx, ty) as array, list or tuple, optional</p>
<blockquote class="last">
<div><p>Translation parameters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.AffineTransform.__init__">
<tt class="descname">__init__</tt><big>(</big><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>shear=None</em>, <em>translation=None</em><big>)</big><a class="headerlink" href="#skimage.transform.AffineTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.rotation">
<tt class="descname">rotation</tt><a class="headerlink" href="#skimage.transform.AffineTransform.rotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.scale">
<tt class="descname">scale</tt><a class="headerlink" href="#skimage.transform.AffineTransform.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.shear">
<tt class="descname">shear</tt><a class="headerlink" href="#skimage.transform.AffineTransform.shear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.translation">
<tt class="descname">translation</tt><a class="headerlink" href="#skimage.transform.AffineTransform.translation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="piecewiseaffinetransform">
<h2><a class="reference internal" href="#skimage.transform.PiecewiseAffineTransform" title="skimage.transform.PiecewiseAffineTransform"><tt class="xref py py-class docutils literal"><span class="pre">PiecewiseAffineTransform</span></tt></a><a class="headerlink" href="#piecewiseaffinetransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.PiecewiseAffineTransform">
<em class="property">class </em><tt class="descclassname">skimage.transform.</tt><tt class="descname">PiecewiseAffineTransform</tt><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.transform._geometric.ProjectiveTransform</span></tt></p>
<p>2D piecewise affine transformation.</p>
<p>Control points are used to define the mapping. The transform is based on
a Delaunay triangulation of the points to form a mesh. Each triangle is
used to find a local affine transform.</p>
<dl class="method">
<dt id="skimage.transform.PiecewiseAffineTransform.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.PiecewiseAffineTransform.estimate">
<tt class="descname">estimate</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the control points with which to perform the piecewise mapping.</p>
<p>Number of source and destination coordinates must match.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>src</strong> : (N, 2) array</p>
<blockquote>
<div><p>Source coordinates.</p>
</div></blockquote>
<p><strong>dst</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>Destination coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.PiecewiseAffineTransform.inverse">
<tt class="descname">inverse</tt><big>(</big><em>coords</em><big>)</big><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<p>Coordinates outside of the mesh will be set to <cite>- 1</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>coords</strong> : (N, 2) array</p>
<blockquote>
<div><p>Source coordinates.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>coords</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>Transformed coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="polynomialtransform">
<h2><a class="reference internal" href="#skimage.transform.PolynomialTransform" title="skimage.transform.PolynomialTransform"><tt class="xref py py-class docutils literal"><span class="pre">PolynomialTransform</span></tt></a><a class="headerlink" href="#polynomialtransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.PolynomialTransform">
<em class="property">class </em><tt class="descclassname">skimage.transform.</tt><tt class="descname">PolynomialTransform</tt><big>(</big><em>params=None</em><big>)</big><a class="headerlink" href="#skimage.transform.PolynomialTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.transform._geometric.GeometricTransform</span></tt></p>
<p>2D transformation of the form:</p>
<div class="highlight-python"><pre>X = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i ))
Y = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i ))</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>params</strong> : (2, N) array, optional</p>
<blockquote class="last">
<div><p>Polynomial coefficients where <cite>N * 2 = (order + 1) * (order + 2)</cite>. So,
a_ji is defined in <cite>params[0, :]</cite> and b_ji in <cite>params[1, :]</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.PolynomialTransform.__init__">
<tt class="descname">__init__</tt><big>(</big><em>params=None</em><big>)</big><a class="headerlink" href="#skimage.transform.PolynomialTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.PolynomialTransform.estimate">
<tt class="descname">estimate</tt><big>(</big><em>src</em>, <em>dst</em>, <em>order</em><big>)</big><a class="headerlink" href="#skimage.transform.PolynomialTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the transformation matrix with the explicit transformation
parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-python"><pre>X = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i ))
Y = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i ))</pre>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-python"><pre>0 = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i )) - X
0 = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i )) - Y</pre>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-python"><pre>A   = [[1 x y x**2 x*y y**2 ... 0 ...             0 -X]
       [0 ...                 0 1 x y x**2 x*y y**2 -Y]
        ...
        ...
      ]
x.T = [a00 a10 a11 a20 a21 a22 ... ann
       b00 b10 b11 b20 b21 b22 ... bnn c3]</pre>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>src</strong> : (N, 2) array</p>
<blockquote>
<div><p>Source coordinates.</p>
</div></blockquote>
<p><strong>dst</strong> : (N, 2) array</p>
<blockquote>
<div><p>Destination coordinates.</p>
</div></blockquote>
<p><strong>order</strong> : int</p>
<blockquote class="last">
<div><p>Polynomial order (number of coefficients is order + 1).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.PolynomialTransform.inverse">
<tt class="descname">inverse</tt><big>(</big><em>coords</em><big>)</big><a class="headerlink" href="#skimage.transform.PolynomialTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="projectivetransform">
<h2><a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><tt class="xref py py-class docutils literal"><span class="pre">ProjectiveTransform</span></tt></a><a class="headerlink" href="#projectivetransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.ProjectiveTransform">
<em class="property">class </em><tt class="descclassname">skimage.transform.</tt><tt class="descname">ProjectiveTransform</tt><big>(</big><em>matrix=None</em><big>)</big><a class="headerlink" href="#skimage.transform.ProjectiveTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.transform._geometric.GeometricTransform</span></tt></p>
<p>Matrix transformation.</p>
<p>Apply a projective transformation (homography) on coordinates.</p>
<p>For each homogeneous coordinate <img class="math" src="../_images/math/8800e6ed331cf15ba182031609babfac06216a77.png" alt="\mathbf{x} = [x, y, 1]^T"/>, its
target position is calculated by multiplying with the given matrix,
<img class="math" src="../_images/math/b1902d279ba37d60bdce4e0e987b7cd19d48974e.png" alt="H"/>, to give <img class="math" src="../_images/math/42a03cd1c073037bd9cd9e953d4ab607bb70d4c5.png" alt="H \mathbf{x}"/>:</p>
<div class="highlight-python"><pre>[[a0 a1 a2]
 [b0 b1 b2]
 [c0 c1 1 ]].</pre>
</div>
<p>E.g., to rotate by theta degrees clockwise, the matrix should be:</p>
<div class="highlight-python"><pre>[[cos(theta) -sin(theta) 0]
 [sin(theta)  cos(theta) 0]
 [0            0         1]]</pre>
</div>
<p>or, to translate x by 10 and y by 20:</p>
<div class="highlight-python"><pre>[[1 0 10]
 [0 1 20]
 [0 0 1 ]].</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>matrix</strong> : (3, 3) array, optional</p>
<blockquote class="last">
<div><p>Homogeneous transformation matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.ProjectiveTransform.__init__">
<tt class="descname">__init__</tt><big>(</big><em>matrix=None</em><big>)</big><a class="headerlink" href="#skimage.transform.ProjectiveTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.ProjectiveTransform.estimate">
<tt class="descname">estimate</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#skimage.transform.ProjectiveTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the transformation matrix with the explicit transformation
parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">0</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-python"><pre>A   = [[x y 1 0 0 0 -x*X -y*X -X]
       [0 0 0 x y 1 -x*Y -y*Y -Y]
        ...
        ...
      ]
x.T = [a0 a1 a2 b0 b1 b2 c0 c1 c3]</pre>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<p>In case of the affine transformation the coefficients c0 and c1 are 0.
Thus the system of equations is:</p>
<div class="highlight-python"><pre>A   = [[x y 1 0 0 0 -X]
       [0 0 0 x y 1 -Y]
        ...
        ...
      ]
x.T = [a0 a1 a2 b0 b1 b2 c3]</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>src</strong> : (N, 2) array</p>
<blockquote>
<div><p>Source coordinates.</p>
</div></blockquote>
<p><strong>dst</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>Destination coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.ProjectiveTransform.inverse">
<tt class="descname">inverse</tt><big>(</big><em>coords</em><big>)</big><a class="headerlink" href="#skimage.transform.ProjectiveTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>coords</strong> : (N, 2) array</p>
<blockquote>
<div><p>Source coordinates.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>coords</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>Transformed coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="similaritytransform">
<h2><a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><tt class="xref py py-class docutils literal"><span class="pre">SimilarityTransform</span></tt></a><a class="headerlink" href="#similaritytransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.SimilarityTransform">
<em class="property">class </em><tt class="descclassname">skimage.transform.</tt><tt class="descname">SimilarityTransform</tt><big>(</big><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>translation=None</em><big>)</big><a class="headerlink" href="#skimage.transform.SimilarityTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.transform._geometric.ProjectiveTransform</span></tt></p>
<p>2D similarity transformation of the form:</p>
<div class="highlight-python"><pre>X = a0*x - b0*y + a1 =
  = m*x*cos(rotation) + m*y*sin(rotation) + a1

Y = b0*x + a0*y + b1 =
  = m*x*sin(rotation) + m*y*cos(rotation) + b1</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">m</span></tt> is a zoom factor and the homogeneous transformation matrix is:</p>
<div class="highlight-python"><pre>[[a0  b0  a1]
 [b0  a0  b1]
 [0   0    1]]</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>matrix</strong> : (3, 3) array, optional</p>
<blockquote>
<div><p>Homogeneous transformation matrix.</p>
</div></blockquote>
<p><strong>scale</strong> : float, optional</p>
<blockquote>
<div><p>Scale factor.</p>
</div></blockquote>
<p><strong>rotation</strong> : float, optional</p>
<blockquote>
<div><p>Rotation angle in counter-clockwise direction as radians.</p>
</div></blockquote>
<p><strong>translation</strong> : (tx, ty) as array, list or tuple, optional</p>
<blockquote class="last">
<div><p>x, y translation parameters.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.SimilarityTransform.__init__">
<tt class="descname">__init__</tt><big>(</big><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>translation=None</em><big>)</big><a class="headerlink" href="#skimage.transform.SimilarityTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.SimilarityTransform.estimate">
<tt class="descname">estimate</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#skimage.transform.SimilarityTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the transformation matrix with the explicit parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">b0</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a1</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a0</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b1</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">0</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">b0</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a0</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-python"><pre>A   = [[x 1 -y 0 -X]
       [y 0  x 1 -Y]
        ...
        ...
      ]
x.T = [a0 a1 b0 b1 c3]</pre>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>src</strong> : (N, 2) array</p>
<blockquote>
<div><p>Source coordinates.</p>
</div></blockquote>
<p><strong>dst</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>Destination coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="skimage.transform.SimilarityTransform.rotation">
<tt class="descname">rotation</tt><a class="headerlink" href="#skimage.transform.SimilarityTransform.rotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.SimilarityTransform.scale">
<tt class="descname">scale</tt><a class="headerlink" href="#skimage.transform.SimilarityTransform.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.SimilarityTransform.translation">
<tt class="descname">translation</tt><a class="headerlink" href="#skimage.transform.SimilarityTransform.translation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.estimate_transform" title="skimage.transform.estimate_transform"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.estimate_transform</span></tt></a>(ttype,&nbsp;...)</td>
<td>Estimate 2D geometric transformation parameters.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.frt2</span></tt></a>(a)</td>
<td>Compute the 2-dimensional finite radon transform (FRT) for an n x n</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.homography" title="skimage.transform.homography"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.homography</span></tt></a>(image,&nbsp;H[,&nbsp;...])</td>
<td><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Deprecated in skimage 0.7</p>
</div>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.hough" title="skimage.transform.hough"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.hough</span></tt></a>(img[,&nbsp;theta])</td>
<td>Perform a straight line Hough transform.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.ifrt2</span></tt></a>(a)</td>
<td>Compute the 2-dimensional inverse finite radon transform (iFRT) for</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.integral_image" title="skimage.transform.integral_image"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.integral_image</span></tt></a>(x)</td>
<td>Integral image / summed area table.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.integrate" title="skimage.transform.integrate"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.integrate</span></tt></a>(ii,&nbsp;r0,&nbsp;c0,&nbsp;r1,&nbsp;c1)</td>
<td>Use an integral image to integrate over a given window.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.iradon" title="skimage.transform.iradon"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.iradon</span></tt></a>(radon_image[,&nbsp;...])</td>
<td>Inverse radon transform.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.probabilistic_hough" title="skimage.transform.probabilistic_hough"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.probabilistic_hough</span></tt></a>(img[,&nbsp;...])</td>
<td>Return lines from a progressive probabilistic line Hough transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.pyramid_expand" title="skimage.transform.pyramid_expand"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.pyramid_expand</span></tt></a>(image[,&nbsp;...])</td>
<td>Upsample and then smooth image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.pyramid_gaussian" title="skimage.transform.pyramid_gaussian"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.pyramid_gaussian</span></tt></a>(image[,&nbsp;...])</td>
<td>Yield images of the gaussian pyramid formed by the input image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.pyramid_laplacian" title="skimage.transform.pyramid_laplacian"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.pyramid_laplacian</span></tt></a>(image[,&nbsp;...])</td>
<td>Yield images of the laplacian pyramid formed by the input image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.pyramid_reduce" title="skimage.transform.pyramid_reduce"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.pyramid_reduce</span></tt></a>(image[,&nbsp;...])</td>
<td>Smooth and then downsample image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.radon" title="skimage.transform.radon"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.radon</span></tt></a>(image[,&nbsp;theta])</td>
<td>Calculates the radon transform of an image given specified projection angles.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.resize" title="skimage.transform.resize"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.resize</span></tt></a>(image,&nbsp;output_shape)</td>
<td>Resize image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.rotate" title="skimage.transform.rotate"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.rotate</span></tt></a>(image,&nbsp;angle[,&nbsp;...])</td>
<td>Rotate image by a certain angle around its center.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.swirl" title="skimage.transform.swirl"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.swirl</span></tt></a>(image[,&nbsp;center,&nbsp;...])</td>
<td>Perform a swirl transformation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.warp</span></tt></a>(image[,&nbsp;inverse_map,&nbsp;...])</td>
<td>Warp an image according to a given coordinate transformation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.warp_coords" title="skimage.transform.warp_coords"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.warp_coords</span></tt></a>(coord_map,&nbsp;shape)</td>
<td>Build the source coordinates for the output pixels of an image warp.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="estimate-transform">
<h2>estimate_transform<a class="headerlink" href="#estimate-transform" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.estimate_transform">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">estimate_transform</tt><big>(</big><em>ttype</em>, <em>src</em>, <em>dst</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#skimage.transform.estimate_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate 2D geometric transformation parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>ttype</strong> : {&#8216;similarity&#8217;, &#8216;affine&#8217;, &#8216;piecewise-affine&#8217;, &#8216;projective&#8217;,              &#8216;polynomial&#8217;}</p>
<blockquote>
<div><p>Type of transform.</p>
</div></blockquote>
<p><strong>kwargs</strong> : array or int</p>
<blockquote>
<div><p>Function parameters (src, dst, n, angle):</p>
<div class="highlight-python"><pre>NAME / TTYPE        FUNCTION PARAMETERS
'similarity'        `src, `dst`
'affine'            `src, `dst`
'piecewise-affine'  `src, `dst`
'projective'        `src, `dst`
'polynomial'        `src, `dst`, `order` (polynomial order)</pre>
</div>
<p>Also see examples below.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>tform</strong> : <tt class="xref py py-class docutils literal"><span class="pre">GeometricTransform</span></tt></p>
<blockquote class="last">
<div><p>Transform object containing the transformation parameters and providing
access to forward and inverse transformation functions.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">transform</span> <span class="k">as</span> <span class="n">tf</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># estimate transformation parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">estimate_transform</span><span class="p">(</span><span class="s">&#39;similarity&#39;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">tform</span><span class="p">(</span><span class="n">src</span><span class="p">))</span> <span class="c"># == src</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># warp image using the estimated transformation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">inverse_map</span><span class="o">=</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># create transformation with explicit parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># unite transformations, applied in order from left to right</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform3</span> <span class="o">=</span> <span class="n">tform</span> <span class="o">+</span> <span class="n">tform2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform3</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="c"># == tform2(tform(src))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="frt2">
<h2>frt2<a class="headerlink" href="#frt2" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.frt2">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">frt2</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#skimage.transform.frt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 2-dimensional finite radon transform (FRT) for an n x n
integer array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>a</strong> : array_like</p>
<blockquote>
<div><p>A 2-D square n x n integer array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>FRT</strong> : 2-D ndarray</p>
<blockquote class="last">
<div><p>Finite Radon Transform array of (n+1) x n integer coefficients.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><tt class="xref py py-obj docutils literal"><span class="pre">ifrt2</span></tt></a></dt>
<dd>The two-dimensional inverse FRT.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The FRT has a unique inverse iff n is prime. [FRT]
The idea for this algorithm is due to Vlad Negnevitski.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="frt" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[FRT]</a></td><td>A. Kingston and I. Svalbe, &#8220;Projective transforms on periodic
discrete image arrays,&#8221; in P. Hawkes (Ed), Advances in Imaging
and Electron Physics, 139 (2006)</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Generate a test image:
Use a prime number for the array dimensions</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SIZE</span> <span class="o">=</span> <span class="mi">59</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Finite Radon Transform:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">frt2</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="homography">
<h2>homography<a class="headerlink" href="#homography" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.homography">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">homography</tt><big>(</big><em>image</em>, <em>H</em>, <em>output_shape=None</em>, <em>order=1</em>, <em>mode='constant'</em>, <em>cval=0.0</em><big>)</big><a class="headerlink" href="#skimage.transform.homography" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Deprecated in skimage 0.7
<cite>homography</cite> will be removed in skimage 0.8, it is replaced by
<cite>warp</cite> because the latter provides the same functionality:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ProjectiveTransform</span><span class="p">(</span><span class="n">H</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>Perform a projective transformation (homography) on an image.</p>
<p>For each pixel, given its homogeneous coordinate <img class="math" src="../_images/math/1aa9d7913003fccfc89a3c2961147dac616653a4.png" alt="\mathbf{x}
= [x, y, 1]^T"/>, its target position is calculated by multiplying
with the given matrix, <img class="math" src="../_images/math/b1902d279ba37d60bdce4e0e987b7cd19d48974e.png" alt="H"/>, to give <img class="math" src="../_images/math/42a03cd1c073037bd9cd9e953d4ab607bb70d4c5.png" alt="H \mathbf{x}"/>.
E.g., to rotate by theta degrees clockwise, the matrix should be</p>
<div class="highlight-python"><pre>[[cos(theta) -sin(theta) 0]
 [sin(theta)  cos(theta) 0]
 [0            0         1]]</pre>
</div>
<p>or, to translate x by 10 and y by 20,</p>
<div class="highlight-python"><pre>[[1 0 10]
 [0 1 20]
 [0 0 1 ]].</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>H</strong> : array of shape <tt class="docutils literal"><span class="pre">(3,</span> <span class="pre">3)</span></tt></p>
<blockquote>
<div><p>Transformation matrix H that defines the homography.</p>
</div></blockquote>
<p><strong>output_shape</strong> : tuple (rows, cols)</p>
<blockquote>
<div><p>Shape of the output image generated.</p>
</div></blockquote>
<p><strong>order</strong> : int</p>
<blockquote>
<div><p>Order of splines used in interpolation.</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><p>How to handle values outside the image borders.  Passed as-is
to ndimage.</p>
</div></blockquote>
<p><strong>cval</strong> : string</p>
<blockquote class="last">
<div><p>Used in conjunction with mode &#8216;constant&#8217;, the value outside
the image boundaries.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># rotate by 90 degrees around origin and shift down by 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6],</span>
<span class="go">       [7, 8, 9]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span>             <span class="mi">0</span><span class="p">,</span>            <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x90</span> <span class="o">=</span> <span class="n">homography</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x90</span>
<span class="go">array([[3, 6, 9],</span>
<span class="go">       [2, 5, 8],</span>
<span class="go">       [1, 4, 7]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># translate right by 2 and down by 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[  0,   0,   0,   0,   0],</span>
<span class="go">       [  0, 255,   0,   0,   0],</span>
<span class="go">       [  0,   0,   0,   0,   0],</span>
<span class="go">       [  0,   0,   0,   0,   0],</span>
<span class="go">       [  0,   0,   0,   0,   0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y21</span> <span class="o">=</span> <span class="n">homography</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y21</span>
<span class="go">array([[  0,   0,   0,   0,   0],</span>
<span class="go">       [  0,   0,   0,   0,   0],</span>
<span class="go">       [  0,   0,   0, 255,   0],</span>
<span class="go">       [  0,   0,   0,   0,   0],</span>
<span class="go">       [  0,   0,   0,   0,   0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="hough">
<h2>hough<a class="headerlink" href="#hough" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">hough</tt><big>(</big><em>img</em>, <em>theta=None</em><big>)</big><a class="headerlink" href="#skimage.transform.hough" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a straight line Hough transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>img</strong> : (M, N) ndarray</p>
<blockquote>
<div><p>Input image with nonzero values representing edges.</p>
</div></blockquote>
<p><strong>theta</strong> : 1D ndarray of double</p>
<blockquote>
<div><p>Angles at which to compute the transform, in radians.
Defaults to -pi/2 .. pi/2</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>H</strong> : 2-D ndarray of uint64</p>
<blockquote>
<div><p>Hough transform accumulator.</p>
</div></blockquote>
<p><strong>distances</strong> : ndarray</p>
<blockquote>
<div><p>Distance values.</p>
</div></blockquote>
<p><strong>theta</strong> : ndarray</p>
<blockquote class="last">
<div><p>Angles at which the transform was computed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Generate a test image:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[:,</span> <span class="mi">65</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">45</span><span class="p">,</span> <span class="mi">35</span><span class="p">:</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">90</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.95</span>
</pre></div>
</div>
<p>Apply the Hough transform:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">hough</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">img</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span><span class="p">[:,</span> <span class="mi">65</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">45</span><span class="p">,</span> <span class="mi">35</span><span class="p">:</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">90</span><span class="p">):</span>
    <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.95</span>

<span class="n">out</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">hough</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Input image&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">bone</span><span class="p">,</span>
           <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                   <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Hough transform&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Angle (degree)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Distance (pixel)&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../plots/hough_tf.py">Source code</a>, <a class="reference external" href="../plots/hough_tf.png">png</a>)</p>
<div class="figure">
<img alt="../_images/hough_tf.png" src="../_images/hough_tf.png" />
</div>
</dd></dl>

</div>
<div class="section" id="ifrt2">
<h2>ifrt2<a class="headerlink" href="#ifrt2" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.ifrt2">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">ifrt2</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#skimage.transform.ifrt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 2-dimensional inverse finite radon transform (iFRT) for
an (n+1) x n integer array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>a</strong> : array_like</p>
<blockquote>
<div><p>A 2-D (n+1) row x n column integer array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>iFRT</strong> : 2-D n x n ndarray</p>
<blockquote class="last">
<div><p>Inverse Finite Radon Transform array of n x n integer coefficients.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><tt class="xref py py-obj docutils literal"><span class="pre">frt2</span></tt></a></dt>
<dd>The two-dimensional FRT</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The FRT has a unique inverse iff n is prime.
See <a class="reference internal" href="#r152">[R152]</a> for an overview.
The idea for this algorithm is due to Vlad Negnevitski.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r152" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R152]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>)</em> A. Kingston and I. Svalbe, &#8220;Projective transforms on periodic
discrete image arrays,&#8221; in P. Hawkes (Ed), Advances in Imaging
and Electron Physics, 139 (2006)</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SIZE</span> <span class="o">=</span> <span class="mi">59</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Finite Radon Transform:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">frt2</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Inverse Finite Radon Transform to recover the input</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fi</span> <span class="o">=</span> <span class="n">ifrt2</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Check that it&#8217;s identical to the original</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">img</span><span class="o">-</span><span class="n">fi</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="integral-image">
<h2>integral_image<a class="headerlink" href="#integral-image" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.integral_image">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">integral_image</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#skimage.transform.integral_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Integral image / summed area table.</p>
<p>The integral image contains the sum of all elements above and to the
left of it, i.e.:</p>
<div class="math">
<p><img src="../_images/math/60eb18acdabe921f0fcbc69cf1dfc9fe4934bb1d.png" alt="S[m, n] = \sum_{i \leq m} \sum_{j \leq n} X[i, j]"/></p>
</div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>x</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>S</strong> : ndarray</p>
<blockquote class="last">
<div><p>Integral image / summed area table.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r153" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[R153]</a></td><td>F.C. Crow, &#8220;Summed-area tables for texture mapping,&#8221;
ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="integrate">
<h2>integrate<a class="headerlink" href="#integrate" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.integrate">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">integrate</tt><big>(</big><em>ii</em>, <em>r0</em>, <em>c0</em>, <em>r1</em>, <em>c1</em><big>)</big><a class="headerlink" href="#skimage.transform.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Use an integral image to integrate over a given window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>ii</strong> : ndarray</p>
<blockquote>
<div><p>Integral image.</p>
</div></blockquote>
<p><strong>r0, c0</strong> : int</p>
<blockquote>
<div><p>Top-left corner of block to be summed.</p>
</div></blockquote>
<p><strong>r1, c1</strong> : int</p>
<blockquote>
<div><p>Bottom-right corner of block to be summed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>S</strong> : int</p>
<blockquote class="last">
<div><p>Integral (sum) over the given window.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="iradon">
<h2>iradon<a class="headerlink" href="#iradon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.iradon">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">iradon</tt><big>(</big><em>radon_image</em>, <em>theta=None</em>, <em>output_size=None</em>, <em>filter='ramp'</em>, <em>interpolation='linear'</em><big>)</big><a class="headerlink" href="#skimage.transform.iradon" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse radon transform.</p>
<p>Reconstruct an image from the radon transform, using the filtered
back projection algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>radon_image</strong> : array_like, dtype=float</p>
<blockquote>
<div><p>Image containing radon transform (sinogram). Each column of
the image corresponds to a projection along a different angle.</p>
</div></blockquote>
<p><strong>theta</strong> : array_like, dtype=float, optional</p>
<blockquote>
<div><p>Reconstruction angles (in degrees). Default: m angles evenly spaced
between 0 and 180 (if the shape of <cite>radon_image</cite> is (N, M)).</p>
</div></blockquote>
<p><strong>output_size</strong> : int</p>
<blockquote>
<div><p>Number of rows and columns in the reconstruction.</p>
</div></blockquote>
<p><strong>filter</strong> : str, optional (default ramp)</p>
<blockquote>
<div><p>Filter used in frequency domain filtering. Ramp filter used by default.
Filters available: ramp, shepp-logan, cosine, hamming, hann
Assign None to use no filter.</p>
</div></blockquote>
<p><strong>interpolation</strong> : str, optional (default linear)</p>
<blockquote>
<div><p>Interpolation method used in reconstruction.
Methods available: nearest, linear.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>output</strong> : ndarray</p>
<blockquote class="last">
<div><p>Reconstructed image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>It applies the fourier slice theorem to reconstruct an image by
multiplying the frequency domain of the filter with the FFT of the
projection data. This algorithm is called filtered back projection.</p>
</dd></dl>

</div>
<div class="section" id="probabilistic-hough">
<h2>probabilistic_hough<a class="headerlink" href="#probabilistic-hough" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.probabilistic_hough">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">probabilistic_hough</tt><big>(</big><em>img</em>, <em>threshold=10</em>, <em>line_length=50</em>, <em>line_gap=10</em>, <em>theta=None</em><big>)</big><a class="headerlink" href="#skimage.transform.probabilistic_hough" title="Permalink to this definition">¶</a></dt>
<dd><p>Return lines from a progressive probabilistic line Hough transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>img</strong> : (M, N) ndarray</p>
<blockquote>
<div><p>Input image with nonzero values representing edges.</p>
</div></blockquote>
<p><strong>threshold</strong> : int</p>
<blockquote>
<div><p>Threshold</p>
</div></blockquote>
<p><strong>line_length</strong> : int, optional (default 50)</p>
<blockquote>
<div><p>Minimum accepted length of detected lines.
Increase the parameter to extract longer lines.</p>
</div></blockquote>
<p><strong>line_gap</strong> : int, optional, (default 10)</p>
<blockquote>
<div><p>Maximum gap between pixels to still form a line.
Increase the parameter to merge broken lines more aggresively.</p>
</div></blockquote>
<p><strong>theta</strong> : 1D ndarray, dtype=double, optional, default (-pi/2 .. pi/2)</p>
<blockquote>
<div><p>Angles at which to compute the transform, in radians.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>lines</strong> : list</p>
<blockquote class="last">
<div><p>List of lines identified, lines in format ((x0, y0), (x1, y0)), indicating
line start and end.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r154" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[R154]</a></td><td>C. Galamhos, J. Matas and J. Kittler, &#8220;Progressive probabilistic
Hough transform for line detection&#8221;, in IEEE Computer Society
Conference on Computer Vision and Pattern Recognition, 1999.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="pyramid-expand">
<h2>pyramid_expand<a class="headerlink" href="#pyramid-expand" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_expand">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">pyramid_expand</tt><big>(</big><em>image</em>, <em>upscale=2</em>, <em>sigma=None</em>, <em>order=1</em>, <em>mode='reflect'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.transform.pyramid_expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Upsample and then smooth image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>upscale</strong> : float, optional</p>
<blockquote>
<div><p>Upscale factor.</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote>
<div><p>Sigma for gaussian filter. Default is <cite>2 * upscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the gaussian distribution.</p>
</div></blockquote>
<p><strong>order</strong> : int, optional</p>
<blockquote>
<div><p>Order of splines used in interpolation of upsampling. See
<cite>scipy.ndimage.map_coordinates</cite> for detail.</p>
</div></blockquote>
<p><strong>mode</strong> :  {&#8216;reflect&#8217;, &#8216;constant&#8217;, &#8216;nearest&#8217;, &#8216;mirror&#8217;, &#8216;wrap&#8217;}, optional</p>
<blockquote>
<div><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &#8216;constant&#8217;.</p>
</div></blockquote>
<p><strong>cval</strong> : float, optional</p>
<blockquote>
<div><p>Value to fill past edges of input if mode is &#8216;constant&#8217;.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>out</strong> : array</p>
<blockquote class="last">
<div><p>Upsampled and smoothed float image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>..[1] <a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a></p>
</dd></dl>

</div>
<div class="section" id="pyramid-gaussian">
<h2>pyramid_gaussian<a class="headerlink" href="#pyramid-gaussian" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_gaussian">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">pyramid_gaussian</tt><big>(</big><em>image</em>, <em>max_layer=-1</em>, <em>downscale=2</em>, <em>sigma=None</em>, <em>order=1</em>, <em>mode='reflect'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.transform.pyramid_gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield images of the gaussian pyramid formed by the input image.</p>
<p>Recursively applies the <cite>pyramid_reduce</cite> function to the image, and yields
the downscaled images.</p>
<p>Note that the first image of the pyramid will be the original, unscaled
image. The total number of images is <cite>max_layer + 1</cite>. In case all layers are
computed, the last image is either a one-pixel image or the image where the
reduction does not change its shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>max_layer</strong> : int</p>
<blockquote>
<div><p>Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</div></blockquote>
<p><strong>downscale</strong> : float, optional</p>
<blockquote>
<div><p>Downscale factor.</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote>
<div><p>Sigma for gaussian filter. Default is <cite>2 * downscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the gaussian distribution.</p>
</div></blockquote>
<p><strong>order</strong> : int, optional</p>
<blockquote>
<div><p>Order of splines used in interpolation of downsampling. See
<cite>scipy.ndimage.map_coordinates</cite> for detail.</p>
</div></blockquote>
<p><strong>mode</strong> :  {&#8216;reflect&#8217;, &#8216;constant&#8217;, &#8216;nearest&#8217;, &#8216;mirror&#8217;, &#8216;wrap&#8217;}, optional</p>
<blockquote>
<div><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &#8216;constant&#8217;.</p>
</div></blockquote>
<p><strong>cval</strong> : float, optional</p>
<blockquote>
<div><p>Value to fill past edges of input if mode is &#8216;constant&#8217;.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>pyramid</strong> : generator</p>
<blockquote class="last">
<div><p>Generator yielding pyramid layers as float images.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>..[1] <a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a></p>
</dd></dl>

</div>
<div class="section" id="pyramid-laplacian">
<h2>pyramid_laplacian<a class="headerlink" href="#pyramid-laplacian" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_laplacian">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">pyramid_laplacian</tt><big>(</big><em>image</em>, <em>max_layer=-1</em>, <em>downscale=2</em>, <em>sigma=None</em>, <em>order=1</em>, <em>mode='reflect'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.transform.pyramid_laplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield images of the laplacian pyramid formed by the input image.</p>
<p>Each layer contains the difference between the downsampled and the
downsampled, smoothed image:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">layer</span> <span class="o">=</span> <span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">)</span> <span class="o">-</span> <span class="n">smooth</span><span class="p">(</span><span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that the first image of the pyramid will be the difference between the
original, unscaled image and its smoothed version. The total number of
images is <cite>max_layer + 1</cite>. In case all layers are computed, the last image
is either a one-pixel image or the image where the reduction does not change
its shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>max_layer</strong> : int</p>
<blockquote>
<div><p>Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</div></blockquote>
<p><strong>downscale</strong> : float, optional</p>
<blockquote>
<div><p>Downscale factor.</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote>
<div><p>Sigma for gaussian filter. Default is <cite>2 * downscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the gaussian distribution.</p>
</div></blockquote>
<p><strong>order</strong> : int, optional</p>
<blockquote>
<div><p>Order of splines used in interpolation of downsampling. See
<cite>scipy.ndimage.map_coordinates</cite> for detail.</p>
</div></blockquote>
<p><strong>mode</strong> :  {&#8216;reflect&#8217;, &#8216;constant&#8217;, &#8216;nearest&#8217;, &#8216;mirror&#8217;, &#8216;wrap&#8217;}, optional</p>
<blockquote>
<div><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &#8216;constant&#8217;.</p>
</div></blockquote>
<p><strong>cval</strong> : float, optional</p>
<blockquote>
<div><p>Value to fill past edges of input if mode is &#8216;constant&#8217;.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>pyramid</strong> : generator</p>
<blockquote class="last">
<div><p>Generator yielding pyramid layers as float images.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>..[1] <a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a>
..[2] <a class="reference external" href="http://sepwww.stanford.edu/~morgan/texturematch/paper_html/node3.html">http://sepwww.stanford.edu/~morgan/texturematch/paper_html/node3.html</a></p>
</dd></dl>

</div>
<div class="section" id="pyramid-reduce">
<h2>pyramid_reduce<a class="headerlink" href="#pyramid-reduce" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_reduce">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">pyramid_reduce</tt><big>(</big><em>image</em>, <em>downscale=2</em>, <em>sigma=None</em>, <em>order=1</em>, <em>mode='reflect'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.transform.pyramid_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth and then downsample image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>downscale</strong> : float, optional</p>
<blockquote>
<div><p>Downscale factor.</p>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote>
<div><p>Sigma for gaussian filter. Default is <cite>2 * downscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the gaussian distribution.</p>
</div></blockquote>
<p><strong>order</strong> : int, optional</p>
<blockquote>
<div><p>Order of splines used in interpolation of downsampling. See
<cite>scipy.ndimage.map_coordinates</cite> for detail.</p>
</div></blockquote>
<p><strong>mode</strong> :  {&#8216;reflect&#8217;, &#8216;constant&#8217;, &#8216;nearest&#8217;, &#8216;mirror&#8217;, &#8216;wrap&#8217;}, optional</p>
<blockquote>
<div><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &#8216;constant&#8217;.</p>
</div></blockquote>
<p><strong>cval</strong> : float, optional</p>
<blockquote>
<div><p>Value to fill past edges of input if mode is &#8216;constant&#8217;.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>out</strong> : array</p>
<blockquote class="last">
<div><p>Smoothed and downsampled float image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>..[1] <a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a></p>
</dd></dl>

</div>
<div class="section" id="radon">
<h2>radon<a class="headerlink" href="#radon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.radon">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">radon</tt><big>(</big><em>image</em>, <em>theta=None</em><big>)</big><a class="headerlink" href="#skimage.transform.radon" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the radon transform of an image given specified
projection angles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : array_like, dtype=float</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>theta</strong> : array_like, dtype=float, optional (default np.arange(180))</p>
<blockquote>
<div><p>Projection angles (in degrees).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>output</strong> : ndarray</p>
<blockquote class="last">
<div><p>Radon transform (sinogram).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="resize">
<h2>resize<a class="headerlink" href="#resize" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.resize">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">resize</tt><big>(</big><em>image</em>, <em>output_shape</em>, <em>order=1</em>, <em>mode='constant'</em>, <em>cval=0.0</em><big>)</big><a class="headerlink" href="#skimage.transform.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>output_shape</strong> : tuple or ndarray</p>
<blockquote>
<div><p>Size of the generated output image <cite>(rows, cols)</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>resized</strong> : ndarray</p>
<blockquote class="last">
<div><p>Resized version of the input.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="rotate">
<h2>rotate<a class="headerlink" href="#rotate" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.rotate">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">rotate</tt><big>(</big><em>image</em>, <em>angle</em>, <em>resize=False</em>, <em>order=1</em>, <em>mode='constant'</em>, <em>cval=0.0</em><big>)</big><a class="headerlink" href="#skimage.transform.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate image by a certain angle around its center.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>angle</strong> : float</p>
<blockquote>
<div><p>Rotation angle in degrees in counter-clockwise direction.</p>
</div></blockquote>
<p><strong>resize: bool, optional</strong> :</p>
<blockquote>
<div><p>Determine whether the shape of the output image will be automatically
calculated, so the complete rotated image exactly fits. Default is
False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>rotated</strong> : ndarray</p>
<blockquote class="last">
<div><p>Rotated version of the input.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="swirl">
<h2>swirl<a class="headerlink" href="#swirl" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.swirl">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">swirl</tt><big>(</big><em>image</em>, <em>center=None</em>, <em>strength=1</em>, <em>radius=100</em>, <em>rotation=0</em>, <em>output_shape=None</em>, <em>order=1</em>, <em>mode='constant'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.transform.swirl" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a swirl transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>center</strong> : (x,y) tuple or (2,) ndarray</p>
<blockquote>
<div><p>Center coordinate of transformation.</p>
</div></blockquote>
<p><strong>strength</strong> : float</p>
<blockquote>
<div><p>The amount of swirling applied.</p>
</div></blockquote>
<p><strong>radius</strong> : float</p>
<blockquote>
<div><p>The extent of the swirl in pixels.  The effect dies out
rapidly beyond <cite>radius</cite>.</p>
</div></blockquote>
<p><strong>rotation</strong> : float</p>
<blockquote>
<div><p>Additional rotation applied to the image.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>swirled</strong> : ndarray</p>
<blockquote class="last">
<div><p>Swirled version of the input.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="warp">
<h2>warp<a class="headerlink" href="#warp" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.warp">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">warp</tt><big>(</big><em>image</em>, <em>inverse_map=None</em>, <em>map_args={}</em>, <em>output_shape=None</em>, <em>order=1</em>, <em>mode='constant'</em>, <em>cval=0.0</em>, <em>reverse_map=None</em><big>)</big><a class="headerlink" href="#skimage.transform.warp" title="Permalink to this definition">¶</a></dt>
<dd><p>Warp an image according to a given coordinate transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>inverse_map</strong> : transformation object, callable <tt class="docutils literal"><span class="pre">xy</span> <span class="pre">=</span> <span class="pre">f(xy,</span> <span class="pre">**kwargs)</span></tt></p>
<blockquote>
<div><p>Inverse coordinate map. A function that transforms a (N, 2) array of
<tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></tt> coordinates in the <em>output image</em> into their corresponding
coordinates in the <em>source image</em> (e.g. a transformation object or its
inverse).</p>
</div></blockquote>
<p><strong>map_args</strong> : dict, optional</p>
<blockquote>
<div><p>Keyword arguments passed to <cite>inverse_map</cite>.</p>
</div></blockquote>
<p><strong>output_shape</strong> : tuple (rows, cols)</p>
<blockquote>
<div><p>Shape of the output image generated.</p>
</div></blockquote>
<p><strong>order</strong> : int</p>
<blockquote>
<div><p>Order of splines used in interpolation. See
<cite>scipy.ndimage.map_coordinates</cite> for detail.</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><p>How to handle values outside the image borders.  See
<cite>scipy.ndimage.map_coordinates</cite> for detail.</p>
</div></blockquote>
<p><strong>cval</strong> : float</p>
<blockquote class="last">
<div><p>Used in conjunction with mode &#8216;constant&#8217;, the value outside
the image boundaries.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Shift an image to the right:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_right</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">shift_right</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="warp-coords">
<h2>warp_coords<a class="headerlink" href="#warp-coords" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.warp_coords">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">warp_coords</tt><big>(</big><em>coord_map</em>, <em>shape</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em><big>)</big><a class="headerlink" href="#skimage.transform.warp_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the source coordinates for the output pixels of an image warp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>coord_map</strong> : callable like GeometricTransform.inverse</p>
<blockquote>
<div><p>Return input coordinates for given output coordinates.</p>
</div></blockquote>
<p><strong>shape</strong> : tuple</p>
<blockquote>
<div><p>Shape of output image <tt class="docutils literal"><span class="pre">(rows,</span> <span class="pre">cols[,</span> <span class="pre">bands])</span></tt>.</p>
</div></blockquote>
<p><strong>dtype</strong> : np.dtype or string</p>
<blockquote>
<div><p>dtype for return value (sane choices: float32 or float64).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>coords</strong> : (ndim, rows, cols[, bands]) array of dtype <cite>dtype</cite></p>
<blockquote class="last">
<div><p>Coordinates for <cite>scipy.ndimage.map_coordinates</cite>, that will yield
an image of shape (orows, ocols, bands) by drawing from source
points according to the <cite>coord_transform_fn</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This is a lower-level routine that produces the source coordinates used by
<cite>warp()</cite>.</p>
<p>It is provided separately from <cite>warp</cite> to give additional flexibility to
users who would like, for example, to re-use a particular coordinate
mapping, to use specific dtypes at various points along the the
image-warping process, or to implement different post-processing logic
than <cite>warp</cite> performs after the call to <cite>ndimage.map_coordinates</cite>.</p>
<p class="rubric">Examples</p>
<p>Produce a coordinate map that Shifts an image to the right:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">map_coordinates</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_right</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">lena</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">warp_coords</span><span class="p">(</span><span class="n">shift_right</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped_image</span> <span class="o">=</span> <span class="n">map_coordinates</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="clearer"></div>
    </div>
    </div>

    <div class="footer-wrapper">
      
    <div class="footer">
        &copy; Copyright 2011, the scikits-image team.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
    </div>

  </body>
</html>