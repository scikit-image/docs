

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Module: measure &mdash; skimage v0.7.0 docs</title>
    
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../../dev/_static/docversions.js"></script>
    <link rel="top" title="skimage v0.7.0 docs" href="../index.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
          <div class="logo"><a href="http://scikits-image.org">
            <img class="logo" src="../_static/scikits_image_logo_small.png" alt="Logo"/>
          </a></div>
       
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
             
            
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"> 

  
    <h3>Navigation</h3>
    <p>
    <a href="../index.html">Documentation Home</a>
    </p>
    <p>&nbsp;</p>
  
    <h3>Contents</h3>
    <ul>
<li><a class="reference internal" href="#">Module: <tt class="docutils literal"><span class="pre">measure</span></tt></a><ul>
<li><a class="reference internal" href="#approximate-polygon">approximate_polygon</a></li>
<li><a class="reference internal" href="#find-contours">find_contours</a></li>
<li><a class="reference internal" href="#perimeter">perimeter</a></li>
<li><a class="reference internal" href="#regionprops">regionprops</a></li>
<li><a class="reference internal" href="#structural-similarity">structural_similarity</a></li>
<li><a class="reference internal" href="#subdivide-polygon">subdivide_polygon</a></li>
</ul>
</li>
</ul>




  <h3>Version</h3>

    <script type="text/javascript">
      insert_version_links();
    </script>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-skimage.measure">
<span id="module-measure"></span><h1>Module: <tt class="xref py py-mod docutils literal"><span class="pre">measure</span></tt><a class="headerlink" href="#module-skimage.measure" title="Permalink to this headline">¶</a></h1>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#skimage.measure.approximate_polygon" title="skimage.measure.approximate_polygon"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.measure.approximate_polygon</span></tt></a>(coords,&nbsp;...)</td>
<td>Approximate a polygonal chain with the specified tolerance.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="skimage.measure.find_contours.html#module-skimage.measure.find_contours" title="skimage.measure.find_contours"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.measure.find_contours</span></tt></a>(array,&nbsp;level)</td>
<td>Find iso-valued contours in a 2D array for a given level value.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.measure.perimeter" title="skimage.measure.perimeter"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.measure.perimeter</span></tt></a>(image[,&nbsp;neighbourhood])</td>
<td>Calculate total perimeter of all objects in binary image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.measure.regionprops</span></tt></a>(label_image[,&nbsp;...])</td>
<td>Measure properties of labelled image regions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.measure.structural_similarity" title="skimage.measure.structural_similarity"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.measure.structural_similarity</span></tt></a>(X,&nbsp;Y)</td>
<td>Compute the mean structural similarity index between two images.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.measure.subdivide_polygon" title="skimage.measure.subdivide_polygon"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.measure.subdivide_polygon</span></tt></a>(coords[,&nbsp;...])</td>
<td>Subdivision of polygonal curves using B-Splines.</td>
</tr>
</tbody>
</table>
<div class="section" id="approximate-polygon">
<h2>approximate_polygon<a class="headerlink" href="#approximate-polygon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.approximate_polygon">
<tt class="descclassname">skimage.measure.</tt><tt class="descname">approximate_polygon</tt><big>(</big><em>coords</em>, <em>tolerance</em><big>)</big><a class="headerlink" href="#skimage.measure.approximate_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate a polygonal chain with the specified tolerance.</p>
<p>It is based on the Douglas-Peucker algorithm.</p>
<p>Note that the approximated polygon is always within the convex hull of the
original polygon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>coords</strong> : (N, 2) array</p>
<blockquote>
<div><p>Coordinate array.</p>
</div></blockquote>
<p><strong>tolerance</strong> : float</p>
<blockquote>
<div><p>Maximum distance from original points of polygon to approximated
polygonal chain. If tolerance is 0, the original coordinate array
is returned.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>coords</strong> : (M, 2) array</p>
<blockquote class="last">
<div><p>Approximated polygonal chain where M &lt;= N.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r106" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[R106]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm">http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="find-contours">
<h2>find_contours<a class="headerlink" href="#find-contours" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.find_contours">
<tt class="descclassname">skimage.measure.</tt><tt class="descname">find_contours</tt><big>(</big><em>array</em>, <em>level</em>, <em>fully_connected='low'</em>, <em>positive_orientation='low'</em><big>)</big><a class="headerlink" href="#skimage.measure.find_contours" title="Permalink to this definition">¶</a></dt>
<dd><p>Find iso-valued contours in a 2D array for a given level value.</p>
<p>Uses the &#8220;marching squares&#8221; method to compute a the iso-valued contours of
the input 2D array for a particular level value. Array values are linearly
interpolated to provide better precision for the output contours.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>array</strong> : 2D ndarray of double</p>
<blockquote>
<div><p>Input data in which to find contours.</p>
</div></blockquote>
<p><strong>level</strong> : float</p>
<blockquote>
<div><p>Value along which to find contours in the array.</p>
</div></blockquote>
<p><strong>fully_connected</strong> : str, {&#8216;low&#8217;, &#8216;high&#8217;}</p>
<blockquote>
<div><p>Indicates whether array elements below the given level value are to be
considered fully-connected (and hence elements above the value will
only be face connected), or vice-versa. (See notes below for details.)</p>
</div></blockquote>
<p><strong>positive_orientation</strong> : either &#8216;low&#8217; or &#8216;high&#8217;</p>
<blockquote>
<div><p>Indicates whether the output contours will produce positively-oriented
polygons around islands of low- or high-valued elements. If &#8216;low&#8217; then
contours will wind counter- clockwise around elements below the
iso-value. Alternately, this means that low-valued elements are always
on the left of the contour. (See below for details.)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>contours</strong> : list of (n,2)-ndarrays</p>
<blockquote class="last">
<div><p>Each contour is an ndarray of shape <tt class="docutils literal"><span class="pre">(n,</span> <span class="pre">2)</span></tt>,
consisting of n <tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></tt> coordinates along the contour.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The marching squares algorithm is a special case of the marching cubes
algorithm <a class="reference internal" href="#r107">[R107]</a>.  A simple explanation is available here:</p>
<div class="highlight-python"><pre>http://www.essi.fr/~lingrand/MarchingCubes/algo.html</pre>
</div>
<p>There is a single ambiguous case in the marching squares algorithm: when
a given <tt class="docutils literal"><span class="pre">2</span> <span class="pre">x</span> <span class="pre">2</span></tt>-element square has two high-valued and two low-valued
elements, each pair diagonally adjacent. (Where high- and low-valued is
with respect to the contour value sought.) In this case, either the
high-valued elements can be &#8216;connected together&#8217; via a thin isthmus that
separates the low-valued elements, or vice-versa. When elements are
connected together across a diagonal, they are considered &#8216;fully
connected&#8217; (also known as &#8216;face+vertex-connected&#8217; or &#8216;8-connected&#8217;). Only
high-valued or low-valued elements can be fully-connected, the other set
will be considered as &#8216;face-connected&#8217; or &#8216;4-connected&#8217;. By default,
low-valued elements are considered fully-connected; this can be altered
with the &#8216;fully_connected&#8217; parameter.</p>
<p>Output contours are not guaranteed to be closed: contours which intersect
the array edge will be left open. All other contours will be closed. (The
closed-ness of a contours can be tested by checking whether the beginning
point is the same as the end point.)</p>
<p>Contours are oriented. By default, array values lower than the contour
value are to the left of the contour and values greater than the contour
value are to the right. This means that contours will wind
counter-clockwise (i.e. in &#8216;positive orientation&#8217;) around islands of
low-valued pixels. This behavior can be altered with the
&#8216;positive_orientation&#8217; parameter.</p>
<p>The order of the contours in the output list is determined by the position
of the smallest <tt class="docutils literal"><span class="pre">x,y</span></tt> (in lexicographical order) coordinate in the
contour.  This is a side-effect of how the input array is traversed, but
can be relied upon.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Array coordinates/values are assumed to refer to the <em>center</em> of the
array element. Take a simple example input: <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">1]</span></tt>. The interpolated
position of 0.5 in this array is midway between the 0-element (at
<tt class="docutils literal"><span class="pre">x=0</span></tt>) and the 1-element (at <tt class="docutils literal"><span class="pre">x=1</span></tt>), and thus would fall at
<tt class="docutils literal"><span class="pre">x=0.5</span></tt>.</p>
</div>
<p>This means that to find reasonable contours, it is best to find contours
midway between the expected &#8220;light&#8221; and &#8220;dark&#8221; values. In particular,
given a binarized array, <em>do not</em> choose to find contours at the low or
high value of the array. This will often yield degenerate contours,
especially around structures that are a single array element wide. Instead
choose a middle value, as above.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r107" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R107]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>)</em> Lorensen, William and Harvey E. Cline. Marching Cubes: A High
Resolution 3D Surface Construction Algorithm. Computer Graphics
(SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170).</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="perimeter">
<h2>perimeter<a class="headerlink" href="#perimeter" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.perimeter">
<tt class="descclassname">skimage.measure.</tt><tt class="descname">perimeter</tt><big>(</big><em>image</em>, <em>neighbourhood=4</em><big>)</big><a class="headerlink" href="#skimage.measure.perimeter" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate total perimeter of all objects in binary image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote>
<div><p>binary image</p>
</div></blockquote>
<p><strong>neighbourhood</strong> : 4 or 8, optional</p>
<blockquote>
<div><p>neighbourhood connectivity for border pixel determination, default 4</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>perimeter</strong> : float</p>
<blockquote class="last">
<div><p>total perimeter of all objects in binary image</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r108" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[R108]</a></td><td>K. Benkrid, D. Crookes. Design and FPGA Implementation of
a Perimeter Estimator. The Queen&#8217;s University of Belfast.
<a class="reference external" href="http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc">http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="regionprops">
<h2>regionprops<a class="headerlink" href="#regionprops" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.regionprops">
<tt class="descclassname">skimage.measure.</tt><tt class="descname">regionprops</tt><big>(</big><em>label_image, properties=['Area', 'Centroid'], intensity_image=None</em><big>)</big><a class="headerlink" href="#skimage.measure.regionprops" title="Permalink to this definition">¶</a></dt>
<dd><p>Measure properties of labelled image regions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>label_image</strong> : (N, M) ndarray</p>
<blockquote>
<div><p>Labelled input image.</p>
</div></blockquote>
<p><strong>properties</strong> : {&#8216;all&#8217;, list}</p>
<blockquote>
<div><p>Shape measurements to be determined for each labelled image region.
Default is <cite>[&#8216;Area&#8217;, &#8216;Centroid&#8217;]</cite>. The following properties can be
determined:</p>
<ul>
<li><dl class="first docutils">
<dt>Area <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of pixels of region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>BoundingBox <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Bounding box <cite>(min_row, min_col, max_row, max_col)</cite></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>CentralMoments <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) ndarray</span></dt>
<dd><p class="first">Central moments (translation invariant) up to 3rd order.</p>
<blockquote>
<div><p>mu_ji = sum{ array(x, y) * (x - x_c)^j * (y - y_c)^i }</p>
</div></blockquote>
<p class="last">where the sum is over the <cite>x</cite>, <cite>y</cite> coordinates of the region,
and <cite>x_c</cite> and <cite>y_c</cite> are the coordinates of the region&#8217;s centroid.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Centroid <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Centroid coordinate tuple <cite>(row, col)</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ConvexArea <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of pixels of convex hull image.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ConvexImage <span class="classifier-delimiter">:</span> <span class="classifier">(H, J) ndarray</span></dt>
<dd><p class="first last">Binary convex hull image which has the same size as bounding box.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Coordinates <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) ndarray</span></dt>
<dd><p class="first last">Coordinate list <cite>(row, col)</cite> of the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Eccentricity <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Eccentricity of the ellipse that has the same second-moments as the
region. The eccentricity is the ratio of the distance between its
minor and major axis length. The value is between 0 and 1.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>EquivDiameter <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The diameter of a circle with the same area as the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>EulerNumber <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Euler number of region. Computed as number of objects (= 1)
subtracted by number of holes (8-connectivity).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Extent <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Ratio of pixels in the region to pixels in the total bounding box.
Computed as <cite>Area / (rows*cols)</cite></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>FilledArea <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of pixels of filled region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>FilledImage <span class="classifier-delimiter">:</span> <span class="classifier">(H, J) ndarray</span></dt>
<dd><p class="first last">Binary region image with filled holes which has the same size as
bounding box.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>HuMoments <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Hu moments (translation, scale and rotation invariant).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Image <span class="classifier-delimiter">:</span> <span class="classifier">(H, J) ndarray</span></dt>
<dd><p class="first last">Sliced binary region image which has the same size as bounding box.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>MajorAxisLength <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The length of the major axis of the ellipse that has the same
normalized second central moments as the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>MaxIntensity: float</dt>
<dd><p class="first last">Value with the greatest intensity in the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>MeanIntensity: float</dt>
<dd><p class="first last">Value with the mean intensity in the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>MinIntensity: float</dt>
<dd><p class="first last">Value with the least intensity in the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>MinorAxisLength <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The length of the minor axis of the ellipse that has the same
normalized second central moments as the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Moments <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) ndarray</span></dt>
<dd><p class="first">Spatial moments up to 3rd order.</p>
<blockquote>
<div><p>m_ji = sum{ array(x, y) * x^j * y^i }</p>
</div></blockquote>
<p class="last">where the sum is over the <cite>x</cite>, <cite>y</cite> coordinates of the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>NormalizedMoments <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) ndarray</span></dt>
<dd><p class="first">Normalized moments (translation and scale invariant) up to 3rd
order.</p>
<blockquote>
<div><p>nu_ji = mu_ji / m_00^[(i+j)/2 + 1]</p>
</div></blockquote>
<p class="last">where <cite>m_00</cite> is the zeroth spatial moment.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Orientation <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Angle between the X-axis and the major axis of the ellipse that has
the same second-moments as the region. Ranging from <cite>-pi/2</cite> to
<cite>pi/2</cite> in counter-clockwise direction.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Perimeter <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Perimeter of object which approximates the contour as a line
through the centers of border pixels using a 4-connectivity.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Solidity <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Ratio of pixels in the region to pixels of the convex hull image.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>WeightedCentralMoments <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) ndarray</span></dt>
<dd><p class="first">Central moments (translation invariant) of intensity image up to
3rd order.</p>
<blockquote>
<div><p>wmu_ji = sum{ array(x, y) * (x - x_c)^j * (y - y_c)^i }</p>
</div></blockquote>
<p class="last">where the sum is over the <cite>x</cite>, <cite>y</cite> coordinates of the region,
and <cite>x_c</cite> and <cite>y_c</cite> are the coordinates of the region&#8217;s centroid.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>WeightedCentroid <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Centroid coordinate tuple <cite>(row, col)</cite> weighted with intensity
image.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>WeightedHuMoments <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Hu moments (translation, scale and rotation invariant) of intensity
image.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>WeightedMoments <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) ndarray</span></dt>
<dd><p class="first">Spatial moments of intensity image up to 3rd order.</p>
<blockquote>
<div><p>wm_ji = sum{ array(x, y) * x^j * y^i }</p>
</div></blockquote>
<p class="last">where the sum is over the <cite>x</cite>, <cite>y</cite> coordinates of the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>WeightedNormalizedMoments <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) ndarray</span></dt>
<dd><p class="first">Normalized moments (translation and scale invariant) of intensity
image up to 3rd order.</p>
<blockquote>
<div><p>wnu_ji = wmu_ji / wm_00^[(i+j)/2 + 1]</p>
</div></blockquote>
<p class="last">where <cite>wm_00</cite> is the zeroth spatial moment (intensity-weighted
area).</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p><strong>intensity_image</strong> : (N, M) ndarray, optional</p>
<blockquote>
<div><p>Intensity image with same size as labelled image. Default is None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>properties</strong> : list of dicts</p>
<blockquote class="last">
<div><p>List containing a property dict for each region. The property dicts
contain all the specified properties plus a &#8216;Label&#8217; field.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r109" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[R109]</a></td><td>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r110" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[R110]</a></td><td>B. Jähne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r111" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[R111]</a></td><td>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r112" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[R112]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Image_moment">http://en.wikipedia.org/wiki/Image_moment</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">coins</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">label</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">coins</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">110</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_img</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">label_img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;Centroid&#39;</span><span class="p">]</span> <span class="c"># centroid of first labelled object</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="structural-similarity">
<h2>structural_similarity<a class="headerlink" href="#structural-similarity" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.structural_similarity">
<tt class="descclassname">skimage.measure.</tt><tt class="descname">structural_similarity</tt><big>(</big><em>X</em>, <em>Y</em>, <em>win_size=7</em>, <em>gradient=False</em>, <em>dynamic_range=None</em><big>)</big><a class="headerlink" href="#skimage.measure.structural_similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean structural similarity index between two images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>X, Y</strong> : (N,N) ndarray</p>
<blockquote>
<div><p>Images.</p>
</div></blockquote>
<p><strong>win_size</strong> : int</p>
<blockquote>
<div><p>The side-length of the sliding window used in comparison.  Must
be an odd value.</p>
</div></blockquote>
<p><strong>gradient</strong> : bool</p>
<blockquote>
<div><p>If True, also return the gradient.</p>
</div></blockquote>
<p><strong>dynamic_range</strong> : int</p>
<blockquote>
<div><p>Dynamic range of the input image (distance between minimum and
maximum possible values).  By default, this is estimated from
the image data-type.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>s</strong> : float</p>
<blockquote>
<div><p>Strucutural similarity.</p>
</div></blockquote>
<p><strong>grad</strong> : (N * N,) ndarray</p>
<blockquote class="last">
<div><p>Gradient of the structural similarity index between X and Y.
This is only returned if <cite>gradient</cite> is set to True.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r113" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[R113]</a></td><td>Wang, Z., Bovik, A. C., Sheikh, H. R., &amp; Simoncelli, E. P.
(2004). Image quality assessment: From error visibility to
structural similarity. IEEE Transactions on Image Processing,
13, 600-612.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="subdivide-polygon">
<h2>subdivide_polygon<a class="headerlink" href="#subdivide-polygon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.subdivide_polygon">
<tt class="descclassname">skimage.measure.</tt><tt class="descname">subdivide_polygon</tt><big>(</big><em>coords</em>, <em>degree=2</em>, <em>preserve_ends=False</em><big>)</big><a class="headerlink" href="#skimage.measure.subdivide_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivision of polygonal curves using B-Splines.</p>
<p>Note that the resulting curve is always within the convex hull of the
original polygon. Circular polygons stay closed after subdivision.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>coords</strong> : (N, 2) array</p>
<blockquote>
<div><p>Coordinate array.</p>
</div></blockquote>
<p><strong>degree</strong> : {1, 2, 3, 4, 5, 6, 7}, optional</p>
<blockquote>
<div><p>Degree of B-Spline. Default is 2.</p>
</div></blockquote>
<p><strong>preserve_ends</strong> : bool, optional</p>
<blockquote>
<div><p>Preserve first and last coordinate of non-circular polygon. Default is
False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>coords</strong> : (M, 2) array</p>
<blockquote class="last">
<div><p>Subdivided coordinate array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r114" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[R114]</a></td><td><a class="reference external" href="http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf">http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="clearer"></div>
    </div>
    </div>

    <div class="footer-wrapper">
      
    <div class="footer">
        &copy; Copyright 2011, the scikits-image team.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
    </div>

  </body>
</html>