

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Module: segmentation &mdash; skimage v0.7.0 docs</title>
    
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../../dev/_static/docversions.js"></script>
    <link rel="top" title="skimage v0.7.0 docs" href="../index.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
          <div class="logo"><a href="http://scikits-image.org">
            <img class="logo" src="../_static/scikits_image_logo_small.png" alt="Logo"/>
          </a></div>
       
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
             
            
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"> 

  
    <h3>Navigation</h3>
    <p>
    <a href="../index.html">Documentation Home</a>
    </p>
    <p>&nbsp;</p>
  
    <h3>Contents</h3>
    <ul>
<li><a class="reference internal" href="#">Module: <tt class="docutils literal"><span class="pre">segmentation</span></tt></a><ul>
<li><a class="reference internal" href="#clear-border">clear_border</a></li>
<li><a class="reference internal" href="#felzenszwalb">felzenszwalb</a></li>
<li><a class="reference internal" href="#find-boundaries">find_boundaries</a></li>
<li><a class="reference internal" href="#quickshift">quickshift</a></li>
<li><a class="reference internal" href="#random-walker">random_walker</a></li>
<li><a class="reference internal" href="#slic">slic</a></li>
<li><a class="reference internal" href="#visualize-boundaries">visualize_boundaries</a></li>
</ul>
</li>
</ul>




  <h3>Version</h3>

    <script type="text/javascript">
      insert_version_links();
    </script>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-skimage.segmentation">
<span id="module-segmentation"></span><h1>Module: <tt class="xref py py-mod docutils literal"><span class="pre">segmentation</span></tt><a class="headerlink" href="#module-skimage.segmentation" title="Permalink to this headline">¶</a></h1>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#skimage.segmentation.clear_border" title="skimage.segmentation.clear_border"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.clear_border</span></tt></a>(image[,&nbsp;...])</td>
<td>Clear objects connected to image border.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.segmentation.felzenszwalb" title="skimage.segmentation.felzenszwalb"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.felzenszwalb</span></tt></a>(image[,&nbsp;...])</td>
<td>Computes Felsenszwalb&#8217;s efficient graph based image segmentation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.segmentation.find_boundaries" title="skimage.segmentation.find_boundaries"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.find_boundaries</span></tt></a>(label_img)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.segmentation.quickshift" title="skimage.segmentation.quickshift"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.quickshift</span></tt></a></td>
<td>Segments image using quickshift clustering in Color-(x,y) space.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.segmentation.random_walker" title="skimage.segmentation.random_walker"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.random_walker</span></tt></a>(data,&nbsp;labels)</td>
<td>Random walker algorithm for segmentation from markers, for gray-level or multichannel images.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.segmentation.slic" title="skimage.segmentation.slic"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.slic</span></tt></a></td>
<td>Segments image using k-means clustering in Color-(x,y) space.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.segmentation.visualize_boundaries" title="skimage.segmentation.visualize_boundaries"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.segmentation.visualize_boundaries</span></tt></a>(...)</td>
<td></td>
</tr>
</tbody>
</table>
<div class="section" id="clear-border">
<h2>clear_border<a class="headerlink" href="#clear-border" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.clear_border">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">clear_border</tt><big>(</big><em>image</em>, <em>buffer_size=0</em>, <em>bgval=0</em><big>)</big><a class="headerlink" href="#skimage.segmentation.clear_border" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear objects connected to image border.</p>
<p>The changes will be applied to the input image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : (N, M) array</p>
<blockquote>
<div><p>Binary image.</p>
</div></blockquote>
<p><strong>buffer_size</strong> : int, optional</p>
<blockquote>
<div><p>Define additional buffer around image border.</p>
</div></blockquote>
<p><strong>bgval</strong> : float or int, optional</p>
<blockquote>
<div><p>Value for cleared objects.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>image</strong> : (N, M) array</p>
<blockquote class="last">
<div><p>Cleared binary image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.segmentation</span> <span class="kn">import</span> <span class="n">clear_border</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clear_border</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 1, 1, 1, 1, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="felzenszwalb">
<h2>felzenszwalb<a class="headerlink" href="#felzenszwalb" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.felzenszwalb">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">felzenszwalb</tt><big>(</big><em>image</em>, <em>scale=1</em>, <em>sigma=0.80000000000000004</em>, <em>min_size=20</em><big>)</big><a class="headerlink" href="#skimage.segmentation.felzenszwalb" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes Felsenszwalb&#8217;s efficient graph based image segmentation.</p>
<p>Produces an oversegmentation of a multichannel (i.e. RGB) image
using a fast, minimum spanning tree based clustering on the image grid.
The parameter <tt class="docutils literal"><span class="pre">scale</span></tt> sets an observation level. Higher scale means
less and larger segments. <tt class="docutils literal"><span class="pre">sigma</span></tt> is the diameter of a Gaussian kernel,
used for smoothing the image prior to segmentation.</p>
<p>The number of produced segments as well as their size can only be
controlled indirectly through <tt class="docutils literal"><span class="pre">scale</span></tt>. Segment size within an image can
vary greatly depending on local contrast.</p>
<p>For RGB images, the algorithm computes a separate segmentation for each
channel and then combines these. The combined segmentation is the
intersection of the separate segmentations on the color channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : (width, height, 3) or (width, height) ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>scale</strong> : float</p>
<blockquote>
<div><p>Free parameter. Higher means larger clusters.</p>
</div></blockquote>
<p><strong>sigma</strong> : float</p>
<blockquote>
<div><p>Width of Gaussian kernel used in preprocessing.</p>
</div></blockquote>
<p><strong>min_size</strong> : int</p>
<blockquote>
<div><p>Minimum component size. Enforced using postprocessing.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>segment_mask</strong> : (width, height) ndarray</p>
<blockquote class="last">
<div><p>Integer mask indicating segment labels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r146" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[R146]</a></td><td>Efficient graph-based image segmentation, Felzenszwalb, P.F. and
Huttenlocher, D.P.  International Journal of Computer Vision, 2004</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="find-boundaries">
<h2>find_boundaries<a class="headerlink" href="#find-boundaries" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.find_boundaries">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">find_boundaries</tt><big>(</big><em>label_img</em><big>)</big><a class="headerlink" href="#skimage.segmentation.find_boundaries" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="quickshift">
<h2>quickshift<a class="headerlink" href="#quickshift" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.quickshift">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">quickshift</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.segmentation.quickshift" title="Permalink to this definition">¶</a></dt>
<dd><p>Segments image using quickshift clustering in Color-(x,y) space.</p>
<p>Produces an oversegmentation of the image using the quickshift mode-seeking
algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : (width, height, channels) ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>ratio</strong> : float, between 0 and 1.</p>
<blockquote>
<div><p>Balances color-space proximity and image-space proximity.
Higher values give more weight to color-space.</p>
</div></blockquote>
<p><strong>kernel_size</strong> : float</p>
<blockquote>
<div><p>Width of Gaussian kernel used in smoothing the
sample density. Higher means fewer clusters.</p>
</div></blockquote>
<p><strong>max_dist</strong> : float</p>
<blockquote>
<div><p>Cut-off point for data distances.
Higher means fewer clusters.</p>
</div></blockquote>
<p><strong>return_tree</strong> : bool</p>
<blockquote>
<div><p>Whether to return the full segmentation hierarchy tree and distances.</p>
</div></blockquote>
<p><strong>sigma</strong> : float</p>
<blockquote>
<div><p>Width for Gaussian smoothing as preprocessing. Zero means no smoothing.</p>
</div></blockquote>
<p><strong>convert2lab</strong> : bool</p>
<blockquote>
<div><p>Whether the input should be converted to Lab colorspace prior to
segmentation. For this purpose, the input is assumed to be RGB.</p>
</div></blockquote>
<p><strong>random_seed</strong> : None or int</p>
<blockquote>
<div><p>Random seed used for breaking ties.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>segment_mask</strong> : (width, height) ndarray</p>
<blockquote class="last">
<div><p>Integer mask indicating segment labels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The authors advocate to convert the image to Lab color space prior to
segmentation, though this is not strictly necessary. For this to work, the
image must be given in RGB format.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r147" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[R147]</a></td><td>Quick shift and kernel methods for mode seeking,
Vedaldi, A. and Soatto, S.
European Conference on Computer Vision, 2008</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="random-walker">
<h2>random_walker<a class="headerlink" href="#random-walker" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.random_walker">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">random_walker</tt><big>(</big><em>data</em>, <em>labels</em>, <em>beta=130</em>, <em>mode='bf'</em>, <em>tol=0.001</em>, <em>copy=True</em>, <em>multichannel=False</em>, <em>return_full_prob=False</em>, <em>depth=1.0</em><big>)</big><a class="headerlink" href="#skimage.segmentation.random_walker" title="Permalink to this definition">¶</a></dt>
<dd><p>Random walker algorithm for segmentation from markers, for gray-level or
multichannel images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>data</strong> : array_like</p>
<blockquote>
<div><p>Image to be segmented in phases. Gray-level <cite>data</cite> can be two- or
three-dimensional; multichannel data can be three- or four-
dimensional (multichannel=True) with the highest dimension denoting
channels. Data spacing is assumed isotropic unless depth keyword
argument is used.</p>
</div></blockquote>
<p><strong>labels</strong> : array of ints, of same shape as <cite>data</cite> without channels dimension</p>
<blockquote>
<div><p>Array of seed markers labeled with different positive integers
for different phases. Zero-labeled pixels are unlabeled pixels.
Negative labels correspond to inactive pixels that are not taken
into account (they are removed from the graph). If labels are not
consecutive integers, the labels array will be transformed so that
labels are consecutive. In the multichannel case, <cite>labels</cite> should have
the same shape as a single channel of <cite>data</cite>, i.e. without the final
dimension denoting channels.</p>
</div></blockquote>
<p><strong>beta</strong> : float</p>
<blockquote>
<div><p>Penalization coefficient for the random walker motion
(the greater <cite>beta</cite>, the more difficult the diffusion).</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;bf&#8217;, &#8216;cg_mg&#8217;, &#8216;cg&#8217;} (default: &#8216;bf&#8217;)</p>
<blockquote>
<div><p>Mode for solving the linear system in the random walker
algorithm.</p>
<ul class="simple">
<li>&#8216;bf&#8217; (brute force, default): an LU factorization of the Laplacian is
computed. This is fast for small images (&lt;1024x1024), but very slow
(due to the memory cost) and memory-consuming for big images (in 3-D
for example).</li>
<li>&#8216;cg&#8217; (conjugate gradient): the linear system is solved iteratively
using the Conjugate Gradient method from scipy.sparse.linalg. This is
less memory-consuming than the brute force method for large images,
but it is quite slow.</li>
<li>&#8216;cg_mg&#8217; (conjugate gradient with multigrid preconditioner): a
preconditioner is computed using a multigrid solver, then the
solution is computed with the Conjugate Gradient method.  This mode
requires that the pyamg module (<a class="reference external" href="http://code.google.com/p/pyamg/">http://code.google.com/p/pyamg/</a>) is
installed. For images of size &gt; 512x512, this is the recommended
(fastest) mode.</li>
</ul>
</div></blockquote>
<p><strong>tol</strong> : float</p>
<blockquote>
<div><p>tolerance to achieve when solving the linear system, in
cg&#8217; and &#8216;cg_mg&#8217; modes.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>If copy is False, the <cite>labels</cite> array will be overwritten with
the result of the segmentation. Use copy=False if you want to
save on memory.</p>
</div></blockquote>
<p><strong>multichannel</strong> : bool, default False</p>
<blockquote>
<div><p>If True, input data is parsed as multichannel data (see &#8216;data&#8217; above
for proper input format in this case)</p>
</div></blockquote>
<p><strong>return_full_prob</strong> : bool, default False</p>
<blockquote>
<div><p>If True, the probability that a pixel belongs to each of the labels
will be returned, instead of only the most likely label.</p>
</div></blockquote>
<p><strong>depth</strong> : float, default 1.</p>
<blockquote>
<div><p>Correction for non-isotropic voxel depths in 3D volumes.
Default (1.) implies isotropy.  This factor is derived as follows:
depth = (out-of-plane voxel spacing) / (in-plane voxel spacing), where
in-plane voxel spacing represents the first two spatial dimensions and
out-of-plane voxel spacing represents the third spatial dimension.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>output</strong> : ndarray</p>
<blockquote class="last">
<div><p>If <cite>return_full_prob</cite> is False, array of ints of same shape as <cite>data</cite>,
in which each pixel has been labeled according to the marker that
reached the pixel first by anisotropic diffusion.
If <cite>return_full_prob</cite> is True, array of floats of shape
<cite>(nlabels, data.shape)</cite>. <cite>output[label_nb, i, j]</cite> is the probability
that label <cite>label_nb</cite> reaches the pixel <cite>(i, j)</cite> first.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="skimage.morphology.watershed.html#module-skimage.morphology.watershed" title="skimage.morphology.watershed"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.morphology.watershed</span></tt></a></dt>
<dd>watershed segmentation A segmentation algorithm based on mathematical morphology and &#8220;flooding&#8221; of regions from markers.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Multichannel inputs are scaled with all channel data combined. Ensure all
channels are separately normalized prior to running this algorithm.</p>
<p>The <cite>depth</cite> argument is specifically for certain types of 3-dimensional
volumes which, due to how they were acquired, have different spacing
along in-plane and out-of-plane dimensions. This is commonly encountered
in medical imaging. The <cite>depth</cite> argument corrects gradients calculated
along the third spatial dimension for the otherwise inherent assumption
that all points are equally spaced.</p>
<p>The algorithm was first proposed in <em>Random walks for image
segmentation</em>, Leo Grady, IEEE Trans Pattern Anal Mach Intell.
2006 Nov;28(11):1768-83.</p>
<p>The algorithm solves the diffusion equation at infinite times for
sources placed on markers of each phase in turn. A pixel is labeled with
the phase that has the greatest probability to diffuse first to the pixel.</p>
<p>The diffusion equation is solved by minimizing x.T L x for each phase,
where L is the Laplacian of the weighted graph of the image, and x is
the probability that a marker of the given phase arrives first at a pixel
by diffusion (x=1 on markers of the phase, x=0 on the other markers, and
the other coefficients are looked for). Each pixel is attributed the label
for which it has a maximal value of x. The Laplacian L of the image
is defined as:</p>
<blockquote>
<div><ul class="simple">
<li>L_ii = d_i, the number of neighbors of pixel i (the degree of i)</li>
<li>L_ij = -w_ij if i and j are adjacent pixels</li>
</ul>
</div></blockquote>
<p>The weight w_ij is a decreasing function of the norm of the local gradient.
This ensures that diffusion is easier between pixels of similar values.</p>
<p>When the Laplacian is decomposed into blocks of marked and unmarked
pixels:</p>
<div class="highlight-python"><pre>L = M B.T
    B A</pre>
</div>
<p>with first indices corresponding to marked pixels, and then to unmarked
pixels, minimizing x.T L x for one phase amount to solving:</p>
<div class="highlight-python"><pre>A x = - B x_m</pre>
</div>
<p>where x_m = 1 on markers of the given phase, and 0 on other markers.
This linear system is solved in the algorithm using a direct method for
small images, and an iterative method for larger images.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c">#Marker for first phase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="c">#Marker for second phase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_walker</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], dtype=int32)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="slic">
<h2>slic<a class="headerlink" href="#slic" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.slic">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">slic</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.segmentation.slic" title="Permalink to this definition">¶</a></dt>
<dd><p>Segments image using k-means clustering in Color-(x,y) space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : (width, height, 3) ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>n_segments</strong> : int</p>
<blockquote>
<div><p>The (approximate) number of labels in the segmented output image.</p>
</div></blockquote>
<p><strong>ratio: float</strong> :</p>
<blockquote>
<div><p>Balances color-space proximity and image-space proximity.
Higher values give more weight to color-space.</p>
</div></blockquote>
<p><strong>max_iter</strong> : int</p>
<blockquote>
<div><p>Maximum number of iterations of k-means.</p>
</div></blockquote>
<p><strong>sigma</strong> : float</p>
<blockquote>
<div><p>Width of Gaussian smoothing kernel for preprocessing. Zero means no
smoothing.</p>
</div></blockquote>
<p><strong>convert2lab</strong> : bool</p>
<blockquote>
<div><p>Whether the input should be converted to Lab colorspace prior to
segmentation.  For this purpose, the input is assumed to be RGB. Highly
recommended.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>segment_mask</strong> : (width, height) ndarray</p>
<blockquote class="last">
<div><p>Integer mask indicating segment labels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The image is smoothed using a Gaussian kernel prior to segmentation.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r148" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[R148]</a></td><td>Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi,
Pascal Fua, and Sabine Süsstrunk, SLIC Superpixels Compared to
State-of-the-art Superpixel Methods, TPAMI, May 2012.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.segmentation</span> <span class="kn">import</span> <span class="n">slic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">lena</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">lena</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segments</span> <span class="o">=</span> <span class="n">slic</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">n_segments</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Increasing the ratio parameter yields more square regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segments</span> <span class="o">=</span> <span class="n">slic</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">n_segments</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="visualize-boundaries">
<h2>visualize_boundaries<a class="headerlink" href="#visualize-boundaries" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.segmentation.visualize_boundaries">
<tt class="descclassname">skimage.segmentation.</tt><tt class="descname">visualize_boundaries</tt><big>(</big><em>img</em>, <em>label_img</em><big>)</big><a class="headerlink" href="#skimage.segmentation.visualize_boundaries" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="clearer"></div>
    </div>
    </div>

    <div class="footer-wrapper">
      
    <div class="footer">
        &copy; Copyright 2011, the scikits-image team.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
    </div>

  </body>
</html>