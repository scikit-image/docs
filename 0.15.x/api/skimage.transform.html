


<!DOCTYPE html>
<html lang="en">
<head>
        <title>Module: transform &mdash; skimage v0.15.0 docs</title>
    
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../_static/css/custom.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
        <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    
    <script src="http://code.jquery.com/jquery-latest.js"></script>
    <script src="../_static/js/bootstrap.min.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.15.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <link rel="index" title="Index" href="../genindex.html" />
        <link rel="search" title="Search" href="../search.html" />
        <link rel="top" title="skimage v0.15.0 docs" href="../index.html" />
        <link rel="up" title="API Reference for skimage 0.15.0" href="api.html" />
        <link rel="next" title="Module: util" href="skimage.util.html" />
        <link rel="prev" title="Module: segmentation" href="skimage.segmentation.html" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="shortcut icon" href="../_static/favicon.ico">
</head>
<body class="container">
    <a href="https://scikit-image.org" class="logo"><img src="../_static/img/logo.png" alt=""></a>
    <div class="clearfix"></div>
    <div class="navbar">
        <div class="navbar-inner">
            <ul class="nav">
                <li><a href="/docs/stable/install.html">Download</a></li>
<li><a href="../auto_examples/index.html">Gallery</a></li>
<li><a href="../index.html">Documentation</a></li>
<li><a href="/community_guidelines.html">Community Guidelines</a></li>

<li><a href="https://github.com/scikit-image/scikit-image">
    <img src="../_static/GitHub-Mark-32px.png"
        style="height: 15px; width: 15px;
               display: inline; float: none;
               padding-bottom: 3px;">
    Source</a>
</li>
            </ul>
        </div>
    </div>
    <div class="row">
        <div class="span3"><div style="padding-bottom: 3em">
  <form class="navbar-form pull-right" action="../search.html" method="get">
    <input type="text" class="search span3" name="q" placeholder="Search documentation ...">
    <input type="hidden" name="check_keywords" value="yes" >
    <input type="hidden" name="area" value="default" >
  </form>
</div><!-- 
        <h4 class="sidebar-box-heading">Contents</h4>
        <div class="well sidebar-box toc">
            <ul class="nav nav-list">
<li><a class="reference internal" href="#">Module: <code class="docutils literal notranslate"><span class="pre">transform</span></code></a><ul class="nav nav-list">
<li><a class="reference internal" href="#match-histograms">match_histograms</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-match-histograms">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.match_histograms</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hough-circle">hough_circle</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-hough-circle">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_circle</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hough-ellipse">hough_ellipse</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-hough-ellipse">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_ellipse</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hough-line">hough_line</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-hough-line">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_line</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#probabilistic-hough-line">probabilistic_hough_line</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-probabilistic-hough-line">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.probabilistic_hough_line</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hough-circle-peaks">hough_circle_peaks</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-hough-circle-peaks">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_circle_peaks</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hough-line-peaks">hough_line_peaks</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-hough-line-peaks">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_line_peaks</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#radon">radon</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-radon">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.radon</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#iradon">iradon</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-iradon">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.iradon</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#iradon-sart">iradon_sart</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-iradon-sart">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.iradon_sart</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#order-angles-golden-ratio">order_angles_golden_ratio</a></li>
<li><a class="reference internal" href="#frt2">frt2</a></li>
<li><a class="reference internal" href="#ifrt2">ifrt2</a></li>
<li><a class="reference internal" href="#integral-image">integral_image</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-integral-image">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.integral_image</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#integrate">integrate</a></li>
<li><a class="reference internal" href="#warp">warp</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-warp">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#warp-coords">warp_coords</a></li>
<li><a class="reference internal" href="#estimate-transform">estimate_transform</a></li>
<li><a class="reference internal" href="#matrix-transform">matrix_transform</a></li>
<li><a class="reference internal" href="#swirl">swirl</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-swirl">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.swirl</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#resize">resize</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-resize">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.resize</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#rotate">rotate</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-rotate">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.rotate</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#rescale">rescale</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-rescale">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.rescale</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#downscale-local-mean">downscale_local_mean</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-downscale-local-mean">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.downscale_local_mean</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pyramid-reduce">pyramid_reduce</a></li>
<li><a class="reference internal" href="#pyramid-expand">pyramid_expand</a></li>
<li><a class="reference internal" href="#pyramid-gaussian">pyramid_gaussian</a><ul class="nav nav-list">
<li><a class="reference internal" href="#examples-using-skimage-transform-pyramid-gaussian">Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.pyramid_gaussian</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pyramid-laplacian">pyramid_laplacian</a></li>
<li><a class="reference internal" href="#seam-carve">seam_carve</a></li>
<li><a class="reference internal" href="#euclideantransform"><code class="docutils literal notranslate"><span class="pre">EuclideanTransform</span></code></a></li>
<li><a class="reference internal" href="#similaritytransform"><code class="docutils literal notranslate"><span class="pre">SimilarityTransform</span></code></a></li>
<li><a class="reference internal" href="#affinetransform"><code class="docutils literal notranslate"><span class="pre">AffineTransform</span></code></a></li>
<li><a class="reference internal" href="#projectivetransform"><code class="docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a></li>
<li><a class="reference internal" href="#essentialmatrixtransform"><code class="docutils literal notranslate"><span class="pre">EssentialMatrixTransform</span></code></a></li>
<li><a class="reference internal" href="#fundamentalmatrixtransform"><code class="docutils literal notranslate"><span class="pre">FundamentalMatrixTransform</span></code></a></li>
<li><a class="reference internal" href="#polynomialtransform"><code class="docutils literal notranslate"><span class="pre">PolynomialTransform</span></code></a></li>
<li><a class="reference internal" href="#piecewiseaffinetransform"><code class="docutils literal notranslate"><span class="pre">PiecewiseAffineTransform</span></code></a></li>
</ul>
</li>
</ul>

        </div>


 --><div class="well">
    <strong>Docs for 0.15.0<br></strong>

    <a id="other">All versions</a>

    <ul id="versionList" style="display: none;">
        <script src="../../dev/_static/docversions.js"></script>
        <script type="text/javascript">
            insert_version_links();
        </script>
    </ul>

 </div>

<script type="text/javascript">
	$("#other").click(function() {
		$("#versionList").toggle();
	});
</script>
        </div>
        <div class="span9">
            
  <div class="section" id="module-skimage.transform">
<span id="module-transform"></span><h1>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">transform</span></code><a class="headerlink" href="#module-skimage.transform" title="Permalink to this headline">¶</a></h1>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.match_histograms" title="skimage.transform.match_histograms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.match_histograms</span></code></a>(image,&nbsp;…)</td>
<td>Adjust an image so that its cumulative histogram matches that of another.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.hough_circle" title="skimage.transform.hough_circle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_circle</span></code></a>(image,&nbsp;radius)</td>
<td>Perform a circular Hough transform.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.hough_ellipse" title="skimage.transform.hough_ellipse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_ellipse</span></code></a>(image[,&nbsp;…])</td>
<td>Perform an elliptical Hough transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.hough_line" title="skimage.transform.hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_line</span></code></a>(image[,&nbsp;theta])</td>
<td>Perform a straight line Hough transform.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.probabilistic_hough_line" title="skimage.transform.probabilistic_hough_line"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.probabilistic_hough_line</span></code></a>(image)</td>
<td>Return lines from a progressive probabilistic line Hough transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.hough_circle_peaks" title="skimage.transform.hough_circle_peaks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_circle_peaks</span></code></a>(…[,&nbsp;…])</td>
<td>Return peaks in a circle Hough transform.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.hough_line_peaks" title="skimage.transform.hough_line_peaks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.hough_line_peaks</span></code></a>(hspace,&nbsp;…)</td>
<td>Return peaks in a straight line Hough transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.radon" title="skimage.transform.radon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.radon</span></code></a>(image[,&nbsp;theta,&nbsp;circle])</td>
<td>Calculates the radon transform of an image given specified projection angles.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.iradon" title="skimage.transform.iradon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.iradon</span></code></a>(radon_image[,&nbsp;…])</td>
<td>Inverse radon transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.iradon_sart" title="skimage.transform.iradon_sart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.iradon_sart</span></code></a>(radon_image[,&nbsp;…])</td>
<td>Inverse radon transform</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.order_angles_golden_ratio" title="skimage.transform.order_angles_golden_ratio"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.order_angles_golden_ratio</span></code></a>(theta)</td>
<td>Order angles to reduce the amount of correlated information in subsequent projections.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.frt2</span></code></a>(a)</td>
<td>Compute the 2-dimensional finite radon transform (FRT) for an n x n integer array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.ifrt2</span></code></a>(a)</td>
<td>Compute the 2-dimensional inverse finite radon transform (iFRT) for an (n+1) x n integer array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.integral_image" title="skimage.transform.integral_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.integral_image</span></code></a>(image)</td>
<td>Integral image / summed area table.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.integrate" title="skimage.transform.integrate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.integrate</span></code></a>(ii,&nbsp;start,&nbsp;end)</td>
<td>Use an integral image to integrate over a given window.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code></a>(image,&nbsp;inverse_map[,&nbsp;…])</td>
<td>Warp an image according to a given coordinate transformation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.warp_coords" title="skimage.transform.warp_coords"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.warp_coords</span></code></a>(coord_map,&nbsp;shape)</td>
<td>Build the source coordinates for the output of a 2-D image warp.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.estimate_transform" title="skimage.transform.estimate_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.estimate_transform</span></code></a>(ttype,&nbsp;…)</td>
<td>Estimate 2D geometric transformation parameters.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.matrix_transform" title="skimage.transform.matrix_transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.matrix_transform</span></code></a>(coords,&nbsp;…)</td>
<td>Apply 2D matrix transform.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.swirl" title="skimage.transform.swirl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.swirl</span></code></a>(image[,&nbsp;center,&nbsp;…])</td>
<td>Perform a swirl transformation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.resize" title="skimage.transform.resize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.resize</span></code></a>(image,&nbsp;output_shape)</td>
<td>Resize image to match a certain size.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.rotate" title="skimage.transform.rotate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.rotate</span></code></a>(image,&nbsp;angle[,&nbsp;…])</td>
<td>Rotate image by a certain angle around its center.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.rescale" title="skimage.transform.rescale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.rescale</span></code></a>(image,&nbsp;scale[,&nbsp;…])</td>
<td>Scale image by a certain factor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.downscale_local_mean" title="skimage.transform.downscale_local_mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.downscale_local_mean</span></code></a>(…)</td>
<td>Down-sample N-dimensional image by local averaging.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.pyramid_reduce" title="skimage.transform.pyramid_reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_reduce</span></code></a>(image[,&nbsp;…])</td>
<td>Smooth and then downsample image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.pyramid_expand" title="skimage.transform.pyramid_expand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_expand</span></code></a>(image[,&nbsp;…])</td>
<td>Upsample and then smooth image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.pyramid_gaussian" title="skimage.transform.pyramid_gaussian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_gaussian</span></code></a>(image[,&nbsp;…])</td>
<td>Yield images of the Gaussian pyramid formed by the input image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.pyramid_laplacian" title="skimage.transform.pyramid_laplacian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.pyramid_laplacian</span></code></a>(image[,&nbsp;…])</td>
<td>Yield images of the laplacian pyramid formed by the input image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.seam_carve" title="skimage.transform.seam_carve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.seam_carve</span></code></a>(*args,&nbsp;**kwargs)</td>
<td>Seam carving has been removed because it is a patented algorithm.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.EuclideanTransform" title="skimage.transform.EuclideanTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.EuclideanTransform</span></code></a>([…])</td>
<td>2D Euclidean transformation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.SimilarityTransform</span></code></a>([…])</td>
<td>2D similarity transformation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.AffineTransform</span></code></a>([matrix,&nbsp;…])</td>
<td>2D affine transformation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.ProjectiveTransform</span></code></a>([matrix])</td>
<td>Projective transformation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.EssentialMatrixTransform" title="skimage.transform.EssentialMatrixTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.EssentialMatrixTransform</span></code></a>([…])</td>
<td>Essential matrix transformation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.FundamentalMatrixTransform" title="skimage.transform.FundamentalMatrixTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.FundamentalMatrixTransform</span></code></a>([…])</td>
<td>Fundamental matrix transformation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.transform.PolynomialTransform" title="skimage.transform.PolynomialTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.PolynomialTransform</span></code></a>([params])</td>
<td>2D polynomial transformation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.transform.PiecewiseAffineTransform" title="skimage.transform.PiecewiseAffineTransform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.transform.PiecewiseAffineTransform</span></code></a>()</td>
<td>2D piecewise affine transformation.</td>
</tr>
</tbody>
</table>
<div class="section" id="match-histograms">
<h2>match_histograms<a class="headerlink" href="#match-histograms" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.match_histograms">
<code class="descclassname">skimage.transform.</code><code class="descname">match_histograms</code><span class="sig-paren">(</span><em>image</em>, <em>reference</em>, <em>multichannel=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/histogram_matching.py#L23"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.match_histograms" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust an image so that its cumulative histogram matches that of another.</p>
<p>The adjustment is applied separately for each channel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Input image. Can be gray-scale or in color.</p>
</dd>
<dt><strong>reference</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Image to match histogram of. Must have the same number of channels as
image.</p>
</dd>
<dt><strong>multichannel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Apply the matching separately for each channel.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>matched</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Transformed input image.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong></dt>
<dd><p class="first last">Thrown when the number of channels in the input image and the reference
differ.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r8b243700b8a3-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://paulbourke.net/miscellaneous/equalisation/">http://paulbourke.net/miscellaneous/equalisation/</a></td></tr>
</tbody>
</table>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-match-histograms">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.match_histograms</span></code><a class="headerlink" href="#examples-using-skimage-transform-match-histograms" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the feature of histogram matching. It manipulates the pixels of an in..."><div class="figure" id="id26">
<img alt="../_images/sphx_glr_plot_histogram_matching_thumb.png" src="../_images/sphx_glr_plot_histogram_matching_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/transform/plot_histogram_matching.html#sphx-glr-auto-examples-transform-plot-histogram-matching-py"><span class="std std-ref">Histogram matching</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="hough-circle">
<h2>hough_circle<a class="headerlink" href="#hough-circle" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough_circle">
<code class="descclassname">skimage.transform.</code><code class="descname">hough_circle</code><span class="sig-paren">(</span><em>image</em>, <em>radius</em>, <em>normalize=True</em>, <em>full_output=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/hough_transform.py#L70"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.hough_circle" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a circular Hough transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(M, N) ndarray</span></dt>
<dd><p class="first last">Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar or sequence of scalars</span></dt>
<dd><p class="first last">Radii at which to compute the Hough transform.
Floats are converted to integers.</p>
</dd>
<dt><strong>normalize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional (default True)</span></dt>
<dd><p class="first last">Normalize the accumulator with the number
of pixels used to draw the radius.</p>
</dd>
<dt><strong>full_output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional (default False)</span></dt>
<dd><p class="first last">Extend the output size by twice the largest
radius in order to detect centers outside the
input picture.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3D ndarray (radius index, (M + 2R, N + 2R) ndarray)</span></dt>
<dd><p class="first last">Hough transform accumulator for each radius.
R designates the larger radius if full_output is True.
Otherwise, R = 0.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="k">import</span> <span class="n">hough_circle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="k">import</span> <span class="n">circle_perimeter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">circle_perimeter</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">try_radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">hough_circle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">try_radii</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ridx</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">res</span><span class="p">),</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">try_radii</span><span class="p">[</span><span class="n">ridx</span><span class="p">]</span>
<span class="go">(25, 35, 23)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-hough-circle">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_circle</span></code><a class="headerlink" href="#examples-using-skimage-transform-hough-circle" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a `method to detect straight lines &lt;https://en.wiki..."><div class="figure" id="id27">
<img alt="../_images/sphx_glr_plot_circular_elliptical_hough_transform_thumb.png" src="../_images/sphx_glr_plot_circular_elliptical_hough_transform_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/edges/plot_circular_elliptical_hough_transform.html#sphx-glr-auto-examples-edges-plot-circular-elliptical-hough-transform-py"><span class="std std-ref">Circular and Elliptical Hough Transforms</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="hough-ellipse">
<h2>hough_ellipse<a class="headerlink" href="#hough-ellipse" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough_ellipse">
<code class="descclassname">skimage.transform.</code><code class="descname">hough_ellipse</code><span class="sig-paren">(</span><em>image</em>, <em>threshold=4</em>, <em>accuracy=1</em>, <em>min_size=4</em>, <em>max_size=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/hough_transform.py#L114"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.hough_ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an elliptical Hough transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(M, N) ndarray</span></dt>
<dd><p class="first last">Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>threshold: int, optional</strong></dt>
<dd><p class="first last">Accumulator threshold value.</p>
</dd>
<dt><strong>accuracy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">double, optional</span></dt>
<dd><p class="first last">Bin size on the minor axis used in the accumulator.</p>
</dd>
<dt><strong>min_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Minimal major axis length.</p>
</dd>
<dt><strong>max_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximal minor axis length.
If None, the value is set to the half of the smaller
image dimension.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray with fields [(accumulator, yc, xc, a, b, orientation)].</span></dt>
<dd><p class="first last">Where <code class="docutils literal notranslate"><span class="pre">(yc,</span> <span class="pre">xc)</span></code> is the center, <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code> the major and minor
axes, respectively. The <cite>orientation</cite> value follows
<cite>skimage.draw.ellipse_perimeter</cite> convention.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The accuracy must be chosen to produce a peak in the accumulator
distribution. In other words, a flat accumulator distribution with low
values may be caused by a too low bin size.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rf2ef66e2ec1f-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Xie, Yonghong, and Qiang Ji. “A new efficient ellipse detection
method.” Pattern Recognition, 2002. Proceedings. 16th International
Conference on. Vol. 2. IEEE, 2002</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="k">import</span> <span class="n">hough_ellipse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="k">import</span> <span class="n">ellipse_perimeter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">ellipse_perimeter</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">cc</span><span class="p">,</span> <span class="n">rr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">hough_ellipse</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[(10, 10.0, 10.0, 8.0, 6.0, 0.0)]</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-hough-ellipse">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_ellipse</span></code><a class="headerlink" href="#examples-using-skimage-transform-hough-ellipse" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a `method to detect straight lines &lt;https://en.wiki..."><div class="figure" id="id28">
<img alt="../_images/sphx_glr_plot_circular_elliptical_hough_transform_thumb.png" src="../_images/sphx_glr_plot_circular_elliptical_hough_transform_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/edges/plot_circular_elliptical_hough_transform.html#sphx-glr-auto-examples-edges-plot-circular-elliptical-hough-transform-py"><span class="std std-ref">Circular and Elliptical Hough Transforms</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="hough-line">
<h2>hough_line<a class="headerlink" href="#hough-line" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough_line">
<code class="descclassname">skimage.transform.</code><code class="descname">hough_line</code><span class="sig-paren">(</span><em>image</em>, <em>theta=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/hough_transform.py#L166"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.hough_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a straight line Hough transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(M, N) ndarray</span></dt>
<dd><p class="first last">Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray of double, optional</span></dt>
<dd><p class="first last">Angles at which to compute the transform, in radians.
Defaults to a vector of 180 angles evenly spaced from -pi/2 to pi/2.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>hspace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2-D ndarray of uint64</span></dt>
<dd><p class="first last">Hough transform accumulator.</p>
</dd>
<dt><strong>angles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Angles at which the transform is computed, in radians.</p>
</dd>
<dt><strong>distances</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Distance values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The origin is the top left corner of the original image.
X and Y axis are horizontal and vertical edges respectively.
The distance is the minimal algebraic distance from the origin
to the detected line.
The angle accuracy can be improved by decreasing the step size in
the <cite>theta</cite> array.</p>
<p class="rubric">Examples</p>
<p>Generate a test image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[:,</span> <span class="mi">65</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">45</span><span class="p">,</span> <span class="mi">35</span><span class="p">:</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">90</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.95</span>
</pre></div>
</div>
<p>Apply the Hough transform:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">hough_line</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough_line</span>
<span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="kn">import</span> <span class="n">line</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">img</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span><span class="p">[:,</span> <span class="mi">65</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">45</span><span class="p">,</span> <span class="mi">35</span><span class="p">:</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">line</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">img</span><span class="p">[</span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.95</span>

<span class="n">out</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">hough_line</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

<span class="n">fix</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Input image&#39;</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span>
    <span class="n">out</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">bone</span><span class="p">,</span>
    <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Hough transform&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Angle (degree)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Distance (pixel)&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../plots/hough_tf.py">Source code</a>)</p>
<div class="figure">
<img alt="../_images/hough_tf.png" src="../_images/hough_tf.png" />
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-hough-line">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_line</span></code><a class="headerlink" href="#examples-using-skimage-transform-hough-line" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a method to detect straight lines [1]_."><div class="figure" id="id29">
<img alt="../_images/sphx_glr_plot_line_hough_transform_thumb.png" src="../_images/sphx_glr_plot_line_hough_transform_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/edges/plot_line_hough_transform.html#sphx-glr-auto-examples-edges-plot-line-hough-transform-py"><span class="std std-ref">Straight line Hough transform</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="probabilistic-hough-line">
<h2>probabilistic_hough_line<a class="headerlink" href="#probabilistic-hough-line" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.probabilistic_hough_line">
<code class="descclassname">skimage.transform.</code><code class="descname">probabilistic_hough_line</code><span class="sig-paren">(</span><em>image</em>, <em>threshold=10</em>, <em>line_length=50</em>, <em>line_gap=10</em>, <em>theta=None</em>, <em>seed=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/hough_transform.py#L224"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.probabilistic_hough_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Return lines from a progressive probabilistic line Hough transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(M, N) ndarray</span></dt>
<dd><p class="first last">Input image with nonzero values representing edges.</p>
</dd>
<dt><strong>threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Threshold</p>
</dd>
<dt><strong>line_length</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Minimum accepted length of detected lines.
Increase the parameter to extract longer lines.</p>
</dd>
<dt><strong>line_gap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum gap between pixels to still form a line.
Increase the parameter to merge broken lines more aggressively.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D ndarray, dtype=double, optional</span></dt>
<dd><p class="first last">Angles at which to compute the transform, in radians.
If None, use a range from -pi/2 to pi/2.</p>
</dd>
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Seed to initialize the random number generator.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>lines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of lines identified, lines in format ((x0, y0), (x1, y1)),
indicating line start and end.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rd9a46cdb16bc-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>C. Galamhos, J. Matas and J. Kittler, “Progressive probabilistic
Hough transform for line detection”, in IEEE Computer Society
Conference on Computer Vision and Pattern Recognition, 1999.</td></tr>
</tbody>
</table>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-probabilistic-hough-line">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.probabilistic_hough_line</span></code><a class="headerlink" href="#examples-using-skimage-transform-probabilistic-hough-line" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a method to detect straight lines [1]_."><div class="figure" id="id30">
<img alt="../_images/sphx_glr_plot_line_hough_transform_thumb.png" src="../_images/sphx_glr_plot_line_hough_transform_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/edges/plot_line_hough_transform.html#sphx-glr-auto-examples-edges-plot-line-hough-transform-py"><span class="std std-ref">Straight line Hough transform</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="hough-circle-peaks">
<h2>hough_circle_peaks<a class="headerlink" href="#hough-circle-peaks" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough_circle_peaks">
<code class="descclassname">skimage.transform.</code><code class="descname">hough_circle_peaks</code><span class="sig-paren">(</span><em>hspaces</em>, <em>radii</em>, <em>min_xdistance=1</em>, <em>min_ydistance=1</em>, <em>threshold=None</em>, <em>num_peaks=inf</em>, <em>total_num_peaks=inf</em>, <em>normalize=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/hough_transform.py#L269"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.hough_circle_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return peaks in a circle Hough transform.</p>
<p>Identifies most prominent circles separated by certain distances in a
Hough space. Non-maximum suppression with different sizes is applied
separately in the first and second dimension of the Hough space to
identify peaks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>hspaces</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, M) array</span></dt>
<dd><p class="first last">Hough spaces returned by the <cite>hough_circle</cite> function.</p>
</dd>
<dt><strong>radii</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(M,) array</span></dt>
<dd><p class="first last">Radii corresponding to Hough spaces.</p>
</dd>
<dt><strong>min_xdistance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Minimum distance separating centers in the x dimension.</p>
</dd>
<dt><strong>min_ydistance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Minimum distance separating centers in the y dimension.</p>
</dd>
<dt><strong>threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Minimum intensity of peaks in each Hough space.
Default is <cite>0.5 * max(hspace)</cite>.</p>
</dd>
<dt><strong>num_peaks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum number of peaks in each Hough space. When the
number of peaks exceeds <cite>num_peaks</cite>, only <cite>num_peaks</cite>
coordinates based on peak intensity are considered for the
corresponding radius.</p>
</dd>
<dt><strong>total_num_peaks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum number of peaks. When the number of peaks exceeds <cite>num_peaks</cite>,
return <cite>num_peaks</cite> coordinates based on peak intensity.</p>
</dd>
<dt><strong>normalize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If True, normalize the accumulator by the radius to sort the prominent
peaks.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>accum, cx, cy, rad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of array</span></dt>
<dd><p class="first last">Peak values in Hough space, x and y center coordinates and radii.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="k">import</span> <span class="n">transform</span><span class="p">,</span> <span class="n">draw</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">120</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">radius</span><span class="p">,</span> <span class="n">x_0</span><span class="p">,</span> <span class="n">y_0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">draw</span><span class="o">.</span><span class="n">circle_perimeter</span><span class="p">(</span><span class="n">y_0</span><span class="p">,</span> <span class="n">x_0</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hspaces</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">hough_circle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">accum</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">rad</span> <span class="o">=</span> <span class="n">hough_circle_peaks</span><span class="p">(</span><span class="n">hspaces</span><span class="p">,</span> <span class="p">[</span><span class="n">radius</span><span class="p">,])</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-hough-circle-peaks">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_circle_peaks</span></code><a class="headerlink" href="#examples-using-skimage-transform-hough-circle-peaks" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a `method to detect straight lines &lt;https://en.wiki..."><div class="figure" id="id31">
<img alt="../_images/sphx_glr_plot_circular_elliptical_hough_transform_thumb.png" src="../_images/sphx_glr_plot_circular_elliptical_hough_transform_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/edges/plot_circular_elliptical_hough_transform.html#sphx-glr-auto-examples-edges-plot-circular-elliptical-hough-transform-py"><span class="std std-ref">Circular and Elliptical Hough Transforms</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="hough-line-peaks">
<h2>hough_line_peaks<a class="headerlink" href="#hough-line-peaks" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough_line_peaks">
<code class="descclassname">skimage.transform.</code><code class="descname">hough_line_peaks</code><span class="sig-paren">(</span><em>hspace</em>, <em>angles</em>, <em>dists</em>, <em>min_distance=9</em>, <em>min_angle=10</em>, <em>threshold=None</em>, <em>num_peaks=inf</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/hough_transform.py#L8"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.hough_line_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Return peaks in a straight line Hough transform.</p>
<p>Identifies most prominent lines separated by a certain angle and distance
in a Hough transform. Non-maximum suppression with different sizes is
applied separately in the first (distances) and second (angles) dimension
of the Hough space to identify peaks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>hspace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, M) array</span></dt>
<dd><p class="first last">Hough space returned by the <cite>hough_line</cite> function.</p>
</dd>
<dt><strong>angles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(M,) array</span></dt>
<dd><p class="first last">Angles returned by the <cite>hough_line</cite> function. Assumed to be continuous.
(<cite>angles[-1] - angles[0] == PI</cite>).</p>
</dd>
<dt><strong>dists</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, ) array</span></dt>
<dd><p class="first last">Distances returned by the <cite>hough_line</cite> function.</p>
</dd>
<dt><strong>min_distance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Minimum distance separating lines (maximum filter size for first
dimension of hough space).</p>
</dd>
<dt><strong>min_angle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Minimum angle separating lines (maximum filter size for second
dimension of hough space).</p>
</dd>
<dt><strong>threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Minimum intensity of peaks. Default is <cite>0.5 * max(hspace)</cite>.</p>
</dd>
<dt><strong>num_peaks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum number of peaks. When the number of peaks exceeds <cite>num_peaks</cite>,
return <cite>num_peaks</cite> coordinates based on peak intensity.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>accum, angles, dists</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of array</span></dt>
<dd><p class="first last">Peak values in Hough space, angles and distances.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="k">import</span> <span class="n">hough_line</span><span class="p">,</span> <span class="n">hough_line_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.draw</span> <span class="k">import</span> <span class="n">line</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">line</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rr</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">line</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="n">cc</span><span class="p">,</span> <span class="n">rr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hspace</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dists</span> <span class="o">=</span> <span class="n">hough_line</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hspace</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dists</span> <span class="o">=</span> <span class="n">hough_line_peaks</span><span class="p">(</span><span class="n">hspace</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">dists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-hough-line-peaks">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.hough_line_peaks</span></code><a class="headerlink" href="#examples-using-skimage-transform-hough-line-peaks" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="The Hough transform in its simplest form is a method to detect straight lines [1]_."><div class="figure" id="id32">
<img alt="../_images/sphx_glr_plot_line_hough_transform_thumb.png" src="../_images/sphx_glr_plot_line_hough_transform_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/edges/plot_line_hough_transform.html#sphx-glr-auto-examples-edges-plot-line-hough-transform-py"><span class="std std-ref">Straight line Hough transform</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="radon">
<h2>radon<a class="headerlink" href="#radon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.radon">
<code class="descclassname">skimage.transform.</code><code class="descname">radon</code><span class="sig-paren">(</span><em>image</em>, <em>theta=None</em>, <em>circle=True</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/radon_transform.py#L12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.radon" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the radon transform of an image given specified
projection angles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, dtype=float</span></dt>
<dd><p class="first last">Input image. The rotation axis will be located in the pixel with
indices <code class="docutils literal notranslate"><span class="pre">(image.shape[0]</span> <span class="pre">//</span> <span class="pre">2,</span> <span class="pre">image.shape[1]</span> <span class="pre">//</span> <span class="pre">2)</span></code>.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, dtype=float, optional</span></dt>
<dd><p class="first last">Projection angles (in degrees). If <cite>None</cite>, the value is set to
np.arange(180).</p>
</dd>
<dt><strong>circle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">Assume image is zero outside the inscribed circle, making the
width of each projection (the first dimension of the sinogram)
equal to <code class="docutils literal notranslate"><span class="pre">min(image.shape)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>radon_image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Radon transform (sinogram).  The tomography rotation axis will lie
at the pixel index <code class="docutils literal notranslate"><span class="pre">radon_image.shape[0]</span> <span class="pre">//</span> <span class="pre">2</span></code> along the 0th
dimension of <code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Based on code of Justin K. Romberg
(<a class="reference external" href="https://www.clear.rice.edu/elec431/projects96/DSP/bpanalysis.html">https://www.clear.rice.edu/elec431/projects96/DSP/bpanalysis.html</a>)</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r0eb755fc1fae-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[1]</a></td><td>AC Kak, M Slaney, “Principles of Computerized Tomographic
Imaging”, IEEE Press 1988.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r0eb755fc1fae-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td>B.R. Ramesh, N. Srinivasa, K. Rajgopal, “An Algorithm for Computing
the Discrete Radon Transform With Some Applications”, Proceedings of
the Fourth IEEE Region 10 International Conference, TENCON ‘89, 1989</td></tr>
</tbody>
</table>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-radon">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.radon</span></code><a class="headerlink" href="#examples-using-skimage-transform-radon" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="In computed tomography, the tomography reconstruction problem is to obtain a tomographic slice ..."><div class="figure" id="id33">
<img alt="../_images/sphx_glr_plot_radon_transform_thumb.png" src="../_images/sphx_glr_plot_radon_transform_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/transform/plot_radon_transform.html#sphx-glr-auto-examples-transform-plot-radon-transform-py"><span class="std std-ref">Radon transform</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="iradon">
<h2>iradon<a class="headerlink" href="#iradon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.iradon">
<code class="descclassname">skimage.transform.</code><code class="descname">iradon</code><span class="sig-paren">(</span><em>radon_image</em>, <em>theta=None</em>, <em>output_size=None</em>, <em>filter='ramp'</em>, <em>interpolation='linear'</em>, <em>circle=True</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/radon_transform.py#L121"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.iradon" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse radon transform.</p>
<p>Reconstruct an image from the radon transform, using the filtered
back projection algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radon_image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, dtype=float</span></dt>
<dd><p class="first last">Image containing radon transform (sinogram). Each column of
the image corresponds to a projection along a different angle. The
tomography rotation axis should lie at the pixel index
<code class="docutils literal notranslate"><span class="pre">radon_image.shape[0]</span> <span class="pre">//</span> <span class="pre">2</span></code> along the 0th dimension of
<code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like, dtype=float, optional</span></dt>
<dd><p class="first last">Reconstruction angles (in degrees). Default: m angles evenly spaced
between 0 and 180 (if the shape of <cite>radon_image</cite> is (N, M)).</p>
</dd>
<dt><strong>output_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of rows and columns in the reconstruction.</p>
</dd>
<dt><strong>filter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Filter used in frequency domain filtering. Ramp filter used by default.
Filters available: ramp, shepp-logan, cosine, hamming, hann.
Assign None to use no filter.</p>
</dd>
<dt><strong>interpolation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Interpolation method used in reconstruction. Methods available:
‘linear’, ‘nearest’, and ‘cubic’ (‘cubic’ is slow).</p>
</dd>
<dt><strong>circle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, optional</span></dt>
<dd><p class="first last">Assume the reconstructed image is zero outside the inscribed circle.
Also changes the default output_size to match the behaviour of
<code class="docutils literal notranslate"><span class="pre">radon</span></code> called with <code class="docutils literal notranslate"><span class="pre">circle=True</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>reconstructed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Reconstructed image. The rotation axis will be located in the pixel
with indices
<code class="docutils literal notranslate"><span class="pre">(reconstructed.shape[0]</span> <span class="pre">//</span> <span class="pre">2,</span> <span class="pre">reconstructed.shape[1]</span> <span class="pre">//</span> <span class="pre">2)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>It applies the Fourier slice theorem to reconstruct an image by
multiplying the frequency domain of the filter with the FFT of the
projection data. This algorithm is called filtered back projection.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r19c92af887b5-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[1]</a></td><td>AC Kak, M Slaney, “Principles of Computerized Tomographic
Imaging”, IEEE Press 1988.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r19c92af887b5-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[2]</a></td><td>B.R. Ramesh, N. Srinivasa, K. Rajgopal, “An Algorithm for Computing
the Discrete Radon Transform With Some Applications”, Proceedings of
the Fourth IEEE Region 10 International Conference, TENCON ‘89, 1989</td></tr>
</tbody>
</table>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-iradon">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.iradon</span></code><a class="headerlink" href="#examples-using-skimage-transform-iradon" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="In computed tomography, the tomography reconstruction problem is to obtain a tomographic slice ..."><div class="figure" id="id34">
<img alt="../_images/sphx_glr_plot_radon_transform_thumb.png" src="../_images/sphx_glr_plot_radon_transform_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/transform/plot_radon_transform.html#sphx-glr-auto-examples-transform-plot-radon-transform-py"><span class="std std-ref">Radon transform</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="iradon-sart">
<h2>iradon_sart<a class="headerlink" href="#iradon-sart" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.iradon_sart">
<code class="descclassname">skimage.transform.</code><code class="descname">iradon_sart</code><span class="sig-paren">(</span><em>radon_image</em>, <em>theta=None</em>, <em>image=None</em>, <em>projection_shifts=None</em>, <em>clip=None</em>, <em>relaxation=0.15</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/radon_transform.py#L318"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.iradon_sart" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse radon transform</p>
<p>Reconstruct an image from the radon transform, using a single iteration of
the Simultaneous Algebraic Reconstruction Technique (SART) algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radon_image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2D array, dtype=float</span></dt>
<dd><p class="first last">Image containing radon transform (sinogram). Each column of
the image corresponds to a projection along a different angle. The
tomography rotation axis should lie at the pixel index
<code class="docutils literal notranslate"><span class="pre">radon_image.shape[0]</span> <span class="pre">//</span> <span class="pre">2</span></code> along the 0th dimension of
<code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array, dtype=float, optional</span></dt>
<dd><p class="first last">Reconstruction angles (in degrees). Default: m angles evenly spaced
between 0 and 180 (if the shape of <cite>radon_image</cite> is (N, M)).</p>
</dd>
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2D array, dtype=float, optional</span></dt>
<dd><p class="first last">Image containing an initial reconstruction estimate. Shape of this
array should be <code class="docutils literal notranslate"><span class="pre">(radon_image.shape[0],</span> <span class="pre">radon_image.shape[0])</span></code>. The
default is an array of zeros.</p>
</dd>
<dt><strong>projection_shifts</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array, dtype=float, optional</span></dt>
<dd><p class="first last">Shift the projections contained in <code class="docutils literal notranslate"><span class="pre">radon_image</span></code> (the sinogram) by
this many pixels before reconstructing the image. The i’th value
defines the shift of the i’th column of <code class="docutils literal notranslate"><span class="pre">radon_image</span></code>.</p>
</dd>
<dt><strong>clip</strong> <span class="classifier-delimiter">:</span> <span class="classifier">length-2 sequence of floats, optional</span></dt>
<dd><p class="first last">Force all values in the reconstructed tomogram to lie in the range
<code class="docutils literal notranslate"><span class="pre">[clip[0],</span> <span class="pre">clip[1]]</span></code></p>
</dd>
<dt><strong>relaxation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Relaxation parameter for the update step. A higher value can
improve the convergence rate, but one runs the risk of instabilities.
Values close to or higher than 1 are not recommended.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>reconstructed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Reconstructed image. The rotation axis will be located in the pixel
with indices
<code class="docutils literal notranslate"><span class="pre">(reconstructed.shape[0]</span> <span class="pre">//</span> <span class="pre">2,</span> <span class="pre">reconstructed.shape[1]</span> <span class="pre">//</span> <span class="pre">2)</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Algebraic Reconstruction Techniques are based on formulating the tomography
reconstruction problem as a set of linear equations. Along each ray,
the projected value is the sum of all the values of the cross section along
the ray. A typical feature of SART (and a few other variants of algebraic
techniques) is that it samples the cross section at equidistant points
along the ray, using linear interpolation between the pixel values of the
cross section. The resulting set of linear equations are then solved using
a slightly modified Kaczmarz method.</p>
<p>When using SART, a single iteration is usually sufficient to obtain a good
reconstruction. Further iterations will tend to enhance high-frequency
information, but will also often increase the noise.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r5a4015ea6a92-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[1]</a></td><td>AC Kak, M Slaney, “Principles of Computerized Tomographic
Imaging”, IEEE Press 1988.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r5a4015ea6a92-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[2]</a></td><td>AH Andersen, AC Kak, “Simultaneous algebraic reconstruction
technique (SART): a superior implementation of the ART algorithm”,
Ultrasonic Imaging 6 pp 81–94 (1984)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r5a4015ea6a92-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[3]</a></td><td>S Kaczmarz, “Angenäherte auflösung von systemen linearer
gleichungen”, Bulletin International de l’Academie Polonaise des
Sciences et des Lettres 35 pp 355–357 (1937)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r5a4015ea6a92-4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[4]</a></td><td>Kohler, T. “A projection access scheme for iterative
reconstruction based on the golden section.” Nuclear Science
Symposium Conference Record, 2004 IEEE. Vol. 6. IEEE, 2004.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r5a4015ea6a92-5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[5]</a></td><td>Kaczmarz’ method, Wikipedia,
<a class="reference external" href="https://en.wikipedia.org/wiki/Kaczmarz_method">https://en.wikipedia.org/wiki/Kaczmarz_method</a></td></tr>
</tbody>
</table>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-iradon-sart">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.iradon_sart</span></code><a class="headerlink" href="#examples-using-skimage-transform-iradon-sart" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="In computed tomography, the tomography reconstruction problem is to obtain a tomographic slice ..."><div class="figure" id="id35">
<img alt="../_images/sphx_glr_plot_radon_transform_thumb.png" src="../_images/sphx_glr_plot_radon_transform_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/transform/plot_radon_transform.html#sphx-glr-auto-examples-transform-plot-radon-transform-py"><span class="std std-ref">Radon transform</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="order-angles-golden-ratio">
<h2>order_angles_golden_ratio<a class="headerlink" href="#order-angles-golden-ratio" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.order_angles_golden_ratio">
<code class="descclassname">skimage.transform.</code><code class="descname">order_angles_golden_ratio</code><span class="sig-paren">(</span><em>theta</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/radon_transform.py#L260"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.order_angles_golden_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Order angles to reduce the amount of correlated information
in subsequent projections.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array of floats</span></dt>
<dd><p class="first last">Projection angles in degrees. Duplicate angles are not allowed.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>indices_generator</strong> <span class="classifier-delimiter">:</span> <span class="classifier">generator yielding unsigned integers</span></dt>
<dd><p class="first last">The returned generator yields indices into <code class="docutils literal notranslate"><span class="pre">theta</span></code> such that
<code class="docutils literal notranslate"><span class="pre">theta[indices]</span></code> gives the approximate golden ratio ordering
of the projections. In total, <code class="docutils literal notranslate"><span class="pre">len(theta)</span></code> indices are yielded.
All non-negative integers &lt; <code class="docutils literal notranslate"><span class="pre">len(theta)</span></code> are yielded exactly once.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The method used here is that of the golden ratio introduced
by T. Kohler.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r88d6c0557044-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[1]</a></td><td>Kohler, T. “A projection access scheme for iterative
reconstruction based on the golden section.” Nuclear Science
Symposium Conference Record, 2004 IEEE. Vol. 6. IEEE, 2004.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r88d6c0557044-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[2]</a></td><td>Winkelmann, Stefanie, et al. “An optimal radial profile order
based on the Golden Ratio for time-resolved MRI.”
Medical Imaging, IEEE Transactions on 26.1 (2007): 68-76.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="frt2">
<h2>frt2<a class="headerlink" href="#frt2" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.frt2">
<code class="descclassname">skimage.transform.</code><code class="descname">frt2</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/finite_radon_transform.py#L12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.frt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 2-dimensional finite radon transform (FRT) for an n x n
integer array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">A 2-D square n x n integer array.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>FRT</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2-D ndarray</span></dt>
<dd><p class="first last">Finite Radon Transform array of (n+1) x n integer coefficients.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ifrt2</span></code></a></dt>
<dd>The two-dimensional inverse FRT.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The FRT has a unique inverse if and only if n is prime. [FRT]
The idea for this algorithm is due to Vlad Negnevitski.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rdb433381c1a5-frt" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[FRT]</a></td><td>A. Kingston and I. Svalbe, “Projective transforms on periodic
discrete image arrays,” in P. Hawkes (Ed), Advances in Imaging
and Electron Physics, 139 (2006)</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Generate a test image:
Use a prime number for the array dimensions</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SIZE</span> <span class="o">=</span> <span class="mi">59</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Finite Radon Transform:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">frt2</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="ifrt2">
<h2>ifrt2<a class="headerlink" href="#ifrt2" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.ifrt2">
<code class="descclassname">skimage.transform.</code><code class="descname">ifrt2</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/finite_radon_transform.py#L71"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.ifrt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 2-dimensional inverse finite radon transform (iFRT) for
an (n+1) x n integer array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">A 2-D (n+1) row x n column integer array.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>iFRT</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2-D n x n ndarray</span></dt>
<dd><p class="first last">Inverse Finite Radon Transform array of n x n integer coefficients.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frt2</span></code></a></dt>
<dd>The two-dimensional FRT</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The FRT has a unique inverse if and only if n is prime.
See <a class="reference internal" href="#r3b76f892cb20-1" id="id16">[1]</a> for an overview.
The idea for this algorithm is due to Vlad Negnevitski.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r3b76f892cb20-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id16">1</a>, <a class="fn-backref" href="#id17">2</a>)</em> A. Kingston and I. Svalbe, “Projective transforms on periodic
discrete image arrays,” in P. Hawkes (Ed), Advances in Imaging
and Electron Physics, 139 (2006)</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SIZE</span> <span class="o">=</span> <span class="mi">59</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Finite Radon Transform:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">frt2</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Inverse Finite Radon Transform to recover the input</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fi</span> <span class="o">=</span> <span class="n">ifrt2</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Check that it’s identical to the original</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">img</span><span class="o">-</span><span class="n">fi</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="integral-image">
<h2>integral_image<a class="headerlink" href="#integral-image" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.integral_image">
<code class="descclassname">skimage.transform.</code><code class="descname">integral_image</code><span class="sig-paren">(</span><em>image</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/integral.py#L7"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.integral_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Integral image / summed area table.</p>
<p>The integral image contains the sum of all elements above and to the
left of it, i.e.:</p>
<div class="math notranslate nohighlight">
\[S[m, n] = \sum_{i \leq m} \sum_{j \leq n} X[i, j]\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Input image.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Integral image/summed area table of same shape as input image.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rd91ebd979f08-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[1]</a></td><td>F.C. Crow, “Summed-area tables for texture mapping,”
ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.</td></tr>
</tbody>
</table>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-integral-image">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.integral_image</span></code><a class="headerlink" href="#examples-using-skimage-transform-integral-image" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to compute multi-block local binary pattern (MB-LBP) features as well as..."><div class="figure" id="id36">
<img alt="../_images/sphx_glr_plot_multiblock_local_binary_pattern_thumb.png" src="../_images/sphx_glr_plot_multiblock_local_binary_pattern_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/features_detection/plot_multiblock_local_binary_pattern.html#sphx-glr-auto-examples-features-detection-plot-multiblock-local-binary-pattern-py"><span class="std std-ref">Multi-Block Local Binary Pattern for texture classification</span></a></span></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Haar-like feature descriptors were successfully used to implement the first real-time face dete..."><div class="figure" id="id37">
<img alt="../_images/sphx_glr_plot_haar_extraction_selection_classification_thumb.png" src="../_images/sphx_glr_plot_haar_extraction_selection_classification_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_haar_extraction_selection_classification.html#sphx-glr-auto-examples-applications-plot-haar-extraction-selection-classification-py"><span class="std std-ref">Face classification using Haar-like feature descriptor</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="integrate">
<h2>integrate<a class="headerlink" href="#integrate" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.integrate">
<code class="descclassname">skimage.transform.</code><code class="descname">integrate</code><span class="sig-paren">(</span><em>ii</em>, <em>start</em>, <em>end</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/integral.py#L39"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Use an integral image to integrate over a given window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ii</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Integral image.</p>
</dd>
<dt><strong>start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List of tuples, each tuple of length equal to dimension of <cite>ii</cite></span></dt>
<dd><p class="first last">Coordinates of top left corner of window(s).
Each tuple in the list contains the starting row, col, … index
i.e <cite>[(row_win1, col_win1, …), (row_win2, col_win2,…), …]</cite>.</p>
</dd>
<dt><strong>end</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List of tuples, each tuple of length equal to dimension of <cite>ii</cite></span></dt>
<dd><p class="first last">Coordinates of bottom right corner of window(s).
Each tuple in the list containing the end row, col, … index i.e
<cite>[(row_win1, col_win1, …), (row_win2, col_win2, …), …]</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar or ndarray</span></dt>
<dd><p class="first last">Integral (sum) over the given window(s).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii</span> <span class="o">=</span> <span class="n">integral_image</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># sum from (1, 0) to (1, 2)</span>
<span class="go">array([ 3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>  <span class="c1"># sum from (3, 3) to (4, 5)</span>
<span class="go">array([ 6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># sum from (1, 0) to (1, 2) and from (3, 3) to (4, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>
<span class="go">array([ 3.,  6.])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="warp">
<h2>warp<a class="headerlink" href="#warp" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.warp">
<code class="descclassname">skimage.transform.</code><code class="descname">warp</code><span class="sig-paren">(</span><em>image</em>, <em>inverse_map</em>, <em>map_args={}</em>, <em>output_shape=None</em>, <em>order=1</em>, <em>mode='constant'</em>, <em>cval=0.0</em>, <em>clip=True</em>, <em>preserve_range=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_warps.py#L676"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.warp" title="Permalink to this definition">¶</a></dt>
<dd><p>Warp an image according to a given coordinate transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Input image.</p>
</dd>
<dt><strong>inverse_map</strong> <span class="classifier-delimiter">:</span> <span class="classifier">transformation object, callable <code class="docutils literal notranslate"><span class="pre">cr</span> <span class="pre">=</span> <span class="pre">f(cr,</span> <span class="pre">**kwargs)</span></code>, or ndarray</span></dt>
<dd><p class="first">Inverse coordinate map, which transforms coordinates in the output
images into their corresponding coordinates in the input image.</p>
<p>There are a number of different options to define this map, depending
on the dimensionality of the input image. A 2-D image can have 2
dimensions for gray-scale images, or 3 dimensions with color
information.</p>
<blockquote>
<div><ul class="simple">
<li>For 2-D images, you can directly pass a transformation object,
e.g. <cite>skimage.transform.SimilarityTransform</cite>, or its inverse.</li>
<li>For 2-D images, you can pass a <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3)</span></code> homogeneous
transformation matrix, e.g.
<cite>skimage.transform.SimilarityTransform.params</cite>.</li>
<li>For 2-D images, a function that transforms a <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">2)</span></code> array of
<code class="docutils literal notranslate"><span class="pre">(col,</span> <span class="pre">row)</span></code> coordinates in the output image to their
corresponding coordinates in the input image. Extra parameters to
the function can be specified through <cite>map_args</cite>.</li>
<li>For N-D images, you can directly pass an array of coordinates.
The first dimension specifies the coordinates in the input image,
while the subsequent dimensions determine the position in the
output image. E.g. in case of 2-D images, you need to pass an array
of shape <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">rows,</span> <span class="pre">cols)</span></code>, where <cite>rows</cite> and <cite>cols</cite> determine the
shape of the output image, and the first dimension contains the
<code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> coordinate in the input image.
See <cite>scipy.ndimage.map_coordinates</cite> for further documentation.</li>
</ul>
</div></blockquote>
<p>Note, that a <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3)</span></code> matrix is interpreted as a homogeneous
transformation matrix, so you cannot interpolate values from a 3-D
input, if the output is of shape <code class="docutils literal notranslate"><span class="pre">(3,)</span></code>.</p>
<p class="last">See example section for usage.</p>
</dd>
<dt><strong>map_args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first last">Keyword arguments passed to <cite>inverse_map</cite>.</p>
</dd>
<dt><strong>output_shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple (rows, cols), optional</span></dt>
<dd><p class="first last">Shape of the output image generated. By default the shape of the input
image is preserved.  Note that, even for multi-band images, only rows
and columns need to be specified.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><dl class="first last docutils">
<dt>The order of interpolation. The order has to be in the range 0-5:</dt>
<dd><ul class="first last simple">
<li>0: Nearest-neighbor</li>
<li>1: Bi-linear (default)</li>
<li>2: Bi-quadratic</li>
<li>3: Bi-cubic</li>
<li>4: Bi-quartic</li>
<li>5: Bi-quintic</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt>
<dd><p class="first last">Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <cite>numpy.pad</cite>.</p>
</dd>
<dt><strong>cval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>warped</strong> <span class="classifier-delimiter">:</span> <span class="classifier">double ndarray</span></dt>
<dd><p class="first last">The warped input image.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ul class="simple">
<li>The input image is converted to a <cite>double</cite> image.</li>
<li>In case of a <cite>SimilarityTransform</cite>, <cite>AffineTransform</cite> and
<cite>ProjectiveTransform</cite> and <cite>order</cite> in [0, 3] this function uses the
underlying transformation matrix to warp the image with a much faster
routine.</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="k">import</span> <span class="n">warp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="k">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
</pre></div>
</div>
<p>The following image warps are all equal but differ substantially in
execution time. The image is shifted to the bottom.</p>
<p>Use a geometric transform to warp an image (fast):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="k">import</span> <span class="n">SimilarityTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">tform</span><span class="p">)</span>
</pre></div>
</div>
<p>Use a callable (slow):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_down</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">shift_down</span><span class="p">)</span>
</pre></div>
</div>
<p>Use a transformation matrix to warp an image (fast):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="k">import</span> <span class="n">ProjectiveTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ProjectiveTransform</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="p">))</span>
</pre></div>
</div>
<p>You can also use the inverse of a geometric transformation (fast):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span>
</pre></div>
</div>
<p>For N-D images you can pass a coordinate array, that specifies the
coordinates in the input image for every element in the output image. E.g.
if you want to rescale a 3-D cube, you can do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cube_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">cube_shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Setup the coordinate array, that defines the scaling:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">cube_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords0</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coords0</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span><span class="p">])</span>
</pre></div>
</div>
<p>Assume that the cube contains spatial data, where the first array element
center is at coordinate (0.5, 0.5, 0.5) in real space, i.e. we have to
account for this extra offset when scaling the image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-warp">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.warp</span></code><a class="headerlink" href="#examples-using-skimage-transform-warp" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to use the Piecewise Affine Transformation."><div class="figure" id="id38">
<img alt="../_images/sphx_glr_plot_piecewise_affine_thumb.png" src="../_images/sphx_glr_plot_piecewise_affine_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/transform/plot_piecewise_affine.html#sphx-glr-auto-examples-transform-plot-piecewise-affine-py"><span class="std std-ref">Piecewise Affine Transformation</span></a></span></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this simplified example we first generate two synthetic images as if they were taken from di..."><div class="figure" id="id39">
<img alt="../_images/sphx_glr_plot_matching_thumb.png" src="../_images/sphx_glr_plot_matching_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/transform/plot_matching.html#sphx-glr-auto-examples-transform-plot-matching-py"><span class="std std-ref">Robust matching using RANSAC</span></a></span></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Detect corner points using the Harris corner detector and determine the subpixel position of co..."><div class="figure" id="id40">
<img alt="../_images/sphx_glr_plot_corner_thumb.png" src="../_images/sphx_glr_plot_corner_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/features_detection/plot_corner.html#sphx-glr-auto-examples-features-detection-plot-corner-py"><span class="std std-ref">Corner detection</span></a></span></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="The CENSURE feature detector is a scale-invariant center-surround detector (CENSURE) that claim..."><div class="figure" id="id41">
<img alt="../_images/sphx_glr_plot_censure_thumb.png" src="../_images/sphx_glr_plot_censure_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/features_detection/plot_censure.html#sphx-glr-auto-examples-features-detection-plot-censure-py"><span class="std std-ref">CENSURE feature detector</span></a></span></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the ORB feature detection and binary description algorithm. It uses a..."><div class="figure" id="id42">
<img alt="../_images/sphx_glr_plot_orb_thumb.png" src="../_images/sphx_glr_plot_orb_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/features_detection/plot_orb.html#sphx-glr-auto-examples-features-detection-plot-orb-py"><span class="std std-ref">ORB feature detector and binary descriptor</span></a></span></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the BRIEF binary description algorithm. The descriptor consists of re..."><div class="figure" id="id43">
<img alt="../_images/sphx_glr_plot_brief_thumb.png" src="../_images/sphx_glr_plot_brief_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/features_detection/plot_brief.html#sphx-glr-auto-examples-features-detection-plot-brief-py"><span class="std std-ref">BRIEF binary descriptor</span></a></span></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example, we will see how to use geometric transformations in the context of image proce..."><div class="figure" id="id44">
<img alt="../_images/sphx_glr_plot_geometric_thumb.png" src="../_images/sphx_glr_plot_geometric_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/applications/plot_geometric.html#sphx-glr-auto-examples-applications-plot-geometric-py"><span class="std std-ref">Using geometric transformations</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="warp-coords">
<h2>warp_coords<a class="headerlink" href="#warp-coords" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.warp_coords">
<code class="descclassname">skimage.transform.</code><code class="descname">warp_coords</code><span class="sig-paren">(</span><em>coord_map</em>, <em>shape</em>, <em>dtype=&lt;class 'numpy.float64'&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_warps.py#L552"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.warp_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the source coordinates for the output of a 2-D image warp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>coord_map</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable like GeometricTransform.inverse</span></dt>
<dd><p class="first last">Return input coordinates for given output coordinates.
Coordinates are in the shape (P, 2), where P is the number
of coordinates and each element is a <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> pair.</p>
</dd>
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Shape of output image <code class="docutils literal notranslate"><span class="pre">(rows,</span> <span class="pre">cols[,</span> <span class="pre">bands])</span></code>.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.dtype or string</span></dt>
<dd><p class="first last">dtype for return value (sane choices: float32 or float64).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(ndim, rows, cols[, bands]) array of dtype <cite>dtype</cite></span></dt>
<dd><p class="first last">Coordinates for <cite>scipy.ndimage.map_coordinates</cite>, that will yield
an image of shape (orows, ocols, bands) by drawing from source
points according to the <cite>coord_transform_fn</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This is a lower-level routine that produces the source coordinates for 2-D
images used by <cite>warp()</cite>.</p>
<p>It is provided separately from <cite>warp</cite> to give additional flexibility to
users who would like, for example, to re-use a particular coordinate
mapping, to use specific dtypes at various points along the the
image-warping process, or to implement different post-processing logic
than <cite>warp</cite> performs after the call to <cite>ndi.map_coordinates</cite>.</p>
<p class="rubric">Examples</p>
<p>Produce a coordinate map that shifts an image up and to the right:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="k">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">map_coordinates</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_up10_left20</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">warp_coords</span><span class="p">(</span><span class="n">shift_up10_left20</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped_image</span> <span class="o">=</span> <span class="n">map_coordinates</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="estimate-transform">
<h2>estimate_transform<a class="headerlink" href="#estimate-transform" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.estimate_transform">
<code class="descclassname">skimage.transform.</code><code class="descname">estimate_transform</code><span class="sig-paren">(</span><em>ttype</em>, <em>src</em>, <em>dst</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L1306"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.estimate_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate 2D geometric transformation parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ttype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘euclidean’, similarity’, ‘affine’, ‘piecewise-affine’,              ‘projective’, ‘polynomial’}</span></dt>
<dd><p class="first last">Type of transform.</p>
</dd>
<dt><strong>kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array or int</span></dt>
<dd><p class="first">Function parameters (src, dst, n, angle):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>NAME / TTYPE        FUNCTION PARAMETERS
&#39;euclidean&#39;         `src, `dst`
&#39;similarity&#39;        `src, `dst`
&#39;affine&#39;            `src, `dst`
&#39;piecewise-affine&#39;  `src, `dst`
&#39;projective&#39;        `src, `dst`
&#39;polynomial&#39;        `src, `dst`, `order` (polynomial order,
                                          default order is 2)
</pre></div>
</div>
<p class="last">Also see examples below.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tform</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeometricTransform</span></code></span></dt>
<dd><p class="first last">Transform object containing the transformation parameters and providing
access to forward and inverse transformation functions.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="k">import</span> <span class="n">transform</span> <span class="k">as</span> <span class="n">tf</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimate transformation parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">estimate_transform</span><span class="p">(</span><span class="s1">&#39;similarity&#39;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">tform</span><span class="p">(</span><span class="n">src</span><span class="p">)),</span> <span class="n">src</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># warp image using the estimated transformation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="k">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">inverse_map</span><span class="o">=</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span> <span class="c1"># doctest: +SKIP</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># create transformation with explicit parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># unite transformations, applied in order from left to right</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform3</span> <span class="o">=</span> <span class="n">tform</span> <span class="o">+</span> <span class="n">tform2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">tform3</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">tform2</span><span class="p">(</span><span class="n">tform</span><span class="p">(</span><span class="n">src</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="matrix-transform">
<h2>matrix_transform<a class="headerlink" href="#matrix-transform" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.matrix_transform">
<code class="descclassname">skimage.transform.</code><code class="descname">matrix_transform</code><span class="sig-paren">(</span><em>coords</em>, <em>matrix</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L1380"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.matrix_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply 2D matrix transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">x, y coordinates to transform</p>
</dd>
<dt><strong>matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) array</span></dt>
<dd><p class="first last">Homogeneous transformation matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Transformed coordinates.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="swirl">
<h2>swirl<a class="headerlink" href="#swirl" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.swirl">
<code class="descclassname">skimage.transform.</code><code class="descname">swirl</code><span class="sig-paren">(</span><em>image</em>, <em>center=None</em>, <em>strength=1</em>, <em>radius=100</em>, <em>rotation=0</em>, <em>output_shape=None</em>, <em>order=1</em>, <em>mode='reflect'</em>, <em>cval=0</em>, <em>clip=True</em>, <em>preserve_range=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_warps.py#L466"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.swirl" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a swirl transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Input image.</p>
</dd>
<dt><strong>center</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(column, row) tuple or (2,) ndarray, optional</span></dt>
<dd><p class="first last">Center coordinate of transformation.</p>
</dd>
<dt><strong>strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">The amount of swirling applied.</p>
</dd>
<dt><strong>radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">The extent of the swirl in pixels.  The effect dies out
rapidly beyond <cite>radius</cite>.</p>
</dd>
<dt><strong>rotation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Additional rotation applied to the image.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>swirled</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Swirled version of the input.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>output_shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple (rows, cols), optional</span></dt>
<dd><p class="first last">Shape of the output image generated. By default the shape of the input
image is preserved.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The order of the spline interpolation, default is 1. The order has to
be in the range 0-5. See <cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt>
<dd><p class="first last">Points outside the boundaries of the input are filled according
to the given mode, with ‘constant’ used as the default. Modes match
the behaviour of <cite>numpy.pad</cite>.</p>
</dd>
<dt><strong>cval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-swirl">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.swirl</span></code><a class="headerlink" href="#examples-using-skimage-transform-swirl" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="Image swirling is a non-linear image deformation that creates a whirlpool effect.  This example..."><div class="figure" id="id45">
<img alt="../_images/sphx_glr_plot_swirl_thumb.png" src="../_images/sphx_glr_plot_swirl_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/transform/plot_swirl.html#sphx-glr-auto-examples-transform-plot-swirl-py"><span class="std std-ref">Swirl</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="resize">
<h2>resize<a class="headerlink" href="#resize" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.resize">
<code class="descclassname">skimage.transform.</code><code class="descname">resize</code><span class="sig-paren">(</span><em>image</em>, <em>output_shape</em>, <em>order=1</em>, <em>mode='reflect'</em>, <em>cval=0</em>, <em>clip=True</em>, <em>preserve_range=False</em>, <em>anti_aliasing=True</em>, <em>anti_aliasing_sigma=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_warps.py#L33"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize image to match a certain size.</p>
<p>Performs interpolation to up-size or down-size images. Note that anti-
aliasing should be enabled when down-sizing images to avoid aliasing
artifacts. For down-sampling N-dimensional images with an integer factor
also see <cite>skimage.transform.downscale_local_mean</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Input image.</p>
</dd>
<dt><strong>output_shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple or ndarray</span></dt>
<dd><p class="first last">Size of the generated output image <cite>(rows, cols[, …][, dim])</cite>. If
<cite>dim</cite> is not provided, the number of channels is preserved. In case the
number of input channels does not equal the number of output channels a
n-dimensional interpolation is applied.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>resized</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Resized version of the input.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The order of the spline interpolation, default is 1. The order has to
be in the range 0-5. See <cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt>
<dd><p class="first last">Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <cite>numpy.pad</cite>.</p>
</dd>
<dt><strong>cval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>anti_aliasing</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to apply a Gaussian filter to smooth the image prior to
down-scaling. It is crucial to filter when down-sampling the image to
avoid aliasing artifacts.</p>
</dd>
<dt><strong>anti_aliasing_sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{float, tuple of floats}, optional</span></dt>
<dd><p class="first last">Standard deviation for Gaussian filtering to avoid aliasing artifacts.
By default, this value is chosen as (1 - s) / 2 where s is the
down-scaling factor.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="k">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="k">import</span> <span class="n">resize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-resize">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.resize</span></code><a class="headerlink" href="#examples-using-skimage-transform-resize" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="`Rescale` operation resizes an image by a given scaling factor. The scaling factor can either b..."><div class="figure" id="id46">
<img alt="../_images/sphx_glr_plot_rescale_thumb.png" src="../_images/sphx_glr_plot_rescale_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/transform/plot_rescale.html#sphx-glr-auto-examples-transform-plot-rescale-py"><span class="std std-ref">Rescale, resize, and downscale</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="rotate">
<h2>rotate<a class="headerlink" href="#rotate" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.rotate">
<code class="descclassname">skimage.transform.</code><code class="descname">rotate</code><span class="sig-paren">(</span><em>image</em>, <em>angle</em>, <em>resize=False</em>, <em>center=None</em>, <em>order=1</em>, <em>mode='constant'</em>, <em>cval=0</em>, <em>clip=True</em>, <em>preserve_range=False</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_warps.py#L296"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate image by a certain angle around its center.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Input image.</p>
</dd>
<dt><strong>angle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Rotation angle in degrees in counter-clockwise direction.</p>
</dd>
<dt><strong>resize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Determine whether the shape of the output image will be automatically
calculated, so the complete rotated image exactly fits. Default is
False.</p>
</dd>
<dt><strong>center</strong> <span class="classifier-delimiter">:</span> <span class="classifier">iterable of length 2</span></dt>
<dd><p class="first last">The rotation center. If <code class="docutils literal notranslate"><span class="pre">center=None</span></code>, the image is rotated around
its center, i.e. <code class="docutils literal notranslate"><span class="pre">center=(cols</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">-</span> <span class="pre">0.5,</span> <span class="pre">rows</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">-</span> <span class="pre">0.5)</span></code>.  Please
note that this parameter is (cols, rows), contrary to normal skimage
ordering.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rotated</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Rotated version of the input.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The order of the spline interpolation, default is 1. The order has to
be in the range 0-5. See <cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt>
<dd><p class="first last">Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <cite>numpy.pad</cite>.</p>
</dd>
<dt><strong>cval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="k">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="k">import</span> <span class="n">rotate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(512, 512)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(530, 530)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(512, 512)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-rotate">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.rotate</span></code><a class="headerlink" href="#examples-using-skimage-transform-rotate" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the ORB feature detection and binary description algorithm. It uses a..."><div class="figure" id="id47">
<img alt="../_images/sphx_glr_plot_orb_thumb.png" src="../_images/sphx_glr_plot_orb_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/features_detection/plot_orb.html#sphx-glr-auto-examples-features-detection-plot-orb-py"><span class="std std-ref">ORB feature detector and binary descriptor</span></a></span></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example demonstrates the BRIEF binary description algorithm. The descriptor consists of re..."><div class="figure" id="id48">
<img alt="../_images/sphx_glr_plot_brief_thumb.png" src="../_images/sphx_glr_plot_brief_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/features_detection/plot_brief.html#sphx-glr-auto-examples-features-detection-plot-brief-py"><span class="std std-ref">BRIEF binary descriptor</span></a></span></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="Histogram matching can be used for object detection in images [1]_. This example extracts a sin..."><div class="figure" id="id49">
<img alt="../_images/sphx_glr_plot_windowed_histogram_thumb.png" src="../_images/sphx_glr_plot_windowed_histogram_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/features_detection/plot_windowed_histogram.html#sphx-glr-auto-examples-features-detection-plot-windowed-histogram-py"><span class="std std-ref">Sliding window histogram</span></a></span></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In this example, we will see how to classify textures based on LBP (Local Binary Pattern). LBP ..."><div class="figure" id="id50">
<img alt="../_images/sphx_glr_plot_local_binary_pattern_thumb.png" src="../_images/sphx_glr_plot_local_binary_pattern_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/features_detection/plot_local_binary_pattern.html#sphx-glr-auto-examples-features-detection-plot-local-binary-pattern-py"><span class="std std-ref">Local Binary Pattern for texture classification</span></a></span></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions."><div class="figure" id="id51">
<img alt="../_images/sphx_glr_plot_regionprops_thumb.png" src="../_images/sphx_glr_plot_regionprops_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="rescale">
<h2>rescale<a class="headerlink" href="#rescale" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.rescale">
<code class="descclassname">skimage.transform.</code><code class="descname">rescale</code><span class="sig-paren">(</span><em>image</em>, <em>scale</em>, <em>order=1</em>, <em>mode='reflect'</em>, <em>cval=0</em>, <em>clip=True</em>, <em>preserve_range=False</em>, <em>multichannel=None</em>, <em>anti_aliasing=True</em>, <em>anti_aliasing_sigma=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_warps.py#L200"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.rescale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale image by a certain factor.</p>
<p>Performs interpolation to up-scale or down-scale images. Note that anti-
aliasing should be enabled when down-sizing images to avoid aliasing
artifacts. For down-sampling N-dimensional images with an integer factor
also see <cite>skimage.transform.downscale_local_mean</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Input image.</p>
</dd>
<dt><strong>scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{float, tuple of floats}</span></dt>
<dd><p class="first last">Scale factors. Separate scale factors can be defined as
<cite>(rows, cols[, …][, dim])</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>scaled</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Scaled version of the input.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The order of the spline interpolation, default is 1. The order has to
be in the range 0-5. See <cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional</span></dt>
<dd><p class="first last">Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <cite>numpy.pad</cite>.</p>
</dd>
<dt><strong>cval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Used in conjunction with mode ‘constant’, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>multichannel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension. By default, is set to True for
3D (2D+color) inputs, and False for others. Starting in release 0.16,
this will always default to False.</p>
</dd>
<dt><strong>anti_aliasing</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether to apply a Gaussian filter to smooth the image prior to
down-scaling. It is crucial to filter when down-sampling the image to
avoid aliasing artifacts.</p>
</dd>
<dt><strong>anti_aliasing_sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{float, tuple of floats}, optional</span></dt>
<dd><p class="first last">Standard deviation for Gaussian filtering to avoid aliasing artifacts.
By default, this value is chosen as (1 - s) / 2 where s is the
down-scaling factor.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="k">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="k">import</span> <span class="n">rescale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(51, 51)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(256, 256)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-rescale">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.rescale</span></code><a class="headerlink" href="#examples-using-skimage-transform-rescale" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="`Rescale` operation resizes an image by a given scaling factor. The scaling factor can either b..."><div class="figure" id="id52">
<img alt="../_images/sphx_glr_plot_rescale_thumb.png" src="../_images/sphx_glr_plot_rescale_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/transform/plot_rescale.html#sphx-glr-auto-examples-transform-plot-rescale-py"><span class="std std-ref">Rescale, resize, and downscale</span></a></span></p>
</div>
</div><div class="sphx-glr-thumbcontainer" tooltip="In computed tomography, the tomography reconstruction problem is to obtain a tomographic slice ..."><div class="figure" id="id53">
<img alt="../_images/sphx_glr_plot_radon_transform_thumb.png" src="../_images/sphx_glr_plot_radon_transform_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/transform/plot_radon_transform.html#sphx-glr-auto-examples-transform-plot-radon-transform-py"><span class="std std-ref">Radon transform</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="downscale-local-mean">
<h2>downscale_local_mean<a class="headerlink" href="#downscale-local-mean" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.downscale_local_mean">
<code class="descclassname">skimage.transform.</code><code class="descname">downscale_local_mean</code><span class="sig-paren">(</span><em>image</em>, <em>factors</em>, <em>cval=0</em>, <em>clip=True</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_warps.py#L406"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.downscale_local_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Down-sample N-dimensional image by local averaging.</p>
<p>The image is padded with <cite>cval</cite> if it is not perfectly divisible by the
integer factors.</p>
<p>In contrast to the 2-D interpolation in <cite>skimage.transform.resize</cite> and
<cite>skimage.transform.rescale</cite> this function may be applied to N-dimensional
images and calculates the local mean of elements in each block of size
<cite>factors</cite> in the input image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">N-dimensional input image.</p>
</dd>
<dt><strong>factors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Array containing down-sampling integer factor along each axis.</p>
</dd>
<dt><strong>cval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Constant padding value if image is not perfectly divisible by the
integer factors.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Down-sampled image with same number of dimensions as input image.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3,  4],</span>
<span class="go">       [ 5,  6,  7,  8,  9],</span>
<span class="go">       [10, 11, 12, 13, 14]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">downscale_local_mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([[ 3.5,  4. ],</span>
<span class="go">       [ 5.5,  4.5]])</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-downscale-local-mean">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.downscale_local_mean</span></code><a class="headerlink" href="#examples-using-skimage-transform-downscale-local-mean" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="`Rescale` operation resizes an image by a given scaling factor. The scaling factor can either b..."><div class="figure" id="id54">
<img alt="../_images/sphx_glr_plot_rescale_thumb.png" src="../_images/sphx_glr_plot_rescale_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/transform/plot_rescale.html#sphx-glr-auto-examples-transform-plot-rescale-py"><span class="std std-ref">Rescale, resize, and downscale</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="pyramid-reduce">
<h2>pyramid_reduce<a class="headerlink" href="#pyramid-reduce" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_reduce">
<code class="descclassname">skimage.transform.</code><code class="descname">pyramid_reduce</code><span class="sig-paren">(</span><em>image</em>, <em>downscale=2</em>, <em>sigma=None</em>, <em>order=1</em>, <em>mode='reflect'</em>, <em>cval=0</em>, <em>multichannel=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/pyramids.py#L27"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.pyramid_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth and then downsample image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Input image.</p>
</dd>
<dt><strong>downscale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Downscale factor.</p>
</dd>
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Sigma for Gaussian filter. Default is <cite>2 * downscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Order of splines used in interpolation of downsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt>
<dd><p class="first last">The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>multichannel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension. By default, is set to True for
3D (2D+color) inputs, and False for others. Starting in release 0.16,
this will always default to False.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Smoothed and downsampled float image.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r4f51c9e42c4a-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[1]</a></td><td><a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="pyramid-expand">
<h2>pyramid_expand<a class="headerlink" href="#pyramid-expand" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_expand">
<code class="descclassname">skimage.transform.</code><code class="descname">pyramid_expand</code><span class="sig-paren">(</span><em>image</em>, <em>upscale=2</em>, <em>sigma=None</em>, <em>order=1</em>, <em>mode='reflect'</em>, <em>cval=0</em>, <em>multichannel=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/pyramids.py#L85"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.pyramid_expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Upsample and then smooth image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Input image.</p>
</dd>
<dt><strong>upscale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Upscale factor.</p>
</dd>
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Sigma for Gaussian filter. Default is <cite>2 * upscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Order of splines used in interpolation of upsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt>
<dd><p class="first last">The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>multichannel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension. By default, is set to True for
3D (2D+color) inputs, and False for others. Starting in release 0.16,
this will always default to False.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Upsampled and smoothed float image.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r53df52222c6d-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[1]</a></td><td><a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="pyramid-gaussian">
<h2>pyramid_gaussian<a class="headerlink" href="#pyramid-gaussian" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_gaussian">
<code class="descclassname">skimage.transform.</code><code class="descname">pyramid_gaussian</code><span class="sig-paren">(</span><em>image</em>, <em>max_layer=-1</em>, <em>downscale=2</em>, <em>sigma=None</em>, <em>order=1</em>, <em>mode='reflect'</em>, <em>cval=0</em>, <em>multichannel=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/pyramids.py#L144"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.pyramid_gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield images of the Gaussian pyramid formed by the input image.</p>
<p>Recursively applies the <cite>pyramid_reduce</cite> function to the image, and yields
the downscaled images.</p>
<p>Note that the first image of the pyramid will be the original, unscaled
image. The total number of images is <cite>max_layer + 1</cite>. In case all layers
are computed, the last image is either a one-pixel image or the image where
the reduction does not change its shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Input image.</p>
</dd>
<dt><strong>max_layer</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</dd>
<dt><strong>downscale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Downscale factor.</p>
</dd>
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Sigma for Gaussian filter. Default is <cite>2 * downscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Order of splines used in interpolation of downsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt>
<dd><p class="first last">The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>multichannel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension. By default, is set to True for
3D (2D+color) inputs, and False for others. Starting in release 0.16,
this will always default to False.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pyramid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">generator</span></dt>
<dd><p class="first last">Generator yielding pyramid layers as float images.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r4f1da659b730-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[1]</a></td><td><a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

<div class="section" id="examples-using-skimage-transform-pyramid-gaussian">
<h3>Examples using <code class="docutils literal notranslate"><span class="pre">skimage.transform.pyramid_gaussian</span></code><a class="headerlink" href="#examples-using-skimage-transform-pyramid-gaussian" title="Permalink to this headline">¶</a></h3>
<div class="sphx-glr-thumbcontainer" tooltip="The ``pyramid_gaussian`` function takes an image and yields successive images shrunk by a const..."><div class="figure" id="id55">
<img alt="../_images/sphx_glr_plot_pyramid_thumb.png" src="../_images/sphx_glr_plot_pyramid_thumb.png" />
<p class="caption"><span class="caption-text"><a class="reference internal" href="../auto_examples/transform/plot_pyramid.html#sphx-glr-auto-examples-transform-plot-pyramid-py"><span class="std std-ref">Build image pyramids</span></a></span></p>
</div>
</div></div>
</div>
<div class="section" id="pyramid-laplacian">
<h2>pyramid_laplacian<a class="headerlink" href="#pyramid-laplacian" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.pyramid_laplacian">
<code class="descclassname">skimage.transform.</code><code class="descname">pyramid_laplacian</code><span class="sig-paren">(</span><em>image</em>, <em>max_layer=-1</em>, <em>downscale=2</em>, <em>sigma=None</em>, <em>order=1</em>, <em>mode='reflect'</em>, <em>cval=0</em>, <em>multichannel=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/pyramids.py#L224"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.pyramid_laplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield images of the laplacian pyramid formed by the input image.</p>
<p>Each layer contains the difference between the downsampled and the
downsampled, smoothed image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">layer</span> <span class="o">=</span> <span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">)</span> <span class="o">-</span> <span class="n">smooth</span><span class="p">(</span><span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that the first image of the pyramid will be the difference between the
original, unscaled image and its smoothed version. The total number of
images is <cite>max_layer + 1</cite>. In case all layers are computed, the last image
is either a one-pixel image or the image where the reduction does not
change its shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>image</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Input image.</p>
</dd>
<dt><strong>max_layer</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</dd>
<dt><strong>downscale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Downscale factor.</p>
</dd>
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Sigma for Gaussian filter. Default is <cite>2 * downscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Order of splines used in interpolation of downsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional</span></dt>
<dd><p class="first last">The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to ‘constant’.</p>
</dd>
<dt><strong>cval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Value to fill past edges of input if mode is ‘constant’.</p>
</dd>
<dt><strong>multichannel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension. By default, is set to True for
3D (2D+color) inputs, and False for others. Starting in release 0.16,
this will always default to False.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pyramid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">generator</span></dt>
<dd><p class="first last">Generator yielding pyramid layers as float images.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r64565393f7ed-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[1]</a></td><td><a class="reference external" href="http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf">http://web.mit.edu/persci/people/adelson/pub_pdfs/pyramid83.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r64565393f7ed-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[2]</a></td><td><a class="reference external" href="http://sepwww.stanford.edu/data/media/public/sep/morgan/texturematch/paper_html/node3.html">http://sepwww.stanford.edu/data/media/public/sep/morgan/texturematch/paper_html/node3.html</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="seam-carve">
<h2>seam_carve<a class="headerlink" href="#seam-carve" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.seam_carve">
<code class="descclassname">skimage.transform.</code><code class="descname">seam_carve</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/seam_carving.py"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.seam_carve" title="Permalink to this definition">¶</a></dt>
<dd><p>Seam carving has been removed because it is a patented algorithm.</p>
<p>See <a class="reference external" href="https://github.com/scikit-image/scikit-image/issues/3646">https://github.com/scikit-image/scikit-image/issues/3646</a></p>
</dd></dl>

</div>
<div class="section" id="euclideantransform">
<h2><a class="reference internal" href="#skimage.transform.EuclideanTransform" title="skimage.transform.EuclideanTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">EuclideanTransform</span></code></a><a class="headerlink" href="#euclideantransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.EuclideanTransform">
<em class="property">class </em><code class="descclassname">skimage.transform.</code><code class="descname">EuclideanTransform</code><span class="sig-paren">(</span><em>matrix=None</em>, <em>rotation=None</em>, <em>translation=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L941"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.EuclideanTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.ProjectiveTransform</span></code></p>
<p>2D Euclidean transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">a1</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span>
</pre></div>
</div>
<p>where the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">b0</span>  <span class="n">a1</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">a0</span>  <span class="n">b1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>The Euclidean transformation is a rigid transformation with rotation and
translation parameters. The similarity transformation extends the Euclidean
transformation with a single scaling factor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) array, optional</span></dt>
<dd><p class="first last">Homogeneous transformation matrix.</p>
</dd>
<dt><strong>rotation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Rotation angle in counter-clockwise direction as radians.</p>
</dd>
<dt><strong>translation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(tx, ty) as array, list or tuple, optional</span></dt>
<dd><p class="first last">x, y translation parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) array</span></dt>
<dd><p class="first last">Homogeneous transformation matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.EuclideanTransform.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>matrix=None</em>, <em>rotation=None</em>, <em>translation=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L978"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.EuclideanTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.EuclideanTransform.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L1005"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.EuclideanTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>src</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Source coordinates.</p>
</dd>
<dt><strong>dst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Destination coordinates.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>success</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True, if model estimation succeeds.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="skimage.transform.EuclideanTransform.rotation">
<code class="descname">rotation</code><a class="headerlink" href="#skimage.transform.EuclideanTransform.rotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.EuclideanTransform.translation">
<code class="descname">translation</code><a class="headerlink" href="#skimage.transform.EuclideanTransform.translation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="similaritytransform">
<h2><a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimilarityTransform</span></code></a><a class="headerlink" href="#similaritytransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.SimilarityTransform">
<em class="property">class </em><code class="descclassname">skimage.transform.</code><code class="descname">SimilarityTransform</code><span class="sig-paren">(</span><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>translation=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L1040"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.SimilarityTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.EuclideanTransform</span></code></p>
<p>2D similarity transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">a1</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">s</span></code> is a scale factor and the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">b0</span>  <span class="n">a1</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">a0</span>  <span class="n">b1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>The similarity transformation extends the Euclidean transformation with a
single scaling factor in addition to the rotation and translation
parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) array, optional</span></dt>
<dd><p class="first last">Homogeneous transformation matrix.</p>
</dd>
<dt><strong>scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Scale factor.</p>
</dd>
<dt><strong>rotation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Rotation angle in counter-clockwise direction as radians.</p>
</dd>
<dt><strong>translation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(tx, ty) as array, list or tuple, optional</span></dt>
<dd><p class="first last">x, y translation parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) array</span></dt>
<dd><p class="first last">Homogeneous transformation matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.SimilarityTransform.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>translation=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L1079"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.SimilarityTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.SimilarityTransform.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L1110"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.SimilarityTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>src</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Source coordinates.</p>
</dd>
<dt><strong>dst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Destination coordinates.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>success</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True, if model estimation succeeds.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="skimage.transform.SimilarityTransform.scale">
<code class="descname">scale</code><a class="headerlink" href="#skimage.transform.SimilarityTransform.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="affinetransform">
<h2><a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">AffineTransform</span></code></a><a class="headerlink" href="#affinetransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.AffineTransform">
<em class="property">class </em><code class="descclassname">skimage.transform.</code><code class="descname">AffineTransform</code><span class="sig-paren">(</span><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>shear=None</em>, <em>translation=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L714"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.AffineTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.ProjectiveTransform</span></code></p>
<p>2D affine transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">sx</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">sy</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">rotation</span> <span class="o">+</span> <span class="n">shear</span><span class="p">)</span> <span class="o">+</span> <span class="n">a2</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">sx</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">sy</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">rotation</span> <span class="o">+</span> <span class="n">shear</span><span class="p">)</span> <span class="o">+</span> <span class="n">b2</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">sx</span></code> and <code class="docutils literal notranslate"><span class="pre">sy</span></code> are scale factors in the x and y directions,
and the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">a1</span>  <span class="n">a2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">b1</span>  <span class="n">b2</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) array, optional</span></dt>
<dd><p class="first last">Homogeneous transformation matrix.</p>
</dd>
<dt><strong>scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(sx, sy) as array, list or tuple, optional</span></dt>
<dd><p class="first last">Scale factors.</p>
</dd>
<dt><strong>rotation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Rotation angle in counter-clockwise direction as radians.</p>
</dd>
<dt><strong>shear</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Shear angle in counter-clockwise direction as radians.</p>
</dd>
<dt><strong>translation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(tx, ty) as array, list or tuple, optional</span></dt>
<dd><p class="first last">Translation parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) array</span></dt>
<dd><p class="first last">Homogeneous transformation matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.AffineTransform.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>shear=None</em>, <em>translation=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L754"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.AffineTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.rotation">
<code class="descname">rotation</code><a class="headerlink" href="#skimage.transform.AffineTransform.rotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.scale">
<code class="descname">scale</code><a class="headerlink" href="#skimage.transform.AffineTransform.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.shear">
<code class="descname">shear</code><a class="headerlink" href="#skimage.transform.AffineTransform.shear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.translation">
<code class="descname">translation</code><a class="headerlink" href="#skimage.transform.AffineTransform.translation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="projectivetransform">
<h2><a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProjectiveTransform</span></code></a><a class="headerlink" href="#projectivetransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.ProjectiveTransform">
<em class="property">class </em><code class="descclassname">skimage.transform.</code><code class="descname">ProjectiveTransform</code><span class="sig-paren">(</span><em>matrix=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L494"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.GeometricTransform</span></code></p>
<p>Projective transformation.</p>
<p>Apply a projective transformation (homography) on coordinates.</p>
<p>For each homogeneous coordinate <span class="math notranslate nohighlight">\(\mathbf{x} = [x, y, 1]^T\)</span>, its
target position is calculated by multiplying with the given matrix,
<span class="math notranslate nohighlight">\(H\)</span>, to give <span class="math notranslate nohighlight">\(H \mathbf{x}\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">c0</span> <span class="n">c1</span> <span class="mi">1</span> <span class="p">]]</span><span class="o">.</span>
</pre></div>
</div>
<p>E.g., to rotate by theta degrees clockwise, the matrix should be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>  <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>            <span class="mi">0</span>         <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>or, to translate x by 10 and y by 20:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">10</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">20</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">]]</span><span class="o">.</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) array, optional</span></dt>
<dd><p class="first last">Homogeneous transformation matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) array</span></dt>
<dd><p class="first last">Homogeneous transformation matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.ProjectiveTransform.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>matrix=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L533"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.ProjectiveTransform.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L590"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">c0</span> <span class="n">c1</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<p>In case of the affine transformation the coefficients c0 and c1 are 0.
Thus the system of equations is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>src</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Source coordinates.</p>
</dd>
<dt><strong>dst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Destination coordinates.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>success</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True, if model estimation succeeds.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.ProjectiveTransform.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L574"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.ProjectiveTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Destination coordinates.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Source coordinates.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="essentialmatrixtransform">
<h2><a class="reference internal" href="#skimage.transform.EssentialMatrixTransform" title="skimage.transform.EssentialMatrixTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">EssentialMatrixTransform</span></code></a><a class="headerlink" href="#essentialmatrixtransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.EssentialMatrixTransform">
<em class="property">class </em><code class="descclassname">skimage.transform.</code><code class="descname">EssentialMatrixTransform</code><span class="sig-paren">(</span><em>rotation=None</em>, <em>translation=None</em>, <em>matrix=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L396"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.EssentialMatrixTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.FundamentalMatrixTransform</span></code></p>
<p>Essential matrix transformation.</p>
<p>The essential matrix relates corresponding points between a pair of
calibrated images. The matrix transforms normalized, homogeneous image
points in one image to epipolar lines in the other image.</p>
<p>The essential matrix is only defined for a pair of moving images capturing a
non-planar scene. In the case of pure rotation or planar scenes, the
homography describes the geometric relation between two images
(<cite>ProjectiveTransform</cite>). If the intrinsic calibration of the images is
unknown, the fundamental matrix describes the projective relation between
the two images (<cite>FundamentalMatrixTransform</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rotation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) array, optional</span></dt>
<dd><p class="first last">Rotation matrix of the relative camera motion.</p>
</dd>
<dt><strong>translation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 1) array, optional</span></dt>
<dd><p class="first last">Translation vector of the relative camera motion. The vector must
have unit length.</p>
</dd>
<dt><strong>matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) array, optional</span></dt>
<dd><p class="first last">Essential matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r2fbde33858f1-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id24">[1]</a></td><td>Hartley, Richard, and Andrew Zisserman. Multiple view geometry in
computer vision. Cambridge university press, 2003.</td></tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) array</span></dt>
<dd><p class="first last">Essential matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.EssentialMatrixTransform.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>rotation=None</em>, <em>translation=None</em>, <em>matrix=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L432"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.EssentialMatrixTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.EssentialMatrixTransform.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L457"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.EssentialMatrixTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate essential matrix using 8-point algorithm.</p>
<p>The 8-point algorithm requires at least 8 corresponding point pairs for
a well-conditioned solution, otherwise the over-determined solution is
estimated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>src</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Source coordinates.</p>
</dd>
<dt><strong>dst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Destination coordinates.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>success</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True, if model estimation succeeds.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="fundamentalmatrixtransform">
<h2><a class="reference internal" href="#skimage.transform.FundamentalMatrixTransform" title="skimage.transform.FundamentalMatrixTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">FundamentalMatrixTransform</span></code></a><a class="headerlink" href="#fundamentalmatrixtransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.FundamentalMatrixTransform">
<em class="property">class </em><code class="descclassname">skimage.transform.</code><code class="descname">FundamentalMatrixTransform</code><span class="sig-paren">(</span><em>matrix=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L210"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.GeometricTransform</span></code></p>
<p>Fundamental matrix transformation.</p>
<p>The fundamental matrix relates corresponding points between a pair of
uncalibrated images. The matrix transforms homogeneous image points in one
image to epipolar lines in the other image.</p>
<p>The fundamental matrix is only defined for a pair of moving images. In the
case of pure rotation or planar scenes, the homography describes the
geometric relation between two images (<cite>ProjectiveTransform</cite>). If the
intrinsic calibration of the images is known, the essential matrix describes
the metric relation between the two images (<cite>EssentialMatrixTransform</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>matrix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) array, optional</span></dt>
<dd><p class="first last">Fundamental matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r725e3a484348-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[1]</a></td><td>Hartley, Richard, and Andrew Zisserman. Multiple view geometry in
computer vision. Cambridge university press, 2003.</td></tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) array</span></dt>
<dd><p class="first last">Fundamental matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.FundamentalMatrixTransform.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>matrix=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L240"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.FundamentalMatrixTransform.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L332"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate fundamental matrix using 8-point algorithm.</p>
<p>The 8-point algorithm requires at least 8 corresponding point pairs for
a well-conditioned solution, otherwise the over-determined solution is
estimated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>src</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Source coordinates.</p>
</dd>
<dt><strong>dst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Destination coordinates.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>success</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True, if model estimation succeeds.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.FundamentalMatrixTransform.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L265"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Destination coordinates.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 3) array</span></dt>
<dd><p class="first last">Epipolar lines in the source image.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.FundamentalMatrixTransform.residuals">
<code class="descname">residuals</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L366"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.FundamentalMatrixTransform.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Sampson distance.</p>
<p>The Sampson distance is the first approximation to the geometric error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>src</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Source coordinates.</p>
</dd>
<dt><strong>dst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Destination coordinates.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>residuals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, ) array</span></dt>
<dd><p class="first last">Sampson distance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="polynomialtransform">
<h2><a class="reference internal" href="#skimage.transform.PolynomialTransform" title="skimage.transform.PolynomialTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolynomialTransform</span></code></a><a class="headerlink" href="#polynomialtransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.PolynomialTransform">
<em class="property">class </em><code class="descclassname">skimage.transform.</code><code class="descname">PolynomialTransform</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L1146"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.GeometricTransform</span></code></p>
<p>2D polynomial transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
<span class="n">Y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(2, N) array, optional</span></dt>
<dd><p class="first last">Polynomial coefficients where <cite>N * 2 = (order + 1) * (order + 2)</cite>. So,
a_ji is defined in <cite>params[0, :]</cite> and b_ji in <cite>params[1, :]</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(2, N) array</span></dt>
<dd><p class="first last">Polynomial coefficients where <cite>N * 2 = (order + 1) * (order + 2)</cite>. So,
a_ji is defined in <cite>params[0, :]</cite> and b_ji in <cite>params[1, :]</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.PolynomialTransform.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L1168"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.PolynomialTransform.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em>, <em>order=2</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L1176"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
<span class="n">Y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span> <span class="n">x</span> <span class="n">y</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">...</span> <span class="mi">0</span> <span class="o">...</span>             <span class="mi">0</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="o">...</span>                 <span class="mi">0</span> <span class="mi">1</span> <span class="n">x</span> <span class="n">y</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a00</span> <span class="n">a10</span> <span class="n">a11</span> <span class="n">a20</span> <span class="n">a21</span> <span class="n">a22</span> <span class="o">...</span> <span class="n">ann</span>
       <span class="n">b00</span> <span class="n">b10</span> <span class="n">b11</span> <span class="n">b20</span> <span class="n">b21</span> <span class="n">b22</span> <span class="o">...</span> <span class="n">bnn</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>src</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Source coordinates.</p>
</dd>
<dt><strong>dst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Destination coordinates.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Polynomial order (number of coefficients is order + 1).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>success</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True, if model estimation succeeds.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.PolynomialTransform.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L1286"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PolynomialTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Destination coordinates.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Source coordinates.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="piecewiseaffinetransform">
<h2><a class="reference internal" href="#skimage.transform.PiecewiseAffineTransform" title="skimage.transform.PiecewiseAffineTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseAffineTransform</span></code></a><a class="headerlink" href="#piecewiseaffinetransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.PiecewiseAffineTransform">
<em class="property">class </em><code class="descclassname">skimage.transform.</code><code class="descname">PiecewiseAffineTransform</code><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L807"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">skimage.transform._geometric.GeometricTransform</span></code></p>
<p>2D piecewise affine transformation.</p>
<p>Control points are used to define the mapping. The transform is based on
a Delaunay triangulation of the points to form a mesh. Each triangle is
used to find a local affine transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>affines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of AffineTransform objects</span></dt>
<dd><p class="first last">Affine transformations for each triangle in the mesh.</p>
</dd>
<dt><strong>inverse_affines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of AffineTransform objects</span></dt>
<dd><p class="first last">Inverse affine transformations for each triangle in the mesh.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.PiecewiseAffineTransform.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L823"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.PiecewiseAffineTransform.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L829"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>Number of source and destination coordinates must match.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>src</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Source coordinates.</p>
</dd>
<dt><strong>dst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Destination coordinates.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>success</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True, if model estimation succeeds.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.PiecewiseAffineTransform.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.15.0/skimage/transform/_geometric.py#L905"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#skimage.transform.PiecewiseAffineTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse transformation.</p>
<p>Coordinates outside of the mesh will be set to <cite>- 1</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Source coordinates.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) array</span></dt>
<dd><p class="first last">Transformed coordinates.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


        </div>
    </div>
    <div class="well footer">
        <small>
            &copy; Copyright the scikit-image development team.
            Created using <a href="http://getbootstrap.com/">Bootstrap</a> and <a href="http://sphinx-doc.org/">Sphinx</a>.
        </small>
    </div>
</body>
</html>


<!-- Piwik -->
<script type="text/javascript">
  var _paq = _paq || [];
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//piwik.sciunto.org/piwik/";
    _paq.push(['setTrackerUrl', u+'piwik.php']);
    _paq.push(['setSiteId', 2]);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<noscript><p><img src="//piwik.sciunto.org/piwik/piwik.php?idsite=2" style="border:0;" alt="" /></p></noscript>
<!-- End Piwik Code -->